
/*
*
*	SYNAPSE X
*	File.:	DataBin.hpp
*	Desc.:	Container classes for data
*
*/

#pragma once

#include "../Misc/Static.hpp"

namespace syn
{
    class IBin
    {
    private:
        uintptr_t _value;
        bool _is_final;
    public:
        uintptr_t Value() const
        {
            return _value;
        }

        void Set(unsigned long value)
        {
            _value = value;
        }

        bool IsFinal() const
        {
            return _is_final;
        }

        bool Finalize()
        {
            if (_is_final)
                return false;

            _is_final = true;

            return true;
        }

        IBin()
            : _value(NULL),
              _is_final(false) {}
    };

    class OffsetBin final : public IBin
    {
    public:
        enum StreamSource
        {
            Remote,
            Local,
            Static
        };
    private:
        StreamSource _strm_source;
    public:
        StreamSource IsFrom() const
        {
            return _strm_source;
        }

        OffsetBin(bool needsrebase, StreamSource source = StreamSource::Remote, uintptr_t defval = 0) : IBin()
        {
            _strm_source = source;
            Set(needsrebase ? RobloxBase(defval) : defval);
            Finalize();
        }

    };

    class BinManager final
    {
    private:
        std::unordered_map<uint32_t, IBin*> _bin_map;
    public:
        using BinIterator = void(*)(IBin*);
        static __declspec(noinline) BinManager* GetSingleton() noexcept
        {
            static BinManager* binm = nullptr;
            if (binm == nullptr)
                binm = new BinManager();

            return binm;
        }

        void ForEach(BinIterator it)
        {
            for (const auto& [key, value] : _bin_map) it(value);
        }

        IBin* GetBin(const uint32_t bin_hash) const noexcept
        {
            if (_bin_map.find(bin_hash) != _bin_map.end())
                return _bin_map.at(bin_hash);

            return nullptr;
        }

        bool HasBin(const uint32_t bin_hash) const
        {
            return GetBin(bin_hash) != nullptr;
        }

        bool Collect(const uint32_t bin_hash, IBin* bin)
        {
            if (HasBin(bin_hash))
                return false;

            _bin_map[bin_hash] = bin;

            return true;
        }

        bool Delete(const uint32_t bin_hash)
        {
            if (_bin_map.find(bin_hash) != _bin_map.end())
            {
                _bin_map.erase(bin_hash);
                return true;
            }

            return false;
        }

        unsigned int Count() const
        {
            return _bin_map.size();
        }
    };
}