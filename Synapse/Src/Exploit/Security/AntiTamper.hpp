#pragma once

#include "../../Utilities/Hashing/XXHash/xxhash.h"
#include "../../Utilities/Utils.hpp"

namespace syn::AntiTamper
{
    struct SecHash32
    {
        uintptr_t Location;
        uint32_t Size;
        uint32_t Hash;
        uint32_t Nonce;
    };

    struct SecHash64
    {
        uintptr_t Location;
        uint32_t Size;
        uint64_t Hash;
        uint64_t Nonce;
    };

    enum SecCheckResult
    {
        OK,

        INVALID_HASH_32,
        INVALID_HASH_64,

        INVALID_MASTER_HASH_32,
        INVALID_MASTER_HASH_64
    };

    extern std::vector<SecHash32> Hashes32;
    extern std::vector<SecHash64> Hashes64;

    extern uint32_t MasterHash32;
    extern uint64_t MasterHash64;

    extern uint32_t Master32;
    extern uint64_t Master64;

    extern uint32_t Counter32;
    extern uint32_t Counter64;

    __declspec(noinline) bool Setup();

    FORCEINLINE XXH32_state_t* HashInit32(uint32_t Secret)
    {
        XXH32_state_t* const state = XXH32_createState();
        if (!state)
            return nullptr;

        XXH_errorcode const resetResult = XXH32_reset(state, Secret);
        if (resetResult == XXH_ERROR)
            return 0;

        return state;
    }

    FORCEINLINE void HashFeed32(XXH32_state_t* state, uintptr_t Location, uint32_t Size)
    {
        size_t Position = Location;
        size_t TotalBlocks = Size / 16;
        size_t RemainingSize = Size - (TotalBlocks * 16);

        while (TotalBlocks--)
        {
            XXH32_update(state, (void*)Position, 16);
            Position += 16;
        }

        /* Hash end of region if needed */
        if (RemainingSize != 0)
            XXH32_update(state, (void*)Position, RemainingSize);
    }

    FORCEINLINE uint32_t HashDigest32(XXH32_state_t* state)
    {
        XXH32_hash_t hash = XXH32_digest(state);

        XXH32_freeState(state);

        return hash;
    }

    FORCEINLINE uint32_t HashRegion32(uintptr_t Location, uint32_t Size, uint32_t Secret)
    {
        XXH32_state_t* const state = HashInit32(Secret);
        if (!state)
            return 0;

        HashFeed32(state, Location, Size);

        return HashDigest32(state);
    }

    FORCEINLINE XXH64_state_t* HashInit64(uint64_t Secret)
    {
        XXH64_state_t* const state = XXH64_createState();
        if (!state)
            return nullptr;

        XXH_errorcode const resetResult = XXH64_reset(state, Secret);
        if (resetResult == XXH_ERROR)
            return 0;

        return state;
    }

    FORCEINLINE void HashFeed64(XXH64_state_t* state, uintptr_t Location, uint32_t Size)
    {
        size_t Position = Location;
        size_t TotalBlocks = Size / 32;
        size_t RemainingSize = Size - (TotalBlocks * 32);

        while (TotalBlocks--)
        {
            XXH64_update(state, (void*)Position, 32);
            Position += 32;
        }

        /* Hash end of region if needed */
        if (RemainingSize != 0)
            XXH64_update(state, (void*)Position, RemainingSize);
    }

    FORCEINLINE uint64_t HashDigest64(XXH64_state_t* state)
    {
        XXH64_hash_t hash = XXH64_digest(state);

        XXH64_freeState(state);

        return hash;
    }

    FORCEINLINE uint64_t HashRegion64(uintptr_t Location, uint32_t Size, uint64_t Secret)
    {
        XXH64_state_t* const state = HashInit64(Secret);
        if (!state)
            return 0;

        HashFeed64(state, Location, Size);

        return HashDigest64(state);
    }

    FORCEINLINE SecCheckResult CheckFull()
    {
#ifndef _DEBUG
        const auto SelectedHasher = __rdtsc() % 2 == 1;

        if (SelectedHasher)
        {
            //64 bit hasher
            XXH64_state_t* CurrentMaster = HashInit64(Master64);

            for (auto Hash : Hashes64)
            {
                uint64_t CalcHash = HashRegion64(Hash.Location, Hash.Size, Hash.Nonce * Master64);

                HashFeed64(CurrentMaster, (uintptr_t)& Hash, sizeof(SecHash64));

                if (CalcHash != Hash.Hash)
                    return INVALID_HASH_64;
            }

            if (HashDigest64(CurrentMaster) != MasterHash64)
                return INVALID_MASTER_HASH_64;
        }
        else
        {
            //32 bit hasher
            XXH32_state_t* CurrentMaster = HashInit32(Master32);

            for (auto Hash : Hashes32)
            {
                const auto CalcHash = HashRegion32(Hash.Location, Hash.Size, Hash.Nonce * Master32);

                HashFeed32(CurrentMaster, (uintptr_t)& Hash, sizeof(SecHash32));

                if (CalcHash != Hash.Hash)
                    return INVALID_HASH_32;
            }

            if (HashDigest32(CurrentMaster) != MasterHash32)
                return INVALID_MASTER_HASH_32;
        }
#endif

        return OK;
    }

    __forceinline SecCheckResult CheckIncrement()
    {
#ifndef _DEBUG
        const auto SelectedHasher = __rdtsc() % 2 == 1;

        if (SelectedHasher)
        {
            //64 bit hasher
            if (Counter64 >= Hashes64.size())
            {
                Counter64 = 0;

                XXH64_state_t* CurrentMaster = HashInit64(Master64);

                for (auto Hash : Hashes64)
                {
                    HashFeed64(CurrentMaster, (uintptr_t)& Hash, sizeof(SecHash64));
                }

                if (HashDigest64(CurrentMaster) != MasterHash64)
                    return INVALID_MASTER_HASH_64;

                return OK;
            }

            const auto Hash = Hashes64.at(Counter64);
            const auto CalcHash = HashRegion64(Hash.Location, Hash.Size, Hash.Nonce * Master64);

            if (Hash.Hash != CalcHash)
                return INVALID_HASH_64;

            Counter64++;
        }
        else
        {
            //32 bit hasher
            if (Counter32 >= Hashes32.size())
            {
                Counter32 = 0;

                XXH32_state_t* CurrentMaster = HashInit32(Master32);

                for (auto Hash : Hashes32)
                {
                    HashFeed32(CurrentMaster, (uintptr_t)& Hash, sizeof(SecHash32));
                }

                if (HashDigest32(CurrentMaster) != MasterHash32)
                    return INVALID_MASTER_HASH_32;

                return OK;
            }

            const auto Hash = Hashes32.at(Counter32);
            const auto CalcHash = HashRegion32(Hash.Location, Hash.Size, Hash.Nonce * Master32);

            if (Hash.Hash != CalcHash)
                return INVALID_HASH_32;

            Counter32++;
        }
#endif

        return OK;
    }
}
