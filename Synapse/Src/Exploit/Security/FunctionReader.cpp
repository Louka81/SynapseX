#include "../Misc/Static.hpp"
#include "./PEBUnlink.hpp"
#include "../Misc/Profiler.hpp"
#include "./FunctionReader.hpp"

#include <DbgHelp.h>

namespace syn
{
    HMODULE FindModule(const char* lpModuleName)
    {
	    auto Prof = syn::Profiler::GetSingleton();

        /* Convert to wide char so I can use the enc on the arugments */
        const auto NameLen = strlen(lpModuleName);
        auto DllName = std::make_unique<wchar_t[]>(NameLen + 1);

        mbstowcs(DllName.get(), lpModuleName, NameLen + 1);

        const auto StartEntry = GetLoadOrderModuleList();
        auto CurrentEntry = (PLDR_MODULE) StartEntry->InLoadOrderModuleList.Flink;

        size_t Count = 255;
        while (Count-- && StartEntry != CurrentEntry)
        {
	        const auto DllNameLen = CurrentEntry->FullDllName.Length / sizeof(wchar_t);
            if (DllNameLen > NameLen)
            {
                std::unique_ptr<wchar_t[]> Buff = std::make_unique<wchar_t[]>(DllNameLen + 1); /* Length doesn't include terminator */
                ZeroMemory(Buff.get(), DllNameLen + 1);

                wmemcpy(Buff.get(), &CurrentEntry->FullDllName.Buffer[DllNameLen - NameLen], NameLen);

                if (!_wcsnicmp(Buff.get(), DllName.get(), NameLen))
                    return (HMODULE) CurrentEntry->BaseAddress;
            }

			CurrentEntry = (LDR_MODULE*)CurrentEntry->InLoadOrderModuleList.Flink;
        }

        /* Fall back */
		Prof->AddProfile(OBFUSCATE_STR("FindModule failed to module, falling back"));
        return GetModuleHandle(lpModuleName);
    }

    PVOID FindProcAddress(HMODULE hModule, const char* lpProcName)
    {
        syn::Profiler* prof = syn::Profiler::GetSingleton();

        if (hModule == NULL)
        {
            prof->AddProfile(OBFUSCATE_STR("FindProcAddress hModule NULL"));
            return NULL;
        }

        const auto ModuleBase = (DWORD)hModule;

        const auto NtHeader = ImageNtHeader(hModule);

        const auto ImageData = NtHeader->OptionalHeader.DataDirectory;
        const auto ExportAddr = ImageData[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        const auto ImageExport = (PIMAGE_EXPORT_DIRECTORY)(ModuleBase + ExportAddr);

        const auto Addresses = (DWORD*)(ImageExport->AddressOfFunctions + ModuleBase);
        const auto Ordinals = (WORD*)(ImageExport->AddressOfNameOrdinals + ModuleBase);

        /* Search export table for name */
        const auto Names = (DWORD*)(ImageExport->AddressOfNames + ModuleBase);
        for (DWORD i = 0; i < ImageExport->NumberOfNames; i++)
        {
	        const auto cName = (const char*)(ModuleBase + Names[i]);
            if (!strcmp(cName, lpProcName))
                return (PVOID)(ModuleBase + Addresses[Ordinals[i]]);
        }

        /* Fall back, forwarded? */
        prof->AddProfile(OBFUSCATE_STR("FindProcAddress failed to find export, falling back"));
        return (PVOID)GetProcAddress(hModule, lpProcName);
    }
}
