#include "../Execution/RbxLua.hpp"
#include "../Execution/RbxApi.hpp"

#include "../Misc/D3D.hpp"
#include "../Misc/Fonts.hpp"

#include "../../Source Dependencies/ImGUI/imgui_impl_dx11.h"
#include "../../Source Dependencies/ImGUI/imgui_impl_win32.h"

#include "../../Source Dependencies/ImGUI/imgui_freetype.h"

#include "./SysHook.hpp"
#include "../../Utilities/Spoofer.hpp"
#include "./MemCheck.hpp"

IDXGISwapChainPresentFn OrigIDXGISwapChainPresent;
bool IsLuaU;
std::vector<std::string> ChunkNamesVec;

BOOL ID3DFirst = TRUE;
BOOL FPSUnlocked = FALSE;
BOOL IGuiOpen = FALSE;
BOOL IGuiEnabled = FALSE;
bool OutputRedirection = FALSE;
bool AutoScroll = FALSE;
DWORD TaskSched = NULL;
DWORD TaskSchedDelay = NULL;
IDXGISwapChain* ID3DChain = NULL;
ID3D11Device* ID3DDevice = NULL;
ID3D11DeviceContext* ID3DContext = NULL;
ID3D11RenderTargetView* ID3DRenderTarget = NULL;
ID3D11Texture2D* ID3DRenderTargetTexture = NULL;
WNDPROC OrigWndProc = NULL;
uint64_t OriginalNtQIP = 0;
uint64_t OriginalSetUEF = 0;
uint64_t OriginalGetAdaptersAddresses = 0;
uint64_t OrigRtlImageNtHeaderEx = 0;
uint64_t OriginalGetThreadId = 0;
uintptr_t OriginalErrHook = 0;
uintptr_t OriginalMsgOutHook = 0;
uint32_t ScriptRunCounter = 0;
bool SecureLuaFlag = false;
PLH::CapstoneDisassembler x86Disasm{ PLH::Mode::x86 };
LPVOID OriginalNtQVM = nullptr;
LPVOID OriginalZwFT = nullptr;
std::string D3DWorkspaceDirectory;
std::vector<std::pair<std::string, ImU32>> ConsoleOutput;
std::unordered_map<std::uintptr_t, SynCClosure> HookedFunctionsMap;
uintptr_t CurrentInstanceMsgOut;

DWORD WINAPI SetUEFHook(LPTOP_LEVEL_EXCEPTION_FILTER) { return 0; }

signed int WINAPI RtlImageNtHeaderExHook(int A1, unsigned int Base, int A3, int A4, PIMAGE_NT_HEADERS* Out)
{
	if (Base == (DWORD)syn::Module)
	{
		const auto DosHeader = (PIMAGE_DOS_HEADER) Base;
		*Out = (PIMAGE_NT_HEADERS)((char*) DosHeader + DosHeader->e_lfanew);
		return 0;
	}

	return ((std::decay_t<decltype(RtlImageNtHeaderExHook)>) OrigRtlImageNtHeaderEx)(A1, Base, A3, A4, Out);
}

DWORD OrigTSRet = 0;
__declspec(naked) void SchedulerRetHook()
{
	__asm
	{
		call syn::Scheduler::StepSchedule
		jmp OrigTSRet	
	}
}

__declspec(noinline) DWORD GetCurrentThreadIdHook()
{
	DWORD Ret = ((std::decay_t<decltype(GetCurrentThreadIdHook)>) OriginalGetThreadId)();
	DWORD RAddr = (DWORD)_ReturnAddress();

	static DWORD TRAddr1 = 0;
	static DWORD TRAddr2 = 0;
	static DWORD TRAddr3 = 0;

	if (!TRAddr1)
		TRAddr1 = syn::RobloxBase(syn::Offsets::DataModel::GetThreadIdReturn1);

	if (!TRAddr2)
		TRAddr2 = syn::RobloxBase(syn::Offsets::DataModel::GetThreadIdReturn2);

	if (!TRAddr3)
		TRAddr3 = syn::RobloxBase(syn::Offsets::DataModel::GetThreadIdReturn3);

	DWORD p_ebp = (DWORD)_AddressOfReturnAddress() - 4;
	DWORD ebp = *(DWORD*)p_ebp;

	if (RAddr == TRAddr1)
	{
		DWORD dm = *(DWORD*)(ebp + 8) + 0x44;
		syn::DataModel = dm;
		syn::Profiler::GetSingleton()->AddProfile("Set DM Hook");
		syn::Scheduler::StepSchedule();
	}
	else if (RAddr == TRAddr2)
	{
		if (*(DWORD*)(ebp + 4) != TRAddr3)
			return Ret;

		OrigTSRet = *(DWORD*)(ebp + 4);
		*(DWORD*)(ebp + 4) = (DWORD)SchedulerRetHook;
	}

	return Ret;
}

NTSTATUS NTAPI NtQIPHook(HANDLE ProcessHandle, INT ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength)
{
	NTSTATUS Status = ((std::decay_t<decltype(NtQIPHook)>) OriginalNtQIP)(ProcessHandle, ProcessInformationClass, ProcessInformation, 
                                                                          ProcessInformationLength, ReturnLength);
	if (!Status && ProcessInformationClass == 0x22) /* ProcessExecuteFlags */
		*(PDWORD)ProcessInformation |= 0x20; /* ImageDispatchEnable */

	return Status;
}

NTSTATUS NTAPI NtQVMHook(HANDLE ProcessHandle, PVOID BaseAddress,
	MEMORY_INFORMATION_CLASS MemoryInformationClass,
	PVOID Buffer, SIZE_T Length, PSIZE_T ResultLength)
{
	const auto RetAddr = (PVOID) _ReturnAddress();

	static syn::SysHook::ProtectedMemory* PM = nullptr;
	if (PM == nullptr) PM = syn::SysHook::ProtectedMemory::GetSingleton();

	/* Check if the NtQVM call is in the protected range, and the return address did NOT come from ntdll (will have to change back if they switch back to reg VirtualQuery, but whatever) */
	if (MemoryInformationClass == MemoryBasicInformation && !(RetAddr >= syn::ntdll && syn::ntdll + syn::NtDllSize >= RetAddr) && PM->IsProtected((uintptr_t) BaseAddress))
	{
		const auto PMBI = (PMEMORY_BASIC_INFORMATION) Buffer;
		PMBI->BaseAddress = BaseAddress;
		PMBI->AllocationBase = 0;
		PMBI->AllocationProtect = 0;
		PMBI->RegionSize = 0x20000;
		PMBI->State = MEM_FREE;
		PMBI->Protect = PAGE_NOACCESS;
		PMBI->Type = 0;

		if (ResultLength)
			*ResultLength = sizeof(MEMORY_BASIC_INFORMATION);

		//Make the checker error.
		return 1;
	}

	return ((std::decay_t<decltype(NtQVMHook)>) OriginalNtQVM)(ProcessHandle, BaseAddress, MemoryInformationClass, Buffer, Length, ResultLength);
}

NTSTATUS NTAPI ZwFTHook(HANDLE ExistingTokenHandle, ULONG Flags,
	PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete,
	PTOKEN_GROUPS SidsToRestricted, HANDLE NewTokenHandle)
{
	//We could care less about this function, its just used as a comparison check and we need to make sure that the function still works.

	return ((std::decay_t<decltype(ZwFTHook)>) OriginalZwFT)(ExistingTokenHandle, Flags, SidsToDisable, PrivilegesToDelete, SidsToRestricted, NewTokenHandle);
}

NTSTATUS NTAPI GetAdaptersAddressesHook(ULONG Family,
	ULONG Flags,
	PVOID Reserved,
	void* AdapterAddresses,
	PULONG SizePointer)
{
	const auto RetAddr = (uintptr_t) _ReturnAddress();

	static uintptr_t RbxTextBase;
	static uintptr_t RbxTextEnd;

	if (!RbxTextBase || !RbxTextEnd)
	{
		auto SegInfo = syn::MemCheck::GetSegmentInfo(syn::RobloxModule, (char*)OBFUSCATE_STR(".text"));
		RbxTextBase = (uintptr_t) SegInfo->SectionAddress;
		RbxTextEnd = RbxTextBase + SegInfo->SectionSize;
	}

	if (RetAddr >= RbxTextBase && RbxTextEnd >= RetAddr)
		return FALSE;

	return ((std::decay_t<decltype(GetAdaptersAddressesHook)>) OriginalGetAdaptersAddresses)(Family, Flags, Reserved, AdapterAddresses, SizePointer);
}

__declspec(naked) void ErrHook()
{
	__asm
	{
		//Check if script pointer is 0
		cmp [ebp + 0x3C], 0
		//If it isn't, go to the original function.
		jne OriginalFunc
		//If it is, just don't fire the event.
		retn 0x38

		OriginalFunc:
		push ebp
		mov ebp, esp
		push 0xFFFFFFFF
		jmp [OriginalErrHook]
	}
}

int MsgOutHookHandler(DWORD* Data)
{
	static uintptr_t MessageOut;
	if (!MessageOut) MessageOut = syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::LogService::MessageOut));

	if (CurrentInstanceMsgOut != MessageOut || *(BYTE*) Data != 3)
	{
		return 1;
	}

	const auto Msg = (std::string*) (Data + 2);

	for (const auto& ChunkName : ChunkNamesVec)
	{
		if (Msg->find(ChunkName) != std::string::npos)
		{
			const auto Color = ImGui::GetColorU32(ImVec4(1, 0, 0, 1));
			ConsoleOutput.emplace_back(std::make_pair(*Msg, Color));

			return 0;
		}
	}

	return 1;
}

__declspec(naked) void MsgOutHook()
{
	__asm
	{
		//Backup registers
		mov CurrentInstanceMsgOut, ecx
		push ebp
		mov ebp, esp
		push ecx
		push edx
		//Push message
		push [ebp + 8]
		//Call MsgOutHookHandler.
		call MsgOutHookHandler
		//Pop arguments
		add esp, 4
		//Restore registers
		pop edx
		pop ecx
		mov esp, ebp
		pop ebp

		//Check if its a Synapse message
		cmp eax, 0
		jne OriginalFunc
		//If it is, do not fire the event.
		retn 4

		OriginalFunc:
		push ebp
		mov ebp, esp
		push 0xFFFFFFFF
		jmp [OriginalMsgOutHook]
	}
}

int CallcheckProxy(DWORD rL)
{
	const syn::RbxLua RL(rL);

	//0 upvalue hookfunction/newcclosure support
	if (RL.Type(lua_upvalueindex(1)) == R_LUA_TNONE)
	{
		lua_Debug ar;
		if (!RL.GetStack(0, &ar))
			return 0;

		RL.GetInfo("f", &ar);

		const auto CCH = HookedFunctionsMap[RL.ToPointer(-1)];

		RL.Pop(1);

		return reinterpret_cast<r_lua_NoUpValCFunction>(CCH.Address)(rL, CCH);
	}

	const auto CC = (SynCClosure*) RL.ToUserData(lua_upvalueindex(1));
	return reinterpret_cast<r_lua_CFunction>(CC->Address)(rL);
}

HRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	if (ID3DFirst)
	{
		ID3DChain = pSwapChain;

		const auto RbxHwnd = syn::RobloxWindow;

		pSwapChain->GetDevice(__uuidof(ID3DDevice), (void**)&ID3DDevice);
		ID3DDevice->GetImmediateContext(&ID3DContext);

		if (SUCCEEDED(pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<LPVOID*>(&ID3DRenderTargetTexture))))
		{
			ID3DDevice->CreateRenderTargetView(ID3DRenderTargetTexture, NULL, &ID3DRenderTarget);
			ID3DRenderTargetTexture->Release();
		}

		ImGui_ImplWin32_Init(RbxHwnd);
		ImGui_ImplDX11_Init(ID3DDevice, ID3DContext);

		ImFontConfig Config{};
		Config.OversampleH = 3;
		Config.OversampleV = 3;

		auto& IO = ImGui::GetIO();
		auto SD3D = syn::D3D::GetSingleton();
		SD3D->AddFont(IO.Fonts->AddFontFromMemoryCompressedTTF(seoge_ui_compressed_data, seoge_ui_compressed_size, 32.0f, &Config));
		SD3D->AddFont(IO.Fonts->AddFontDefault(&Config));
		SD3D->AddFont(IO.Fonts->AddFontFromMemoryCompressedTTF(ibm_plex_compressed_data, ibm_plex_compressed_size, 32.0f, &Config));
		SD3D->AddFont(IO.Fonts->AddFontFromMemoryCompressedTTF(sometype_mono_compressed_data, sometype_mono_compressed_size, 32.0f, &Config));

		IO.Fonts->TexGlyphPadding = 1;
		for (auto n = 0; n < IO.Fonts->ConfigData.Size; n++)
		{
			auto* FontCfg = (ImFontConfig*) &IO.Fonts->ConfigData[n];
			FontCfg->RasterizerMultiply = 1.0f;
			FontCfg->RasterizerFlags = 0;
		}

		ImGuiFreeType::BuildFontAtlas(IO.Fonts, 0);
		ImGui_ImplDX11_CreateDeviceObjects();

		ID3DRenderTarget->Release();

		ID3DFirst = false;
	}

	if (FPSUnlocked)
	{
        /* TODO: Move to renderstepped */
        *(double*)(TaskSched + TaskSchedDelay) = 1.0 / 144.0;
	}

	if (SUCCEEDED(pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<LPVOID*>(&ID3DRenderTargetTexture))))
	{
		ID3DDevice->CreateRenderTargetView(ID3DRenderTargetTexture, NULL, &ID3DRenderTarget);
		ID3DRenderTargetTexture->Release();
	}

	ID3DContext->OMSetRenderTargets(1, &ID3DRenderTarget, NULL);

	ImGui_ImplDX11_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	const auto D3DRender = syn::D3D::GetSingleton();

	D3DRender->BeginScene();
	D3DRender->DrawScene();
	D3DRender->EndScene();

	if (IGuiEnabled)
	{
		if (IGuiOpen)
		{
			ImGui::GetIO().MouseDrawCursor = TRUE;
			D3DRender->DrawUI();
		}
		else ImGui::GetIO().MouseDrawCursor = FALSE;
	}

	ImGui::Render();
	ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

	ID3DRenderTarget->Release();

	return OrigIDXGISwapChainPresent(pSwapChain, SyncInterval, Flags);
}

LRESULT __stdcall WndProcHook(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (IGuiEnabled && uMsg == WM_KEYDOWN && wParam == VK_INSERT)
	{
		IGuiOpen = !IGuiOpen;
		return true;
	}

	if (IGuiEnabled && IGuiOpen)
	{
		if (ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam))
			return true;
	}

	if (uMsg == WM_SIZE)
	{
		if (!ID3DChain || !ID3DDevice) 
            return CallWindowProc(OrigWndProc, hWnd, uMsg, wParam, lParam);

		if (SUCCEEDED(ID3DChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<LPVOID*>(&ID3DRenderTarget))))
		{
			ID3DDevice->CreateRenderTargetView(ID3DRenderTargetTexture, NULL, &ID3DRenderTarget);
			ID3DRenderTargetTexture->Release();
		}

		ID3DRenderTarget->Release();

		return DefWindowProc(hWnd, uMsg, wParam, lParam);
	}

	return CallWindowProc(OrigWndProc, hWnd, uMsg, wParam, lParam);
}
