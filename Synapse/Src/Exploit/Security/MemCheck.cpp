
/*
*
*	SYNAPSE X
*	File.:	MemCheck.cpp
*	Desc.:	MemCheck bypass
*
*/

#include "./MemCheck.hpp"

#include "SysHook.hpp"
#include "../../Utilities/Utils.hpp"
#include "AntiDump.hpp"
#include "AntiDebug.hpp"
#include "../Misc/PointerObfuscation.hpp"
#include "../../Utilities/FakeMemoryHasher.hpp"
#include "../../Utilities/Obfuscation/ObfuscatedNumber.hpp"

#undef xor

namespace syn
{
	DWORD MemCheckData[] = { 0, 0, 0 };
    std::uint32_t SecondaryHookKey;
	static MemCheck* MemInst;

    uint32_t MulConst1, MulConst2, MulConst3;
	void __declspec(naked) MemCheckHook()
	{
		__asm
		{
            push eax
            mov eax, syn::FakeMemcheck::MemoryChanged
            test eax, eax
            jz MemContinue
            dec MulConst1

        MemContinue:
            pop eax

        ReEntry:
			sub     esp, 4
			pop     MemCheckData
			push    ecx
			push    edx
			push    10h
			push    esi
			call    MemCheck::GetCopyDif
			add     esp, 8
			pop     edx
			pop     ecx
			mov     MemCheckData + 4, esp
			mov     esp, eax
			mov     eax, [esp + esi]
			add     eax, esi
			imul    eax, MulConst1
			add     eax, [ebp - 0Ch]
			rol     eax, 13h
			imul    eax, MulConst2
			mov		[ebp - 0Ch], eax
			lea     eax, [esi + 4]
			sub     eax, [esp + esi + 4]
			add     esi, 8
			imul    eax, MulConst3
			add     eax, [ebp - 18h]
			rol     eax, 12h
			imul    eax, MulConst1
			mov		[ebp - 18h], eax
			mov     eax, [esp + esi]
			xor		eax, esi
			add     esi, 4
			imul    eax, MulConst1
			add     eax, [ebp - 14h]
			rol     eax, 0Dh
			imul    eax, MulConst2
			mov		[ebp - 14h], eax
			mov     eax, [esp + esi]
			sub     eax, esi
			add     esi, 4
			imul    eax, MulConst3
			add     eax, ebx
			rol     eax, 0Fh
            mov     esp, MulConst1
            imul    esp, eax
			mov     ebx, esp
			mov     esp, MemCheckData + 4
			push    MemCheckData
			add     esp, 4
			cmp     esi, edi
			jb      ReEntry
			jmp     MemCheckData + 8
		}
	}

	uint32_t OrigSecondaryHasherJmp;

	void __declspec(naked) SecondaryHasherHook()
	{
		__asm
		{
			push ebx
			call MemCheck::HashSecondary
			add esp, 4
			mov ecx, [ebp + 0x0C]
			jmp [OrigSecondaryHasherJmp]
		}
	}

	uint32_t MemCheck::HashSecondary(const uintptr_t HasherAddr, const uintptr_t StartingAddr, uintptr_t EndingOffset, int Unused, const uint32_t Nonce)
	{
        VM_DOLPHIN_BLACK_START;

		/*
		 * Bypass for MemCheck "secondary hashers" - Synapse pre-calculates the hashes for every possible secondary hasher (16 * 30 = 480 hashes)
		 *
		 * We then lookup the correct hash in the Synapse security struct - I purposefully obfuscate this struct as much as possible to make dumping the correct hashes or spoofing this struct as hard as possible.
		 *
		 * We can use a strong VM here as the secondary hashers aren't called very often (only does a sweep every 5 seconds)
		 *
		 * We can also do security checks here as it will be quite hard to hook this.
		 */

        /* Before anything, determine if someone has tampered from the outside */
		if (syn::FakeMemcheck::MemoryChanged)
			return (HasherAddr + StartingAddr ^ Nonce) * EndingOffset; /* Cause a real disconnection */

		static auto Step = 0;
		if (Step >= 30)
		{
			if (syn::AntiDebug::Check() || syn::AntiDump::Check())
				return EndingOffset - StartingAddr * Nonce ^ HasherAddr; /* Also cause a real disconnection (but make it look different from the other case) */

			Step = 0;
		}

        UNUSED(Unused);

		SuspendRoblox();

		const auto Res = MessageBox(NULL, OBFUSCATE_STR("Synapse X has encountered an internal error.\n\nIf you wish to report this, please press 'Yes' then send the contents of your clipboard to 3dsboy08."), OBFUSCATE_STR("Synapse X"), MB_YESNO | MB_ICONWARNING);

		if (Res == IDYES)
		{
			std::stringstream HFStream;
            uintptr_t ModuleBase = reinterpret_cast<uintptr_t>(syn::RobloxModule);
			HFStream << OBFUSCATE_STR("Hasher: ") << IntToHex(HasherAddr - ModuleBase + 0x400000) << "\n";
			HFStream << OBFUSCATE_STR("StartingAddr: ") << IntToHex(StartingAddr - ModuleBase + 0x400000) << "\n";
			HFStream << OBFUSCATE_STR("EndOffset: ") << IntToHex(EndingOffset) << "\n";
			HFStream << OBFUSCATE_STR("Nonce: ") << IntToHex(Nonce) << "\n";

			MessageBox(NULL, OBFUSCATE_STR("The report has been set to your clipboard. Please send the contents to 3dsboy08."), OBFUSCATE_STR("Synapse X"), MB_OK);
		}

		TerminateProcess(syn::RobloxProcess, 0);

        VM_DOLPHIN_BLACK_END;

		return 0;
	}

	int MemCheck::GetCopyDif(int Base, int Add)
	{
		auto MemCls = GetBaseInstance();
		for (auto CurrentSeg : MemCls->Segments)
		{
			if (Base > CurrentSeg->SegmentBase && Base + Add < CurrentSeg->SegmentEnd)
			{
				return CurrentSeg->SegmentCopy - CurrentSeg->SegmentBase;
			}
		}
		return 0;
	}

	void MemCheck::WriteBytes(DWORD Addr, DWORD Patch, size_t Size)
    {
        VM_DOLPHIN_RED_START;

		DWORD Protect;
		syn::SafeVirtualProtect((LPVOID)Addr, Size, PAGE_EXECUTE_READWRITE, &Protect);
		memcpy((PVOID)Addr, (const PVOID)Patch, Size);
        syn::SafeVirtualProtect((LPVOID)Addr, Size, Protect, &Protect);

        FlushInstructionCache(syn::RobloxProcess, (LPCVOID) Addr, Size);

        /* Update fake hash when new memory is written */
        syn::FakeMemcheck::UpdateMasterHash();

        VM_DOLPHIN_RED_END;
	}

	void MemCheck::RawHook(DWORD Addr, DWORD Jmp, BYTE HookByte)
	{
        VM_DOLPHIN_RED_START;
            
		byte Patch[5] = { 0x00, 0x00, 0x00, 0x00, 0x00 };
		Patch[0] = HookByte;
		int relative = Jmp - Addr - 5;
		memcpy(Patch + 1, &relative, sizeof(int));
		WriteBytes(Addr, (DWORD)Patch, sizeof(Patch));

        VM_DOLPHIN_RED_END;
	}

	ImageSectionInfo* MemCheck::GetSegmentInfo(HMODULE Module, char* SegmentName)
	{
        VM_DOLPHIN_RED_START;

		const auto DllImageBase = (char*)Module;
		const auto NtHdr = ImageNtHeader(DllImageBase);
		auto* SectionHdr = (IMAGE_SECTION_HEADER *)(NtHdr + 1);
		ImageSectionInfo* SectionInfo = NULL;
		for (int i = 0; i < NtHdr->FileHeader.NumberOfSections; i++)
		{
			const auto Name = (char*)SectionHdr->Name;
			if (strcmp(Name, SegmentName) == 0)
			{
				SectionInfo = new ImageSectionInfo(SegmentName);
				SectionInfo->SectionAddress = DllImageBase + SectionHdr->VirtualAddress;
				SectionInfo->SectionSize = SectionHdr->Misc.VirtualSize;
				return SectionInfo;
			}
			SectionHdr++;
		}

        VM_DOLPHIN_RED_END;

		return nullptr;
	}

	void MemCheck::AddSegment(char* SegmentName)
	{
        VM_DOLPHIN_RED_START;
		
		auto RSegment = GetSegmentInfo(GetModuleHandle(0), SegmentName);
		if (!RSegment)
			throw std::exception();

		const auto Segment = new SegmentInfo;
		Segment->SegmentName = SegmentName;
		Segment->SegmentCopy = (int) VirtualAlloc(nullptr, RSegment->SectionSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		syn::SysHook::ProtectedMemory::GetSingleton()->Add((uintptr_t) Segment->SegmentCopy, RSegment->SectionSize);
		Segment->SegmentBase = (int) RSegment->SectionAddress;
		Segment->SegmentEnd = Segment->SegmentBase + RSegment->SectionSize;
		memcpy((void*) Segment->SegmentCopy, (void*) Segment->SegmentBase, RSegment->SectionSize);

        VM_DOLPHIN_RED_END;

		Segments.push_back(Segment);
	}

	void MemCheck::HookMemCheck(DWORD RHasher, DWORD JmpBack)
	{
        VM_DOLPHIN_BLACK_START;

		RawHook(RobloxBase(OBFUSCATED_NUM(syn::Offsets::MemCheck::DispatcherCall)), (DWORD) SecondaryHasherHook);
		RawHook(RHasher, (DWORD) MemCheckHook);		

        VM_DOLPHIN_BLACK_END;
	}

	MemCheck::MemCheck()
	{
        MulConst1 = OBFUSCATED_NUM(0x1594FE2D);
        MulConst2 = OBFUSCATED_NUM(0xCBB4ABF7);
        MulConst3 = OBFUSCATED_NUM(0x344B5409);

		if (MemInst != nullptr)
			throw std::exception();

		MemInst = this;
	}

	MemCheck::~MemCheck()
	{
		MemInst = nullptr;
	}

	MemCheck* MemCheck::GetBaseInstance()
	{
		if (!MemInst)
			MemInst = new MemCheck();

		return MemInst;
	}
}