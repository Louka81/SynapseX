#pragma once

#include <cstdint>

#include "../Misc/CallingConvention.hpp"

namespace syn
{
	namespace Offsets
	{
		namespace GCObject
		{
			constexpr std::uint32_t GC_Marked = 4;
			constexpr std::uint32_t GC_TT = 5;
		}

		namespace LuaState
		{
			constexpr std::uint32_t LS_Top = 20;
			constexpr std::uint32_t LS_Base = 8;
			constexpr std::uint32_t LS_GlobalState = 12;
			constexpr std::uint32_t LS_SavedPC = 24;
			constexpr std::uint32_t LS_Env = 64;

            constexpr std::uint32_t LS_StackLast = 28; // HSVM

			// TODO: implement for reallocstack + closure handling
			constexpr std::uint32_t LS_NamecallMethod = 120;

			// "no calling environment" - first is LS_CI, second is LS_BaseCI.
			constexpr std::uint32_t LS_CI = 16;
			constexpr std::uint32_t LS_BaseCI = 36;

			// see LuaU OP_SELF - 48
			constexpr std::uint32_t LS_StackSize = NULL;
		}

		namespace GlobalState
		{
			constexpr std::uint32_t GS_LuaU = 0;
			constexpr std::uint32_t GS_RootGC = 52;
			constexpr std::uint32_t GS_CKey = 48;
			constexpr std::uint32_t GS_WhiteMask = 24;
            constexpr std::uint32_t GS_TotalBytes = 92; // HSVM
            constexpr std::uint32_t GS_GCThreshold = 80; // HSVM
			constexpr std::uint32_t GS_GreyAgain = 28; // HSVM
		}

		namespace Table
		{
			constexpr std::uint32_t T_GCList = 16; // HSVM
			constexpr std::uint32_t T_Untouched = 7; // HSVM, use getfenv for it. TODO: find better way of getting this
		}

		namespace CallInfo 
		{
            constexpr std::uint32_t CI_Base = 8;
            // "global" / index2adr
			constexpr std::uint32_t CI_Func = 0;
			constexpr std::uint32_t CI_SavedPc = 4;
            constexpr std::uint32_t CI_Top = 12;
		}

        namespace LClosure
		{
            constexpr std::uint32_t LCL_Upvals = 24;
            constexpr std::uint32_t LCL_Env = 16;
            constexpr std::uint32_t LCL_NUpVals = 7;
			constexpr std::uint32_t LCL_MaxStackSize = 8;
		}

        namespace String
		{
            // objlen / OP_LEN
            constexpr std::uint32_t STR_Len = 8; // HSVM
		}

		namespace DataModel
		{
			/* "Recording Stopped", near end of function, massive amount of params, first func in that */
			constexpr std::uintptr_t GetDataModel = 0x5A6F10;
			// "Write Marshal" -> instruction directly after GetCurrentThreadId
			constexpr std::uintptr_t GetThreadIdReturn1 = 0x647EAE;

			// "InvalidAccess" -> xref 3
			constexpr std::uintptr_t GetThreadIdReturn2 = 0x63D58F;

			//"GC Job finish, data model: %p" -> mov ecx, edi
			constexpr std::uintptr_t GetThreadIdReturn3 = 0x828B6B;

			/* 55 8B EC 8B 15 ? ? ? ? 8B CA */
			constexpr std::uintptr_t TrustCheckStr = 0x215C994;
			constexpr std::uint32_t DM_Net = 0x4E4;
		}

		namespace Player
		{
			/* "Submitting abuse report on game" */
			constexpr std::uintptr_t UserId = 224;
			constexpr std::uintptr_t UserIdBackup = 232;
			constexpr std::uintptr_t UserIdSecurityConst = 0x4E4EABC4;
		}

		namespace MemCheck
		{
			/* 8B 06 03 C6 69 C0 ? ? ? ? 03 45 F4 C1 C0 13 69 C0 ? ? ? ?, loc is 2nd */
			constexpr std::uintptr_t Hasher = 0x693F91;
			constexpr std::uintptr_t HasherJmpBack = 0x694000;

			/* .vmpx segment, see the 'call ebx' from the addresses xref. */
			constexpr std::uintptr_t DispatcherCall = 0x2610E8D;
			constexpr std::uintptr_t DispatcherJmpBack = 0x2610E92;
		}

		namespace LogService
		{
			//Error: Standard Message Out set with incorrect MessageType %d
			constexpr std::uintptr_t MessageOut = 0x241A43C;
		}

		namespace Signal
		{
			constexpr std::uintptr_t FireSingle = 0x4F8AD0;
			constexpr std::uintptr_t FireError = 0x819F20;
			constexpr std::uintptr_t Iterate = 0x53EA80;
		}

		namespace ClickDetector
		{
			//E8 ? ? ? ? 8B 4D D8 8B 45 1C 
			constexpr std::uintptr_t FireClick = 0xA1E330;
		}

		namespace TouchInterestArray
		{
			//E8 ? ? ? ? 8D 4D D4 E8 ? ? ? ? 5F 5E 
			constexpr std::uintptr_t AppendArray = 0x8F4380;
		}

		namespace Http
		{
			//&userLocale=
			constexpr std::uintptr_t PlaceId = 0x2424514;
			constexpr std::uintptr_t GameInstanceId = 0x24244FC;
		}

		namespace MemUsage
		{
			/*
				  "GetMemoryUsageMbForTag"
			 
			 	  if ( sub_1169280() )
				  {
				    do
				    {
				      if ( a1 == sub_57F820(v2) )	<-- GetIdx
				        v1 += sub_57F920(v2);		<-- UsageTable (in function, 'v3 = &unk_2166E08 + 104 * a1;')
				      ++v2;
				    }
				    while ( v2 < sub_57F810() );	<-- GetUsageMax
				  }
			 */

			constexpr std::uintptr_t GetIdx = 0x55B6D0;
			constexpr std::uintptr_t GetUsageMax = 0x55B6C0;
			constexpr std::uintptr_t UsageTable = 0x2271CA0;
		}

		namespace Table
		{
			//"Attempt to modify a readonly table", xref 2
			constexpr std::uint32_t TL_Locked = 8;
		}

		namespace Proto
		{
			constexpr std::uint32_t PO_LocVars = 16;
			constexpr std::uint32_t PO_SizeLocVars = 52;
			constexpr std::uint32_t PO_K = 8;
			constexpr std::uint32_t PO_SizeK = 40;
			constexpr std::uint32_t PO_Source = 20;
			constexpr std::uint32_t PO_P = 32;
			constexpr std::uint32_t PO_SizeP = 72;
			constexpr std::uint32_t PO_LineInfo = 12;
			constexpr std::uint32_t PO_SizeLineInfo = 56;
			constexpr std::uint32_t PO_Code = 36;
			constexpr std::uint32_t PO_SizeCode = 68;
			constexpr std::uint32_t PO_Upvals = 24;
			constexpr std::uint32_t PO_SizeUpvals = 28;
			constexpr std::uint32_t PO_LineDefined = 76;
			constexpr std::uint32_t PO_LastLineDefined = 48;
			constexpr std::uint32_t PO_Hash = 60;
			constexpr std::uint32_t PO_Flag = 44;
			constexpr std::uint32_t PO_NumParams = 80;
			constexpr std::uint32_t PO_MaxStackSize = 81;
			constexpr std::uint32_t PO_NUps = 82;
			constexpr std::uint32_t PO_IsVararg = 83;
		}
	}

	namespace Types
	{
		constexpr std::int8_t RT_None = -1;
		constexpr std::int8_t RT_Nil = 0;
		constexpr std::int8_t RT_LightUserdata = 1;
		constexpr std::int8_t RT_Number = 2;
		constexpr std::int8_t RT_Boolean = 3;
		constexpr std::int8_t RT_String = 4;
		constexpr std::int8_t RT_Thread = 5;
		constexpr std::int8_t RT_Function = 6;
		constexpr std::int8_t RT_Table = 7;
		constexpr std::int8_t RT_Userdata = 8;
		constexpr std::int8_t RT_Proto = 9;
		constexpr std::int8_t RT_Upval = 10;
	}

	namespace Spoofer
	{
		//FF E7
		constexpr std::uintptr_t ReturnAddress = 0x693D4D;
		//really doesnt fucking matter honestly, set it to like some SEH handler
		constexpr std::uintptr_t ExceptionHandlerAddress = 0x14CB51B;
	}

	namespace Lua
	{
		//Resuming script: %p
		constexpr std::uintptr_t RbxResume = 0x8261B0;
		//Error occurred, no output from Lua.
		constexpr std::uintptr_t RbxError = 0x8251A0;
		/*
			"processDeserializedPacket"
		*/
		constexpr std::uintptr_t RbxImpersonatorConstruct = 0x6AEAB0;
	}

	namespace CallCheck
	{
		//j_MiniDumpWriteDump_0
		constexpr std::uintptr_t CallcheckAddress = 0x119FC5A;
	}

	namespace TaskScheduler
	{
		constexpr std::uint32_t ArbiterVector = 564;

		//55 8B EC 6A FF 68 ? ? ? ? 64 A1 ? ? ? ? 50 64 89 25 ? ? ? ? 51 64 A1 ? ? ? ? 8B 0D ? ? ? ? 8B 0C 88 A1 ? ? ? ? 3B 81 ? ? ? ? 7E 52 68 ? ? ? ? E8 ? ? ? ? 83 C4 04 83 3D ? ? ? ? ? 75 3C 68 ? ? ? ? C7 45 ? ? ? ? ? 
		constexpr std::uintptr_t Singleton = 0x57A560;
	}
}

#pragma region API Obfuscation
#define DereferenceSmartPointerInstance(Ptr) (*(DWORD*) (Ptr))
#pragma endregion

#pragma region Proto Offsets
#define PO_SIZEP syn::Offsets::Proto::PO_SizeP
#define PO_SIZEK syn::Offsets::Proto::PO_SizeK
#define PO_SIZECODE syn::Offsets::Proto::PO_SizeCode
#define PO_P syn::Offsets::Proto::PO_P
#define PO_K syn::Offsets::Proto::PO_K
#define PO_CODE syn::Offsets::Proto::PO_Code
#define PO_SOURCE syn::Offsets::Proto::PO_Source
#define PO_FLAG syn::Offsets::Proto::PO_Flag
#define PO_IS_VARARG syn::Offsets::Proto::PO_IsVararg
#define PO_MAXSTACKSIZE syn::Offsets::Proto::PO_MaxStackSize
#define PO_NUMPARAMS syn::Offsets::Proto::PO_NumParams
#define PO_NUPS syn::Offsets::Proto::PO_NUps
#define PO_SIZELOCVARS syn::Offsets::Proto::PO_SizeLocVars
#define PO_SIZELINEINFO syn::Offsets::Proto::PO_SizeLineInfo
#define PO_SIZEUPVALUES syn::Offsets::Proto::PO_SizeUpvals
#define PO_LINEDEFINED syn::Offsets::Proto::PO_LineDefined
#define PO_LASTLINEDEFINED syn::Offsets::Proto::PO_LastLineDefined
#define PO_LOCVARS syn::Offsets::Proto::PO_LocVars
#define PO_LINEINFO syn::Offsets::Proto::PO_LineInfo
#define PO_UPVALS syn::Offsets::Proto::PO_Upvals
#define PO_HASH syn::Offsets::Proto::PO_Hash
#pragma endregion

#pragma region GCObject Offsets
#define GCO_MARKED syn::Offsets::GCObject::GC_Marked
#define GCO_TT syn::Offsets::GCObject::GC_TT
#pragma endregion

#pragma region LuaState Offsets
#define L_BASE syn::Offsets::LuaState::LS_Base
#define L_TOP syn::Offsets::LuaState::LS_Top
#define L_GS syn::Offsets::LuaState::LS_GlobalState
#define L_SAVEDPC syn::Offsets::LuaState::LS_SavedPC
#define L_ENV syn::Offsets::LuaState::LS_Env
#define L_BCI syn::Offsets::LuaState::LS_BaseCI
#define L_CI syn::Offsets::LuaState::LS_CI
#define L_STKLAST syn::Offsets::LuaState::LS_StackLast
#define L_NAMECALLMETHOD syn::Offsets::LuaState::LS_NamecallMethod
#pragma endregion

#pragma region Table Offsets
#define T_GCLIST syn::Offsets::Table::T_GCList
#define T_UNTOUCHED syn::Offsets::Table::T_Untouched
#pragma endregion

#pragma region CallInfo Offsets
#define CI_BASE syn::Offsets::CallInfo::CI_Base
#define CI_FUNC syn::Offsets::CallInfo::CI_Func
#define CI_SAVEDPC syn::Offsets::CallInfo::CI_SavedPc
#define CI_TOP syn::Offsets::CallInfo::CI_Top
#pragma endregion

#pragma region String Offsets
#define STR_LEN syn::Offsets::String::STR_Len
#pragma endregion

#pragma region LClosure Offsets
#define LCL_UPVALS syn::Offsets::LClosure::LCL_Upvals
#define LCL_ENV syn::Offsets::LClosure::LCL_Env
#define LCL_NUPVALS syn::Offsets::LClosure::LCL_NUpVals
#define LCL_MAXSTACKSIZE syn::Offsets::LClosure::LCL_MaxStackSize
#pragma endregion

#pragma region GlobalState Offsets
#define G_LUAU syn::Offsets::GlobalState::GS_LuaU
#define G_ROOTGC syn::Offsets::GlobalState::GS_RootGC
#define G_CKEY syn::Offsets::GlobalState::GS_CKey
#define G_WMASK syn::Offsets::GlobalState::GS_WhiteMask
#define G_TOTALBYTES syn::Offsets::GlobalState::GS_TotalBytes 
#define G_GCTHRESHOLD syn::Offsets::GlobalState::GS_GCThreshold
#define G_GRAYAGAIN syn::Offsets::GlobalState::GS_GreyAgain
#pragma endregion

#pragma region Http Offsets
#define HTTP_PLACEID syn::Offsets::Http::PlaceId
#define HTTP_GAMEINSTANCEID syn::Offsets::Http::GameInstanceId
#pragma endregion

#pragma region Misc Offsets
#define RT_LOCKED syn::Offsets::Table::TL_Locked
#define DM_NET syn::Offsets::DataModel::DM_Net
#define PL_USERID syn::Offsets::Player::UserId
#define PL_USERIDBACKUP syn::Offsets::Player::UserIdBackup
#define PL_USERIDSECURITYCONST syn::Offsets::Player::UserIdSecurityConst
#pragma endregion

#pragma region Roblox Lua Types
#define R_LUA_TNONE syn::Types::RT_None
#define R_LUA_TNIL syn::Types::RT_Nil
#define R_LUA_TLIGHTUSERDATA syn::Types::RT_LightUserdata
#define R_LUA_TNUMBER syn::Types::RT_Number
#define R_LUA_TBOOLEAN syn::Types::RT_Boolean
#define R_LUA_TSTRING syn::Types::RT_String
#define R_LUA_TTHREAD syn::Types::RT_Thread
#define R_LUA_TFUNCTION syn::Types::RT_Function
#define R_LUA_TTABLE syn::Types::RT_Table
#define R_LUA_TUSERDATA syn::Types::RT_Userdata
#define R_LUA_TPROTO syn::Types::RT_Proto
#define R_LUA_TUPVAL syn::Types::RT_Upval
#pragma endregion

#pragma region Structures
struct RBXExtraSpace {
	struct Set {
		int         SetCount;
		RBXExtraSpace* Head;
	};

	RBXExtraSpace* Next;   // 0
	Set* All;              // 4
	RBXExtraSpace** Prev;  // 8
	uint8_t Pad[20];       // 12
	uint32_t ScriptPtr;    // 32
	uint32_t ScriptRef;    // 36
	uint8_t Pad2[24];      // 40
};
#pragma endregion

#pragma region Whitelist Constants
#define CLIENT_AES_KEY OBFUSCATE_STR_TEA("caX4nv33a1FvJLzfJ")
#define CLIENT_AES_IV OBFUSCATE_STR_TEA("6XiwchRZwc5bAxRF")
#define CLIENT_CACHE_KEY OBFUSCATE_STR_TEA("DLU65AAzabFCToSJ")
#define CLIENT_XOR_KEY 0x15131f25
#define CLIENT_XOR_CACHE_KEY 0x1713c3a5
#define CLIENT_HASH_KEY OBFUSCATE_STR_TEA("9tiHeWVpSSwg3BIP")
#define CLIENT_HASHCOMP_KEY OBFUSCATE_STR_TEA("LLvGnIEgLAsdJpz6")
#define CLIENT_HASHCOMP_RSA_KEY OBFUSCATE_STR_TEA("6e9UIsUkZfaaQ9No")
#define CLIENT_REQ_KEY OBFUSCATE_STR_TEA("B05NzHjXdGasfRxN")
#pragma endregion