#include "./D3D.hpp"

#include "./ExplorerIcons.hpp"

#include "../../Source Dependencies/ImGUI/imgui.h"
#include "../../Source Dependencies/ImGUI/imgui_internal.h"
#include "../../Source Dependencies/ImGUI/imgui_impl_dx11.h"

#include "../Execution/RbxApi.hpp"
#include "../Execution/Scheduler.hpp"

#include "../../Utilities/Scanner.hpp"
#include "../../Utilities/MemSpoofer.hpp"
#include "../../Utilities/Hashing/fnv.hpp"

namespace syn
{
	bool syn::D3D::WriteMemory(void* Addr, const void* Patch, size_t Sz)
	{
		DWORD protect;
		if (!syn::SafeVirtualProtect(Addr, Sz, PAGE_EXECUTE_READWRITE, &protect)) return false;
		memcpy((void*)Addr, Patch, Sz);
		return syn::SafeVirtualProtect(Addr, Sz, protect, (PDWORD)& protect) != 0;
	}

	void* syn::D3D::HookVFT(void* Obj, const int Idx, void* Target)
	{
		const auto VF = *(int**)Obj;
		const auto Prev = (void*)VF[Idx];

		WriteMemory(VF + Idx, &Target, sizeof(void*));

		return Prev;
	}

	DWORD syn::D3D::FindTaskScheduler()
	{
		DWORD Res;

		try
		{
			Res = (DWORD)syn::MemoryScanner::Scan(
				NULL, "\x55\x8B\xEC\xE8\x00\x00\x00\x00\x8A\x4D\x08\x83\xC0\x04\x86\x08\x5D\xC3", "xxxx????xxxxxxxxxx");

			if (Res)
			{
				typedef DWORD(*GetTaskSchedulerFn)();
				const auto GetTaskScheduler = (GetTaskSchedulerFn)(Res + 8 + *(DWORD*)(Res + 4));

				Res = GetTaskScheduler();
			}
		}
		catch (...)
		{
			Res = 0;
		}

		return Res;
	}

	int syn::D3D::FindDelayOffset(DWORD Sched)
	{
		for (auto i = 0x200; i < 0x300; i += 4)
		{
			static const auto FrameDelay = 1.0 / 60.0;
			auto Diff = *(double*)(Sched + i) - FrameDelay;
			Diff = Diff < 0 ? -Diff : Diff;
			if (Diff < 0.01) return i;
		}

		return 0;
	}

	void syn::D3D::SetupFPSUnlocker()
	{
		TaskSched = FindTaskScheduler();
		if (!TaskSched)
		{
			MessageBoxA(
				NULL,
				"Failed to find required variables for FPS unlocker (1) - it will be disabled. Please wait for Synapse to update.",
				"Synapse X", MB_OK);
			return;
		}
		TaskSchedDelay = FindDelayOffset(TaskSched);
		if (!TaskSchedDelay)
		{
			MessageBoxA(
				NULL,
				"Failed to find required variables for FPS unlocker (2) - it will be disabled. Please wait for Synapse to update.",
				"Synapse X", MB_OK);
			return;
		}
		FPSUnlocked = TRUE;
	}

	std::wstring syn::D3D::GetWorkingPath()
	{
		return std::filesystem::path(syn::WorkspaceDirectory).parent_path().wstring();
	}

	bool syn::D3D::Initialize(bool UnlockFPS)
	{
		static bool IsInit;
		if (IsInit) return true;
		IsInit = true;

		if (UnlockFPS) SetupFPSUnlocker();

		/* Create D3D device variables */
		ID3D11Device* Device = nullptr;
		ID3D11DeviceContext* DeviceContext = nullptr;
		IDXGISwapChain* SwapChain = nullptr;
		auto FeatureLevel = D3D_FEATURE_LEVEL_11_0;
		DXGI_SWAP_CHAIN_DESC SwapChainDesc;

		/* Create dummy window */
		const auto DummyWindow = CreateWindowEx(WS_EX_TOPMOST | WS_EX_TRANSPARENT | WS_EX_NOACTIVATE, "STATIC",
			RandomString(RandomInteger(10, 24)).c_str(), 0, 0, 0, 0, 0, NULL, NULL,
			NULL, NULL);
		if (!DummyWindow) return false;

		ZeroMemory(&SwapChainDesc, sizeof SwapChainDesc);
		SwapChainDesc.BufferCount = 1;
		SwapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		SwapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		SwapChainDesc.OutputWindow = DummyWindow;
		SwapChainDesc.SampleDesc.Count = 1;
		SwapChainDesc.Windowed = TRUE;
		SwapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
		SwapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
		SwapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

		if (SUCCEEDED(
			D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_NULL, NULL, NULL, &FeatureLevel, 1, D3D11_SDK_VERSION, &
				SwapChainDesc, &SwapChain, &Device, NULL, &DeviceContext)))
		{
			/* Hook IDXGISwapChain::Present */
			OrigIDXGISwapChainPresent = (IDXGISwapChainPresentFn)HookVFT(SwapChain, 8, (void*)PresentHook);

			/* Free objects */
			Device->Release();
			DeviceContext->Release();
			SwapChain->Release();
		}

		OrigWndProc = (WNDPROC)SetWindowLongPtr(syn::RobloxWindow, GWLP_WNDPROC, (LONG_PTR)WndProcHook);

		wcscpy(IniPath, (GetWorkingPath() + L"\\bin\\ImGui.ini").c_str());
		ImGui::GetIO().IniFilename = IniPath;

		return true;
	}

	syn::D3D* syn::D3D::GetSingleton()
	{
		static D3D* d3d = nullptr;
		if (d3d == nullptr)
			d3d = new D3D();
		return d3d;
	}

	void syn::D3D::AddFont(ImFont* _Font)
	{
		Fonts.push_back(_Font);
	}

	ImFont* syn::D3D::GetFont(int idx) const
	{
		return Fonts.at(idx);
	}

	void syn::D3D::BeginScene() const
	{
		ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
		ImGui::Begin("BackBuffer", reinterpret_cast<bool*>(true), ImVec2(0, 0), 0.0f,
			ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs);

		ImGui::SetWindowPos(ImVec2(0, 0), ImGuiSetCond_Always);
		ImGui::SetWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y), ImGuiSetCond_Always);
	}

	void syn::D3D::DrawScene() const
	{
		if (!RenderChain.empty())
		{
			for (auto Rend : RenderChain)
			{
				if (Rend->Header.Visible)
				{
					switch (Rend->Header.Type)
					{
					case D3_LINE:
					{
						const auto Line = (D3DLine*)Rend->Ptr;
						DrawLine(Line->From, Line->To, Line->Color, Line->Thickness);
						break;
					}
					case D3_SQUARE:
					{
						const auto Square = (D3DSquare*)Rend->Ptr;
						if (Square->Filled)
							DrawBoxFilled(Square->Pos, Square->Size, Square->Color);
						else
							DrawBox(Square->Pos, Square->Size, Square->Color, Square->Thickness);
						break;
					}
					case D3_CIRCLE:
					{
						const auto Circle = (D3DCircle*)Rend->Ptr;
						if (Circle->Filled)
							DrawCircleFilled(Circle->Pos, Circle->Radius, Circle->Color, Circle->Sides);
						else
							DrawCircle(Circle->Pos, Circle->Radius, Circle->Color, Circle->Thickness, Circle->Sides);
						break;
					}
					case D3_TEXT:
					{
						const auto Text = (D3DText*)Rend->Ptr;
						DrawText(GetFont(Text->Font), *Text->Text, Text->Pos, Text->Size, Text->Color,
							Text->OutlineColor, Text->Center, Text->Outline);
						break;
					}
					}
				}
			}
		}
	}

	void syn::D3D::EndScene()
	{
		auto Window = ImGui::GetCurrentWindow();
		Window->DrawList->PushClipRectFullScreen();

		ImGui::End();
		ImGui::PopStyleColor();
	}

	bool IsInstanceSeen = false;
	uintptr_t InstanceSelected;

	enum RbxPropertyType
	{
		BOOL,
		NUMBER,
		STRING,
		CLASS
	};

	enum RbxPropertyFlags
	{
		READONLY = 1 << 0,
	};

	struct RbxProperty
	{
		RbxPropertyType Type;
		int Flags;
		std::string Property;
	};

	struct RbxPropertyValue
	{
		RbxPropertyType Type;
		int Flags;
		std::string Value;
	};

	std::map<std::string, ImTextureID> ExplorerIcons;
	std::string DecScript;

	void DrawInstance(const syn::Instance& Inst)
	{
		const auto Children = Inst.GetChildren();

		auto NodeFlags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;
		if (InstanceSelected == Inst)
			NodeFlags |= ImGuiTreeNodeFlags_Selected;
		if (Children.empty())
			NodeFlags |= ImGuiTreeNodeFlags_Leaf;

		const auto ClassName = Inst.GetInstanceClassName();

		if (ExplorerIcons.count(ClassName))
			ImGui::Image(ExplorerIcons[ClassName], ImVec2(16, 16));
		else
			ImGui::Image(ExplorerIcons["Default"], ImVec2(16, 16));

		ImGui::SameLine();

		const auto Res = ImGui::TreeNodeEx((void*)(uintptr_t) Inst, NodeFlags, "%s", Inst.GetInstanceName().c_str());
		if (ImGui::IsItemClicked())
			InstanceSelected = Inst;

		if (InstanceSelected == Inst)
			IsInstanceSeen = true;

		if (Res)
		{
			for (auto& CInst : Children)
			{
				DrawInstance(CInst);
			}

			ImGui::TreePop();
		}
	}

	std::string GetInstanceValue(const RbxLua RL, const syn::Instance& Inst, const std::string& Property)
	{
		static DWORD PushF = NULL;
		if (!PushF) PushF = RbxLua::GetBinValue(FNVA1_CONSTEXPR("pushinstance"));

		const auto RealInst = (DWORD) Inst;

		RL.GetGlobal("getpropvalue");
		((int(__cdecl*)(DWORD, DWORD))PushF)(RL, (DWORD) &RealInst);
		RL.PushString(Property.c_str());

		if (RL.PCall(2, 1, 0))
		{
			RL.Pop(RL.GetTop());

			return "N/A";
		}

		size_t CSize;
		const auto CStr = RL.ToLString(-1, &CSize);

		RL.Pop(RL.GetTop());

		return std::string(CStr, CSize);
	}

	bool SetInstanceValue(const RbxLua RL, const syn::Instance& Inst, const std::string& Property, const RbxPropertyType Type, const std::string& Value)
	{
		static DWORD PushF = NULL;
		if (!PushF) PushF = RbxLua::GetBinValue(FNVA1_CONSTEXPR("pushinstance"));

		if (Type == CLASS)
			return false;

		const auto RealInst = (DWORD) Inst;

		RL.GetGlobal("setpropvalue");
		((int(__cdecl*)(DWORD, DWORD))PushF)(RL, (DWORD) &RealInst);
		RL.PushString(Property.c_str());

		switch (Type)
		{
			case BOOL:
			{
				RL.PushBoolean(Value == "true");
			}
			case STRING:
			{
				RL.PushLString(Value.c_str(), Value.size());
				break;
			}			
			case NUMBER:
			{
				double Number = 0;

				try
				{
					Number = std::stod(Value);
				}
				catch (...)
				{
					return false;
				}

				RL.PushNumber(Number);
				break;
			}
			default:
			{
				RL.PushNil();
			}
		}

		if (RL.PCall(3, 0, 0))
		{
			RL.Pop(RL.GetTop());

			return false;
		}

		RL.Pop(RL.GetTop());

		return true;
	}

	bool DestroyInstance(const RbxLua RL, const syn::Instance& Inst)
	{
		static DWORD PushF = NULL;
		if (!PushF) PushF = RbxLua::GetBinValue(FNVA1_CONSTEXPR("pushinstance"));

		const auto RealInst = (DWORD) Inst;

		((int(__cdecl*)(DWORD, DWORD))PushF)(RL, (DWORD)& RealInst);
		RL.GetField(-1, "Destroy");
		RL.PushValue(-2);

		if (RL.PCall(1, 0, 0))
		{
			RL.Pop(RL.GetTop());

			return false;
		}

		RL.Pop(RL.GetTop());

		return true;
	}

	int SetDecScript(DWORD RL)
	{
		const syn::RbxLua NRL(RL);

		size_t DScriptSize;
		const auto DScriptCStr = NRL.ToLString(1, &DScriptSize);

		DecScript = std::string(DScriptCStr, DScriptSize);

		return 0;
	}

	void syn::D3D::DrawUI() const
	{
		ImGui::PushFont(GetFont(1));
		ImGui::SetNextWindowSize(ImVec2(480, 285), ImGuiCond_FirstUseEver);

		static auto VectorGetter = [](void* vec, int idx, const char** out_text)
		{
			auto& vector = *static_cast<std::vector<std::string>*>(vec);
			if (idx < 0 || idx >= static_cast<int>(vector.size())) { return false; }
			*out_text = vector.at(idx).c_str();
			return true;
		};

		static TextEditor Editor;
		static TextEditor DecompilerEditor;
		static auto EditorInit = FALSE;
		static auto ScriptHubInit = FALSE;
		static auto ExplorerInit = FALSE;
		static CRITICAL_SECTION ScriptHubSection;
		static CRITICAL_SECTION ExplorerSection;
		static std::vector<std::wstring> ListBoxContents;
		static std::vector<std::string> ListBoxAnsiContents;
		static std::vector<std::string> ScriptHubContents;
		static std::map<std::string, std::vector<RbxProperty>> ExplorerProperties;
		if (!EditorInit)
		{
			const auto Lang = TextEditor::LanguageDefinition::Lua();

			Editor.SetLanguageDefinition(Lang);
			Editor.SetPalette(TextEditor::GetDarkPalette());

			DecompilerEditor.SetLanguageDefinition(Lang);
			DecompilerEditor.SetPalette(TextEditor::GetDarkPalette());

			EditorInit = TRUE;

			auto Colors = ImGui::GetStyle().Colors;
			ImGui::GetStyle().WindowRounding = 0.0f;
			ImGui::GetStyle().FrameRounding = 0.0f;
			ImGui::GetStyle().GrabRounding = 0.0f;
			ImGui::GetStyle().ScrollbarRounding = 0.0f;
			Colors[ImGuiCol_Text] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
			Colors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
			Colors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
			Colors[ImGuiCol_PopupBg] = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
			Colors[ImGuiCol_Border] = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
			Colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
			Colors[ImGuiCol_FrameBg] = ImVec4(0.20f, 0.21f, 0.22f, 0.54f);
			Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.40f, 0.40f, 0.40f, 0.40f);
			Colors[ImGuiCol_FrameBgActive] = ImVec4(0.18f, 0.18f, 0.18f, 0.67f);
			Colors[ImGuiCol_TitleBg] = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
			Colors[ImGuiCol_TitleBgActive] = ImVec4(0.29f, 0.29f, 0.29f, 1.00f);
			Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
			Colors[ImGuiCol_MenuBarBg] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
			Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
			Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
			Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
			Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
			Colors[ImGuiCol_CheckMark] = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
			Colors[ImGuiCol_SliderGrab] = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
			Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
			Colors[ImGuiCol_Button] = ImVec4(0.44f, 0.44f, 0.44f, 0.40f);
			Colors[ImGuiCol_ButtonHovered] = ImVec4(0.46f, 0.47f, 0.48f, 1.00f);
			Colors[ImGuiCol_ButtonActive] = ImVec4(0.42f, 0.42f, 0.42f, 1.00f);
			Colors[ImGuiCol_Header] = ImVec4(0.70f, 0.70f, 0.70f, 0.31f);
			Colors[ImGuiCol_HeaderHovered] = ImVec4(0.70f, 0.70f, 0.70f, 0.80f);
			Colors[ImGuiCol_HeaderActive] = ImVec4(0.48f, 0.50f, 0.52f, 1.00f);
			Colors[ImGuiCol_Separator] = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
			Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.72f, 0.72f, 0.72f, 0.78f);
			Colors[ImGuiCol_SeparatorActive] = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
			Colors[ImGuiCol_ResizeGrip] = ImVec4(0.91f, 0.91f, 0.91f, 0.25f);
			Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.81f, 0.81f, 0.81f, 0.67f);
			Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.46f, 0.46f, 0.46f, 0.95f);
			Colors[ImGuiCol_PlotLines] = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
			Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
			Colors[ImGuiCol_PlotHistogram] = ImVec4(0.73f, 0.60f, 0.15f, 1.00f);
			Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
			Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.87f, 0.87f, 0.87f, 0.35f);
			Colors[ImGuiCol_ModalWindowDarkening] = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
			Colors[ImGuiCol_Tab] = ImVec4(0.44f, 0.44f, 0.44f, 0.40f);
			Colors[ImGuiCol_TabHovered] = ImVec4(0.46f, 0.47f, 0.48f, 1.00f);
			Colors[ImGuiCol_TabActive] = ImVec4(0.42f, 0.42f, 0.42f, 1.00f);
			Colors[ImGuiCol_TabUnfocused] = ImVec4(0.44f, 0.44f, 0.44f, 0.40f);
			Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.42f, 0.42f, 0.42f, 1.00f);

			auto Path = GetWorkingPath() + L"\\scripts";

			/* TODO: use FindFirstChangeNotification to monitor for new files */
			if (std::filesystem::exists(Path))
			{
				for (const auto& File : std::filesystem::directory_iterator(Path))
				{
					ListBoxContents.push_back(File.path().filename().wstring());
					ListBoxAnsiContents.push_back(File.path().filename().string());
				}
			}

			UNUSED(InitializeCriticalSectionAndSpinCount(&ScriptHubSection, 0x00000400UL));
			UNUSED(InitializeCriticalSectionAndSpinCount(&ExplorerSection, 0x00000400UL));

			std::thread([]
			{
				const auto ApiDump = json::parse(cpr::Get(cpr::Url{ OBFUSCATE_STR("https://anaminus.github.io/rbx/json/api/latest.json") }).text);

				EnterCriticalSection(&ExplorerSection);

				std::map<std::string, std::string> SuperClassTree;

				for (const auto& It : ApiDump.items())
				{
					const auto Value = It.value();
					const auto Type = Value["type"].get<std::string>();

					if (Type == "Class")
					{
						const auto Name = Value["Name"].get<std::string>();

						if (!Value["Superclass"].is_null())
						{
							//Some classes might have no properties of their own.
							if (!ExplorerProperties.count(Name))
								ExplorerProperties[Name] = std::vector<RbxProperty>();

							SuperClassTree[Name] = Value["Superclass"].get<std::string>();
						}
						else
						{
							SuperClassTree[Name] = "<<<ROOT>>>";
						}
					}
					else if (Type == "Property")
					{
						const auto Class = Value["Class"].get<std::string>();
						const auto Name = Value["Name"].get<std::string>();
						const auto ValueType = Value["ValueType"].get<std::string>();

						if (!ExplorerProperties.count(Class))
							ExplorerProperties[Class] = std::vector<RbxProperty>();

						auto Flags = 0;
						for (const auto& ItTag : Value["tags"].items())
						{
							const auto ValueTag = ItTag.value().get<std::string>();

							if (ValueTag == "readonly")
							{
								Flags |= READONLY;
							}
							else if (ValueTag == "deprecated" || ValueTag == "hidden")
							{
								goto BreakLoop;
							}
						}

						RbxProperty Prop{};
						Prop.Property = Name;

						if (ValueType == "int"
							|| ValueType == "int64"
							|| ValueType == "double"
							|| ValueType == "float"
						)
						{
							Prop.Type = NUMBER;
						}
						else if (ValueType == "bool")
						{
							Prop.Type = BOOL;
						}
						else if (ValueType == "string")
						{
							Prop.Type = STRING;
						}
						else
						{
							Prop.Type = CLASS;
						}

						Prop.Flags = Flags;

						ExplorerProperties[Class].push_back(Prop);
					}

					BreakLoop:
					continue;
				}

				for (auto& [Key, Arr] : ExplorerProperties)
				{
					auto SuperClass = SuperClassTree[Key];

					while (SuperClass != "<<<ROOT>>>")
					{
						Arr.insert(std::end(Arr), std::begin(ExplorerProperties[SuperClass]), std::end(ExplorerProperties[SuperClass]));

						SuperClass = SuperClassTree[SuperClass];
					}
				}

				for (auto& [ClassName, TexInfo] : ExplorerImagesMap)
				{
					ID3D11ShaderResourceView* Texture;

					//todo: disgusting
					D3D11_TEXTURE2D_DESC desc;
					ZeroMemory(&desc, sizeof(desc));
					desc.Width = 16;
					desc.Height = 16;
					desc.MipLevels = 1;
					desc.ArraySize = 1;
					desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
					desc.SampleDesc.Count = 1;
					desc.Usage = D3D11_USAGE_DEFAULT;
					desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
					desc.CPUAccessFlags = 0;

					ID3D11Texture2D* pTexture = NULL;
					D3D11_SUBRESOURCE_DATA subResource;
					subResource.pSysMem = TexInfo;
					subResource.SysMemPitch = desc.Width * 4;
					subResource.SysMemSlicePitch = 0;
					g_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);

					D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
					ZeroMemory(&srvDesc, sizeof srvDesc);
					srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
					srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
					srvDesc.Texture2D.MipLevels = desc.MipLevels;
					srvDesc.Texture2D.MostDetailedMip = 0;
					g_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &Texture);

					pTexture->Release();

					ExplorerIcons[ClassName] = (ImTextureID) Texture;
				}

				ExplorerInit = TRUE;

				LeaveCriticalSection(&ExplorerSection);
			}).detach();
		}

		ImGui::SetNextWindowSizeConstraints(ImVec2(210, 110), ImVec2(FLT_MAX, FLT_MAX));
		if (ImGui::Begin(OBFUSCATE_STR("Synapse X"), NULL, ImGuiWindowFlags_MenuBar))
		{
			if (ImGui::BeginMenuBar())
			{
				if (ImGui::BeginMenu("File"))
				{
					if (ImGui::MenuItem("Load"))
					{
						wchar_t FileName[MAX_PATH];
						wchar_t FileTitle[MAX_PATH];

						FileName[0] = '\0';
						FileTitle[0] = '\0';

						OPENFILENAMEW Ofn;
						SecureZeroMemory(&Ofn, sizeof Ofn);
						Ofn.lStructSize = sizeof Ofn;
						Ofn.hwndOwner = NULL;
						Ofn.lpstrFilter = L"Script Files (*.lua, *.txt)\0*.lua;*.txt\0";
						Ofn.lpstrTitle = L"Synapse X - Load File";
						Ofn.lpstrInitialDir = syn::WorkspaceDirectory.c_str();
						Ofn.lpstrFileTitle = FileTitle;
						Ofn.lpstrFile = FileName;
						Ofn.nMaxFile = MAX_PATH;
						Ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
						Ofn.lpstrDefExt = L"lua";

						if (GetOpenFileNameW(&Ofn))
						{
							std::ifstream Stream(Ofn.lpstrFile, std::ios_base::binary);
							std::string Final((std::istreambuf_iterator<char>(Stream)),
								std::istreambuf_iterator<char>());
							Editor.SetText(Final);
						}
					}

					if (ImGui::MenuItem("Save"))
					{
						wchar_t FileName[MAX_PATH];
						wchar_t FileTitle[MAX_PATH];

						FileName[0] = L'\0';
						FileTitle[0] = L'\0';

						OPENFILENAMEW Ofn;
						SecureZeroMemory(&Ofn, sizeof Ofn);
						Ofn.lStructSize = sizeof Ofn;
						Ofn.hwndOwner = NULL;
						Ofn.lpstrFilter = L"Script Files (*.lua, *.txt)\0*.lua;*.txt\0";
						Ofn.lpstrTitle = L"Synapse X - Save File";
						Ofn.lpstrInitialDir = syn::WorkspaceDirectory.c_str();
						Ofn.lpstrFileTitle = FileTitle;
						Ofn.lpstrFile = FileName;
						Ofn.nMaxFile = MAX_PATH;
						Ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY;
						Ofn.lpstrDefExt = L"lua";

						if (GetSaveFileNameW(&Ofn))
						{
							std::ofstream Out;
							Out.open(Ofn.lpstrFile, std::ios::out | std::ios::binary);
							auto Contents = Editor.GetText();
							Out.write(Contents.c_str(), Contents.size());
							Out.close();
						}
					}

					ImGui::EndMenu();
				}

				ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.14f, 0.14f, 0.14f, 1.00f));
				ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.14f, 0.14f, 0.14f, 1.00f));
				ImGui::PushStyleColor(ImGuiCol_BorderShadow, ImVec4(0.14f, 0.14f, 0.14f, 1.00f));

				if (ImGui::Button("Execute"))
				{
					VM_TIGER_WHITE_START;

					if (!SecureLuaFlag)
					{
						ScriptRunCounter++;

						syn::Scheduler::GetSingleton()->Push(Editor.GetText());
					}

					VM_TIGER_WHITE_END;
				}

				if (ImGui::Button("Clear"))
				{
					Editor.SetText("");
				}

				ImGui::PopStyleColor(3);

				ImGui::EndMenuBar();
			}

			Editor.Render("TextEditor");
		}

		ImGui::End();
		ImGui::PopFont();

		ImGui::SetNextWindowSize(ImVec2(464, 444), ImGuiCond_FirstUseEver);
		ImGui::PushFont(GetFont(1));
		if (ImGui::Begin("Scripts", NULL, NULL))
		{
			static auto CurrentItem = -1;
			ImGui::PushItemWidth(-1);
			ImGui::ListBox("##Script Box", &CurrentItem, VectorGetter,
				static_cast<void*>(&ListBoxAnsiContents), ListBoxAnsiContents.size(),
				(int)(ImGui::GetWindowHeight() / 20));

			ImGui::Separator();

			if (ImGui::Button("Run", ImVec2(ImGui::GetWindowWidth() / 2 - 12, 20)) && CurrentItem != -1)
			{
				std::wstring scriptPath = GetWorkingPath() + L"\\scripts\\" + ListBoxContents.at(CurrentItem);

				if (std::filesystem::exists(scriptPath))
				{
					std::ifstream Stream(scriptPath, std::ios_base::binary);
					std::string Final((std::istreambuf_iterator<char>(Stream)),
						std::istreambuf_iterator<char>());

					VM_TIGER_WHITE_START;

					if (!SecureLuaFlag)
					{
						ScriptRunCounter++;

						syn::Scheduler::GetSingleton()->Push(Final);
					}

					VM_TIGER_WHITE_END;
				}
				else
				{
					ListBoxContents.erase(ListBoxContents.begin() + CurrentItem);
					ListBoxAnsiContents.erase(ListBoxAnsiContents.begin() + CurrentItem);
					CurrentItem = -1;
				}
			}

			ImGui::SameLine();

			if (ImGui::Button("Load Into Editor", ImVec2(ImGui::GetWindowWidth() / 2 - 12, 20)) && CurrentItem != -1)
			{
				std::wstring scriptPath = GetWorkingPath() + L"\\scripts\\" + ListBoxContents.at(CurrentItem);

				if (std::filesystem::exists(scriptPath))
				{
					std::ifstream Stream(scriptPath, std::ios_base::binary);
					std::string Final((std::istreambuf_iterator<char>(Stream)),
						std::istreambuf_iterator<char>());

					Editor.SetText(Final);
				}
				else
				{
					ListBoxContents.erase(ListBoxContents.begin() + CurrentItem);
					ListBoxAnsiContents.erase(ListBoxAnsiContents.begin() + CurrentItem);
					CurrentItem = -1;
				}
			}

			ImGui::PopItemWidth();
		}

		ImGui::End();
		ImGui::PopFont();

		ImGui::PushFont(GetFont(1));

		ImGui::SetNextWindowSize(ImVec2(533, 322), ImGuiCond_FirstUseEver);
		ImGui::SetNextWindowSizeConstraints(ImVec2(365, 110), ImVec2(FLT_MAX, FLT_MAX));
		if (ImGui::Begin("Console", NULL, NULL))
		{
			ImGui::Checkbox("Output Redirection", &OutputRedirection);
			ImGui::SameLine();
			ImGui::Checkbox("AutoScroll", &AutoScroll);
			ImGui::Separator();

			const auto HeightToReserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing();
			ImGui::BeginChild("ScrollingRegion", ImVec2(0, -HeightToReserve), false, ImGuiWindowFlags_HorizontalScrollbar);
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 1));
			for (const auto& Item : ConsoleOutput)
			{
				ImGui::PushStyleColor(ImGuiCol_Text, Item.second);
				ImGui::TextUnformatted(Item.first.c_str());
				ImGui::PopStyleColor();
			}

			if (AutoScroll)
			{
				ImGui::SetScrollHereY(1.0f);
			}

			ImGui::PopStyleVar();
			ImGui::EndChild();
			ImGui::Separator();

			auto ReclaimFocus = false;
			static char InputBuf[256];
			if (ImGui::InputText("##Input", InputBuf, IM_ARRAYSIZE(InputBuf), ImGuiInputTextFlags_EnterReturnsTrue))
			{
				if (InputBuf[0])
				{
					syn::Scheduler::GetSingleton()->Push(InputBuf);
					ConsoleOutput.emplace_back("> " + std::string(InputBuf), 0xFFA0A0A0);
				}

				SecureZeroMemory(InputBuf, 256);

				ReclaimFocus = true;
			}

			if (AutoScroll)
			{
				ImGui::SetItemDefaultFocus();
				if (ReclaimFocus)
					ImGui::SetKeyboardFocusHere(-1);
			}

			ImGui::SameLine();

			if (ImGui::SmallButton("Clear"))
			{
				ConsoleOutput.clear();
			}
		}

		ImGui::End();
		ImGui::PopFont();

		ImGui::PushFont(GetFont(1));

		ImGui::SetNextWindowSize(ImVec2(591, 293), ImGuiCond_FirstUseEver);
		ImGui::SetNextWindowSizeConstraints(ImVec2(591, 293), ImVec2(FLT_MAX, FLT_MAX));
		EnterCriticalSection(&ScriptHubSection);

		if (ScriptHubInit && ImGui::Begin("Script Hub", NULL, NULL))
		{
			static auto CurrentItem = -1;
			ImGui::PushItemWidth(-1);
			ImGui::ListBox("##Hub Box", &CurrentItem, VectorGetter,
				static_cast<void*>(&ScriptHubContents), ScriptHubContents.size(),
				(int)(ImGui::GetWindowHeight() / 20) - 50);

			ImGui::Separator();

			/* //TODO: reimplement this after rewrite, right now some internal stuff is broken with the website
			const auto HeightToReserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing();
			ImGui::BeginChild("ScrollingRegion", ImVec2(0, -HeightToReserve), false, ImGuiWindowFlags_HorizontalScrollbar);
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 1));

			if (CurrentItem != -1)
			{
				ImGui::PushStyleColor(ImGuiCol_Text, ImVec4{ 255, 255, 255, 255 });
				ImGui::TextUnformatted(ScriptHubData[ScriptHubContents.at(CurrentItem)].Description.c_str());
				ImGui::PopStyleColor();
			}

			ImGui::PopStyleVar();
			ImGui::EndChild();

			ImGui::Separator();

			if (ImGui::Button("Run", ImVec2(ImGui::GetWindowWidth(), 20)) && CurrentItem != -1)
			{
				auto Url = ScriptHubData[ScriptHubContents.at(CurrentItem)].Url;

				VM_TIGER_WHITE_START;

				if (!SecureLuaFlag)
				{
					ScriptRunCounter++;

					std::thread([Url]
					{
						syn::Scheduler::GetSingleton()->Push(cpr::Get(cpr::Url{ Url }).text);
					}).detach();
				}

				VM_TIGER_WHITE_END;
			}*/
		}

		LeaveCriticalSection(&ScriptHubSection);

		ImGui::End();
		ImGui::PopFont();

		ImGui::PushFont(GetFont(1));

		if (ImGui::Begin("Explorer", NULL, NULL))
		{
			IsInstanceSeen = false;

			for (auto& CInst : syn::Instance(DataModel).GetChildren())
			{
				DrawInstance(CInst);
			}
		}

		ImGui::End();
		ImGui::PopFont();

		ImGui::PushFont(GetFont(1));

		if (ImGui::Begin("Explorer Properties", NULL, NULL) && IsInstanceSeen && ExplorerInit)
		{
			EnterCriticalSection(&ExplorerSection);

			const auto Inst = syn::Instance(InstanceSelected);
			const auto ClassName = Inst.GetInstanceClassName();

			if (!ExplorerProperties.count(ClassName))
			{
				LeaveCriticalSection(&ExplorerSection);
				goto ExplorerExit; //It's better then a nested if statement.
			}

			LeaveCriticalSection(&ExplorerSection);

			static std::map<std::string, RbxPropertyValue> PropertiesMap;
			static std::map<std::string, std::string> NewPropertiesMap;
			static std::string LastClassName;
			static uint32_t Step = 0;
			static uintptr_t ScriptImpPtr = 0;
			if (!ScriptImpPtr)
				ScriptImpPtr = syn::RobloxBase(syn::Lua::RbxImpersonatorConstruct);

			if (LastClassName != ClassName)
			{
				Step = 31;
				PropertiesMap.clear();

				LastClassName = ClassName;
			}

			if (Step >= 30)
			{
				Step = 0;

				syn::Scheduler::GetSingleton()->Push([Inst, ClassName](const DWORD RL)
				{
					if (InstanceSelected != Inst || !IsInstanceSeen)
					{
						NewPropertiesMap.clear();
						return;
					}

					const auto OldIdentity = syn::RbxLua(RL).GetIdentity();

					DWORD _this{};
					((void(__thiscall*)(DWORD*, DWORD))ScriptImpPtr)(&_this, 6);

					for (auto& Prop : ExplorerProperties[ClassName])
					{
						RbxPropertyValue Value{};
						Value.Type = Prop.Type;
						Value.Flags = Prop.Flags;
						Value.Value = GetInstanceValue(RL, Inst, Prop.Property);

						PropertiesMap[Prop.Property] = Value;

						if (NewPropertiesMap.count(Prop.Property))
						{
							SetInstanceValue(RL, Inst, Prop.Property, Prop.Type, NewPropertiesMap[Prop.Property]);
						}
					}

					((void(__thiscall*)(DWORD*, DWORD))ScriptImpPtr)(&_this, OldIdentity);

					NewPropertiesMap.clear();
				});
			}

			Step++;

			static std::string DecScriptBackup;

			if (ImGui::SmallButton("Destroy"))
			{
				auto Scheduler = syn::Scheduler::GetSingleton();

				Scheduler->Push([Inst](DWORD RL)
				{
					if (InstanceSelected != Inst || !IsInstanceSeen)
						return;

					const auto OldIdentity = syn::RbxLua(RL).GetIdentity();

					DWORD _this{};
					((void(__thiscall*)(DWORD*, DWORD))ScriptImpPtr)(&_this, 6);

					DestroyInstance(RL, Inst);

					((void(__thiscall*)(DWORD*, DWORD))ScriptImpPtr)(&_this, OldIdentity);
				});
			}

			if (ClassName == "LocalScript" || ClassName == "ModuleScript")
			{
				static uintptr_t LastScript = 0;

				if (DecScript.empty())
				{
					ImGui::SameLine();

					if (ImGui::SmallButton("Decompile"))
					{
						LastScript = InstanceSelected;

						syn::Scheduler::GetSingleton()->Push([](DWORD RL)
						{
							if (!IsInstanceSeen)
								return;

							const auto SelectedInst = syn::Instance(InstanceSelected);
							const auto SelectedInstClass = SelectedInst.GetInstanceClassName();

							if (SelectedInstClass != "LocalScript" && SelectedInstClass != "ModuleScript")
								return;

							const auto MSpoofCallback = syn::MemSpoofer::Spoof();

#ifdef EnableLuaUTranslator
							LuaU_MagicMul = 227;
#endif
							auto Sthread = syn::LuaTranslator::GetSingleton()->Convert(syn::Scheduler::GetSingleton()->MainThread, OBFUSCATE_STR("return function(a) setdecscript(decompile(a)) end"), 0, nullptr);
#ifdef EnableLuaUTranslator
							LuaU_MagicMul = 1;
#endif

							Sthread.PushCFunction(SetDecScript);
							Sthread.SetGlobal(OBFUSCATE_STR("setdecscript"));

							Sthread.PCall(0, 1, 0);

							struct RbxThreadRef
							{
								BYTE Pad[8];
								DWORD L;
							};

							RbxThreadRef Ref{};
							Ref.L = Sthread;

							const auto ScriptContext = syn::Instance(DataModel).GetChildFromClassName(OBFUSCATE_STR("ScriptContext"));
							static DWORD RResume = 0;
							static DWORD PushF = 0;

							if (!RResume)
								RResume = RobloxBase(syn::Lua::RbxResume);
							if (!PushF)
								PushF = RbxLua::GetBinValue(FNVA1_CONSTEXPR("pushinstance"));

							const auto RealInst = (DWORD) SelectedInst;
							((int(__cdecl*)(DWORD, DWORD))PushF)(Sthread, (DWORD) &RealInst);
							MSpoofCallback();

							((int(__thiscall*)(int, RbxThreadRef*, int))RResume)(ScriptContext, &Ref, 1);
						});
					}
				}

				if (!DecScript.empty())
				{
					if (LastScript != InstanceSelected)
					{
						DecScript = "";
					}
					else
					{
						ImGui::SameLine();

						if (ImGui::SmallButton("Properties"))
						{
							DecScript = "";
						}
					}
				}

				if (!DecScript.empty())
				{
					ImGui::Separator();

					if (DecScript != DecScriptBackup)
					{
						DecompilerEditor.SetText(DecScript);
						DecompilerEditor.SetReadOnly(true);

						DecScriptBackup = DecScript;
					}

					DecompilerEditor.Render("TextEditorDecompiler");
					goto ExplorerExit; //todo: Lazy.
				}
			}

			ImGui::Separator();

			auto Ctr = 0;

			char Buf[256];
			SecureZeroMemory(Buf, 256);

			for (auto& [Prop, Value] : PropertiesMap)
			{
				ImGui::Text("%s", Prop.c_str());

				int Flags = ImGuiInputTextFlags_EnterReturnsTrue;
				if (Value.Flags & READONLY || Value.Type == CLASS)
					Flags |= ImGuiInputTextFlags_ReadOnly;

				if (ImGui::InputTextWithHint((std::string("##PropMap") + IntToHex(Inst) + IntToHex(Ctr)).c_str(), Value.Value.c_str(), Buf, 256, Flags))
				{
					NewPropertiesMap[Prop] = std::string(Buf);
				}

				ImGui::Separator();

				SecureZeroMemory(Buf, 256);

				Ctr++;
			}
		}

		ExplorerExit:

		ImGui::End();
		ImGui::PopFont();
	}

	void syn::D3D::AddToRenderList(D3DObject* Object)
	{
		RenderChain.push_back(Object);
	}

	void syn::D3D::RemoveFromRenderList(D3DObject* Object)
	{
		RenderChain.erase(std::remove(RenderChain.begin(), RenderChain.end(), Object), RenderChain.end());
	}

	float syn::D3D::DrawText(ImFont* font, const std::string& text, const ImVec2& pos, float size, ImU32 color,
		ImU32 ocolor, bool center, bool outline) const
	{
		auto Window = ImGui::GetCurrentWindow();

		ImGui::PushFont(font);

		std::stringstream steam(text);
		std::string line;

		auto y = 0.0f;
		auto i = 0;

		while (std::getline(steam, line))
		{
			const auto TextSize = font->CalcTextSizeA(size, FLT_MAX, 0.0f, line.c_str());

			if (center)
			{
				if (outline)
				{
					Window->DrawList->AddText(font, size, ImVec2(pos.x - TextSize.x / 2.0f + 1, pos.y + TextSize.y * i + 1),
						ocolor, line.c_str());
					Window->DrawList->AddText(font, size, ImVec2(pos.x - TextSize.x / 2.0f - 1, pos.y + TextSize.y * i - 1),
						ocolor, line.c_str());
					Window->DrawList->AddText(font, size, ImVec2(pos.x - TextSize.x / 2.0f + 1, pos.y + TextSize.y * i - 1),
						ocolor, line.c_str());
					Window->DrawList->AddText(font, size, ImVec2(pos.x - TextSize.x / 2.0f - 1, pos.y + TextSize.y * i + 1),
						ocolor, line.c_str());
				}

				Window->DrawList->AddText(font, size, ImVec2(pos.x - TextSize.x / 2.0f, pos.y + TextSize.y * i), color,
					line.c_str());
			}
			else
			{
				if (outline)
				{
					Window->DrawList->AddText(font, size, ImVec2(pos.x + 1, pos.y + TextSize.y * i + 1), ocolor,
						line.c_str());
					Window->DrawList->AddText(font, size, ImVec2(pos.x - 1, pos.y + TextSize.y * i - 1), ocolor,
						line.c_str());
					Window->DrawList->AddText(font, size, ImVec2(pos.x + 1, pos.y + TextSize.y * i - 1), ocolor,
						line.c_str());
					Window->DrawList->AddText(font, size, ImVec2(pos.x - 1, pos.y + TextSize.y * i + 1), ocolor,
						line.c_str());
				}

				Window->DrawList->AddText(font, size, ImVec2(pos.x, pos.y + TextSize.y * i), color, line.c_str());
			}

			y = pos.y + TextSize.y * (i + 1);
			i++;
		}

		ImGui::PopFont();

		return y;
	}

	void syn::D3D::DrawLine(const ImVec2& from, const ImVec2& to, ImU32 color, float thickness)
	{
		auto Window = ImGui::GetCurrentWindow();

		Window->DrawList->AddLine(from, to, color, thickness);
	}

	void syn::D3D::DrawBox(const ImVec2& from, const ImVec2& size, ImU32 color, float thickness)
	{
		auto Window = ImGui::GetCurrentWindow();

		Window->DrawList->AddRect(from, ImVec2(from.x + size.x, from.y + size.y), color, 0, ~0, thickness);
	}

	void syn::D3D::DrawBoxFilled(const ImVec2& from, const ImVec2& size, ImU32 color)
	{
		auto Window = ImGui::GetCurrentWindow();

		Window->DrawList->AddRectFilled(from, ImVec2(from.x + size.x, from.y + size.y), color);
	}

	void syn::D3D::DrawCircle(const ImVec2& position, float radius, ImU32 color, float thickness, int sides)
	{
		auto Window = ImGui::GetCurrentWindow();

		Window->DrawList->AddCircle(position, radius, color, sides, thickness);
	}

	void syn::D3D::DrawCircleFilled(const ImVec2& position, float radius, ImU32 color, int sides)
	{
		auto Window = ImGui::GetCurrentWindow();

		Window->DrawList->AddCircleFilled(position, radius, color, sides);
	}
}
