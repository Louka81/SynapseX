
/*
*
*	SYNAPSE X
*	File.:	Entry.cpp
*	Desc.:	Entrypoint for Synapse
*
*/

#include "Static.hpp"
#include "D3D.hpp"

#include "../Misc/Flags.hpp"
#include "../Misc/AutoBin.hpp"
#include "../Misc/Structures.hpp"

#include "../Security/MemCheck.hpp"
#include "../Security/DataBin.hpp"
#include "../Security/AntiDump.hpp"
#include "../Security/PEBUnlink.hpp"
#include "../Security/SysHook.hpp"
#include "../Security/Fingerprint.hpp"
#include "../Security/FunctionReader.hpp"

#include "../Execution/RbxApi.hpp"
#include "../Execution/RbxLua.hpp"
#include "../Execution/Scheduler.hpp"
#include "../Execution/RbxInstance.hpp"
#include "../Execution/Conversion/RbxConversion.hpp"

#include "../../Utilities/Console.hpp"
#include "../../Utilities/FakeMemoryHasher.hpp"

#include "../../Utilities/Hashing/sha512.h"

#include "./Profiler.hpp"
#include "../Security/AntiDebug.hpp"
#include "../Security/AntiProxy.hpp"

uintptr_t syn::RobloxBase(uintptr_t ToAdjust)
{
	return reinterpret_cast<uintptr_t>(syn::RobloxModule) + (ToAdjust - 0x400000);
}

__declspec(noinline) const char* ErrorCodeToString(DWORD code)
{
	switch (code)
	{
		case EXCEPTION_ACCESS_VIOLATION:         return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:    return "EXCEPTION_ARRAY_BOUNDS_EXCEEDED";
		case EXCEPTION_BREAKPOINT:               return "EXCEPTION_BREAKPOINT";
		case EXCEPTION_DATATYPE_MISALIGNMENT:    return "EXCEPTION_DATATYPE_MISALIGNMENT";
		case EXCEPTION_FLT_DENORMAL_OPERAND:     return "EXCEPTION_FLT_DENORMAL_OPERAND";
		case EXCEPTION_FLT_DIVIDE_BY_ZERO:       return "EXCEPTION_FLT_DIVIDE_BY_ZERO";
		case EXCEPTION_FLT_INEXACT_RESULT:       return "EXCEPTION_FLT_INEXACT_RESULT";
		case EXCEPTION_FLT_INVALID_OPERATION:    return "EXCEPTION_FLT_INVALID_OPERATION";
		case EXCEPTION_FLT_OVERFLOW:             return "EXCEPTION_FLT_OVERFLOW";
		case EXCEPTION_FLT_STACK_CHECK:          return "EXCEPTION_FLT_STACK_CHECK";
		case EXCEPTION_FLT_UNDERFLOW:            return "EXCEPTION_FLT_UNDERFLOW";
		case EXCEPTION_ILLEGAL_INSTRUCTION:      return "EXCEPTION_ILLEGAL_INSTRUCTION";
		case EXCEPTION_IN_PAGE_ERROR:            return "EXCEPTION_IN_PAGE_ERROR";
		case EXCEPTION_INT_DIVIDE_BY_ZERO:       return "EXCEPTION_INT_DIVIDE_BY_ZERO";
		case EXCEPTION_INT_OVERFLOW:             return "EXCEPTION_INT_OVERFLOW";
		case EXCEPTION_INVALID_DISPOSITION:      return "EXCEPTION_INVALID_DISPOSITION";
		case EXCEPTION_NONCONTINUABLE_EXCEPTION: return "EXCEPTION_NONCONTINUABLE_EXCEPTION";
		case EXCEPTION_PRIV_INSTRUCTION:         return "EXCEPTION_PRIV_INSTRUCTION";
		case EXCEPTION_SINGLE_STEP:              return "EXCEPTION_SINGLE_STEP";
		case EXCEPTION_STACK_OVERFLOW:           return "EXCEPTION_STACK_OVERFLOW";
		case EXCEPTION_GUARD_PAGE:               return "EXCEPTION_GUARD_PAGE";
		case 0xE06D7363:				         return "EXCEPTION_CPP";
		default:								 return "UNKNOWN EXCEPTION";
	}
}

#ifdef EnableDebugOutput
void WalkStack(PEXCEPTION_POINTERS pExceptionInfo) 
{
	const auto process = GetCurrentProcess();
	SymInitialize(process, NULL, TRUE);

	auto context_record = *pExceptionInfo->ContextRecord;
	STACKFRAME64 stack_frame;
	memset(&stack_frame, 0, sizeof stack_frame);
	const auto machine_type = IMAGE_FILE_MACHINE_I386;
	stack_frame.AddrPC.Offset = context_record.Eip;
	stack_frame.AddrFrame.Offset = context_record.Ebp;
	stack_frame.AddrPC.Mode = AddrModeFlat;
	stack_frame.AddrFrame.Mode = AddrModeFlat;
	stack_frame.AddrStack.Mode = AddrModeFlat;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    PSYMBOL_INFO symbol = (PSYMBOL_INFO)buffer;
    symbol->MaxNameLen = 255;
	symbol->SizeOfStruct = sizeof(SYMBOL_INFO);

	printf("\nWalking the stack...\n");
	auto ind = 0;
	while (StackWalk64(machine_type,
		GetCurrentProcess(),
		GetCurrentThread(),
		&stack_frame,
		&context_record,
		NULL,
		&SymFunctionTableAccess64,
		&SymGetModuleBase64,
		NULL))
	{
		DWORD64 displacement = 0;

		if (SymFromAddr(process, (DWORD64)stack_frame.AddrPC.Offset, &displacement, symbol))
		{
			IMAGEHLP_MODULE64 moduleInfo;
			ZeroMemory(&moduleInfo, sizeof(IMAGEHLP_MODULE64));
			moduleInfo.SizeOfStruct = sizeof moduleInfo;

			printf("%d -  ", ind);
			if (::SymGetModuleInfo64(process, symbol->ModBase, &moduleInfo))
			{
				printf("%s: ", moduleInfo.ModuleName);
			}

			printf("%s + 0x%lx (%lx)\n", symbol->Name, (DWORD)displacement, (DWORD)stack_frame.AddrPC.Offset);
		}
		ind++;
	}

	printf("Finished.\n");
}
#endif

std::tuple<DWORD, std::string> GetModuleFileNameFromAddress(DWORD Addr)
{
	MODULEENTRY32 me32;
	HANDLE HModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
	me32.dwSize = sizeof(MODULEENTRY32);

	if (!Module32First(HModuleSnap, &me32))
	{
		return std::make_tuple(0, OBFUSCATE_STR("Unknown"));
	}
	do
	{
		if (Addr - (DWORD) me32.modBaseAddr <= me32.modBaseSize)
		{
			CloseHandle(HModuleSnap);
			return std::make_tuple((DWORD) me32.modBaseAddr, std::string(me32.szModule));
		}

	} while (Module32Next(HModuleSnap, &me32));

	CloseHandle(HModuleSnap);

	if (Addr - (DWORD) syn::Module <= syn::ModuleSize)
	{
		return std::make_tuple((DWORD) syn::Module, std::string(OBFUSCATE_STR("Synapse")));
	}

	return std::make_tuple(0, OBFUSCATE_STR("Unknown"));
}

static std::once_flag ExceptionFlag;
LONG WINAPI SynapseExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo)
{
    /* check for intentional Synapse Crash */
    if (ExceptionInfo->ContextRecord->Eax == 0 && ExceptionInfo->ContextRecord->Ebx == 0 && 
        ExceptionInfo->ContextRecord->Ecx == 0 && ExceptionInfo->ContextRecord->Edx == 0 && 
        ExceptionInfo->ContextRecord->Esp == 0)
    {
        TerminateProcess(syn::RobloxProcess, 0);

        return 0;
    }

    std::call_once(ExceptionFlag,
        [&ExceptionInfo]()
        {
			//lol
			MessageBox(NULL, "Unfortunately, Synapse X has crashed.\n\nThis error has been uploaded to our servers. Check the discord for any potential fixes. Thanks!", "Synapse X - Crash Reporter", MB_OK);
        });

    TerminateProcess(syn::RobloxProcess, 0);

    return EXCEPTION_CONTINUE_SEARCH;
}

/* TODO: rewrite */
DWORD WINAPI SynapseScriptIPC([[maybe_unused]] LPVOID Param)
{
	syn::Profiler *prof = syn::Profiler::GetSingleton();
	prof->AddProfile(OBFUSCATE_STR("Script IPC Start"));
	auto FirstScript = TRUE;

	std::string PipeName = sha512(OBFUSCATE_STR("SynapseScript") + std::to_string(syn::ProcID)).substr(0, 16);

	const auto Pipe = CreateNamedPipe(std::string(OBFUSCATE_STR("\\\\.\\pipe\\") + PipeName).c_str(),
		PIPE_ACCESS_DUPLEX | PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
		PIPE_WAIT,
		1,
		1024,
		1024,
		NMPWAIT_USE_DEFAULT_WAIT,
		NULL);

	auto Scheduler = syn::Scheduler::GetSingleton();

	while (Pipe != INVALID_HANDLE_VALUE)
	{
		if (ConnectNamedPipe(Pipe, NULL) != FALSE)
		{
			std::string Script;

			char buffer[1024] = {};
			DWORD Read;
			while (ReadFile(Pipe, buffer, 1024, &Read, NULL) != FALSE)
				Script.append(buffer, Read);

			if (FirstScript && Script.find("SYN_FILE_PATH|") == 0)
			{
				prof->AddProfile(OBFUSCATE_STR("Syn Pipe Init"));

				FirstScript = FALSE;
				std::vector<std::string> SplitContents;
				SplitString(Script, "|", SplitContents);

				/* Initialize static (for window) */
				syn::Static::InitializeWindow();

				if (SplitContents.at(2) == "TRUE" || SplitContents.at(4) == "TRUE")
					syn::D3D::Initialize(SplitContents.at(2) == "TRUE");

				if (SplitContents.at(3) == "TRUE")
				{
					syn::WSocketEnabled = 2;
				}
				else
				{
					syn::WSocketEnabled = 1;
				}

				if (SplitContents.at(4) == "TRUE")
				{
					IGuiEnabled = TRUE;
				}

				if (SplitContents.at(5) == "TRUE")
				{
					syn::IngameChatEnabled = 2;
				}
				else
				{
					syn::IngameChatEnabled = 1;
				}

				prof->AddProfile(OBFUSCATE_STR("Syn Pipe Init complete"));
			}
			else
			{
				prof->AddProfile(OBFUSCATE_STR("Syn Pipe received script"));

				VM_TIGER_WHITE_START

				if (!SecureLuaFlag)
				{
					ScriptRunCounter++;

					Scheduler->Push(Script);
				}

				VM_TIGER_WHITE_END
			}
		}

		DisconnectNamedPipe(Pipe);
	}

	return 0;
}

void WritePipe(HANDLE Pipe, const std::string& Data)
{
	DWORD DwWritten;
	WriteFile(Pipe, (Data + "\n").c_str(), Data.size() + 1, &DwWritten, NULL);
	FlushFileBuffers(Pipe);
}

__declspec(noinline) void AntiSkid()
{
    [[maybe_unused]] volatile uint32_t RetCst1 = 0x541B9F;
    [[maybe_unused]] volatile uint32_t RetCst2 = 0x1F3D8AF;
    [[maybe_unused]] volatile uint32_t RetCst3 = 0x1C0BCC3;

    [[maybe_unused]] volatile uint32_t SUpValCst1 = 0x961C86;
    [[maybe_unused]] volatile uint32_t SUpValCst2 = 0x3FC01FF;

	volatile auto Meme = std::string("Hello Aero! (or some other script kiddie like you) - You won't be finding encryption to skid here. Go away.");
}

/* TODO: This needs to be overhauled (*wink* *wink* loukas hooking lib) */
std::string GrabPolyHookHistory(int PolyHookID)
{
	std::string Error = "PolyHook - #" + std::to_string(PolyHookID) + ":\n";

	PLH::ErrorLog ErrLog = PLH::ErrorLog::singleton();

	std::string Msg = ErrLog.pop().msg;
	size_t Counter = 1;
	while (!Msg.empty())
	{
		Error += std::to_string(Counter++) + " - " + Msg + "\n";
		Msg = ErrLog.pop().msg;
	}

	return Error;
}

DWORD WINAPI SynapseMain(LPVOID Param)
{
	DbgConsoleExec(syn::Console* DbgConsole = syn::Console::GetSingleton());

    VM_TIGER_WHITE_START;

	if (syn::AntiDebug::Check())
		CrashRoblox(true, OBFUSCATE_STR("AntiDebug - #3"));

	if (syn::AntiDump::Check())
		CrashRoblox(true, OBFUSCATE_STR("AntiDump - #3.5"));

	syn::BinManager* bm = syn::BinManager::GetSingleton();
	syn::Profiler* prof = syn::Profiler::GetSingleton();

	DWORD CheckFlag;
	CHECK_CODE_INTEGRITY(CheckFlag, 0x9079a8c7);
	if (CheckFlag != 0x9079a8c7) CrashRoblox(true, OBFUSCATE_STR("CodeIntegrity - #1"));
	CHECK_PROTECTION(CheckFlag, 0x3b3df916);
	if (CheckFlag != 0x3b3df916) CrashRoblox(true, OBFUSCATE_STR("Protection - #1"));
	CHECK_VIRTUAL_PC(CheckFlag, 0x40c581d1);
	if (CheckFlag != 0x40c581d1)
	{
		MessageBox(NULL, OBFUSCATE_STR("Synapse X does not support virtualized enviorments. Please try again on a non-virtualized system."), OBFUSCATE_STR("Synapse X"), MB_OK | MB_ICONWARNING);
		CrashRoblox();
	}

	prof->AddProfile(OBFUSCATE_STR("Whitelist Start"));

    VM_TIGER_WHITE_END;

	syn::PipeHandle = CreateFile(TEXT(OBFUSCATE_STR("\\\\.\\pipe\\SynapseInteract")),
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);
	if (syn::PipeHandle == INVALID_HANDLE_VALUE)
		DbgConsoleExec(DbgConsole->Error("Failed to connect to named pipe"));

    VM_TIGER_WHITE_START;

	DbgConsoleExec(const auto wtime = std::time(nullptr));
	DbgConsoleExec(DbgConsole->Info("Checking whitelist..."));
	WritePipe(syn::PipeHandle, OBFUSCATE_STR("SYN_CHECK_WL"));
	auto Fingerprint = syn::SystemFingerprint::CreateUniqueFingerprint();
	DbgConsoleExec(DbgConsole->Info("Whitelist complete. Took %d second(s).", std::time(nullptr) - wtime));

	DbgConsoleExec(DbgConsole->Info("Loaded (%d/%d) DataBins.", bm->Count(), SYN_AUTO_EXPECTED_BINS));
	prof->AddProfile(OBFUSCATE_STR("Whitelist Complete"));

	/* Same. */
	AntiSkid();

    VM_TIGER_WHITE_END;

	WritePipe(syn::PipeHandle, OBFUSCATE_STR("SYN_SCANNING"));

	ImGui::CreateContext();
	ImGui::StyleColorsDark();

	syn::RbxLua::Initialize();

    VM_TIGER_LONDON_START;
	
	prof->AddProfile(OBFUSCATE_STR("Scanning start"));

    /* Alternate trust check bypass. The .data segment isn't memcheck'd, we can just set one of the dynamically set variables with our own (javascript:) */
	*(BYTE**)syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::DataModel::TrustCheckStr)) = (BYTE*)syn::TrustcheckBuff;

	prof->AddProfile(OBFUSCATE_STR("Set HWID"));
	syn::RbxApi::SetHWID(Fingerprint->ToString());

	prof->AddProfile(OBFUSCATE_STR("Attach hook"));
	syn::Scheduler::GetSingleton()->Attach();

	const auto GetCurrentThreadIdPointer = syn::FindProcAddress(syn::kernel32, OBFUSCATE_STR("GetCurrentThreadId"));
	PLH::x86Detour GetCurrentThreadHookObj((char*)GetCurrentThreadIdPointer, (char*) &GetCurrentThreadIdHook, &OriginalGetThreadId, x86Disasm);
	if (!GetCurrentThreadHookObj.hook())
		throw std::exception(GrabPolyHookHistory(5).c_str());

	MEMORY_BASIC_INFORMATION PolyMBI{};
	if (!VirtualQuery((LPVOID)OriginalGetThreadId, &PolyMBI, sizeof(PolyMBI)))
		throw std::exception(OBFUSCATE_STR("Poly VQ - Fail 5"));

	syn::SysHook::ProtectedMemory::GetSingleton()->Add((uintptr_t) PolyMBI.BaseAddress, PolyMBI.RegionSize);

	prof->AddProfile(OBFUSCATE_STR("IPC start"));
	CreateThread(NULL, NULL, SynapseScriptIPC, NULL, NULL, NULL);

    VM_TIGER_LONDON_END;

	volatile int noTailCall = 0;

#ifndef EnableDebugOutput
    uint32_t Count = 0;
	while (true)
	{
		Sleep(500);

        VM_TIGER_WHITE_START;

		if (syn::AntiDebug::Check())
			CrashRoblox(true, OBFUSCATE_STR("AntiDebug - #7"));

		if (syn::AntiDump::Check())
			CrashRoblox(true, OBFUSCATE_STR("AntiDump - #8"));

#if defined(EnableMemCheckBypass) || defined(EnableHSVMOnlyLuaU)
        static auto LogOnce = false;
        if (Count && Count % 8 == 0)
        {
            if (syn::FakeMemcheck::MemChanged() && !LogOnce)
            {
                LogOnce = true;
                prof->AddProfile(OBFUSCATE_STR("Memcheck invalidation")); /* Should help determine if there are any issues */
            }
        }
        Count++;
#endif

		//SecureLua specific checks
		if (SecureLuaFlag)
		{
			if (syn::AntiProxy::Check())
				CrashRoblox(true, OBFUSCATE_STR("AntiProxy - #9"));

			if (FindWindowW(L"e01043", NULL) || GetModuleHandleA(OBFUSCATE_STR("elysian.dll")) || GetModuleHandleA(OBFUSCATE_STR("ProtoSmasher.dll")))
				CrashRoblox(true, OBFUSCATE_STR("SecureLua - Attempted injection - #10"));
		}

        VM_TIGER_WHITE_END;

		[[maybe_unused]] volatile int noTailCall2 = 0;

		if (syn::AntiTamper::CheckIncrement() != syn::AntiTamper::OK)
			CrashRoblox(true, OBFUSCATE_STR("AntiTamper - #9"));
	}

#endif
	return 0;
}

BOOL APIENTRY DllMain(HMODULE mod, DWORD reason, LPVOID)
{
	if (reason == DLL_PROCESS_ATTACH)
	{
        VM_TIGER_LONDON_START;
		UNUSED(InitializeCriticalSectionAndSpinCount(&syn::InitSection, 0x00000400UL));

		/* Initialize static values */
		syn::Module = mod;
		syn::Static::Initialize();

		syn::Profiler* prof = syn::Profiler::GetSingleton();
		prof->AddProfile(OBFUSCATE_STR("Set exception filter"));

		/* Register exception handler */
		const HMODULE ntdll = GetModuleHandleA(OBFUSCATE_STR("ntdll.dll"));
		typedef VOID(WINAPI * RtlSetUnhandledExceptionFilterFn)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
		const auto _RtlSetFilter = (RtlSetUnhandledExceptionFilterFn)syn::FindProcAddress(ntdll, OBFUSCATE_STR("RtlSetUnhandledExceptionFilter"));

		_RtlSetFilter(SynapseExceptionFilter);

		/* hook exception handler for future bullshit */
		/* todo: defcon when you implement something make sure it doesnt kick you first
		 * <3 - 3ds
		 */
		/*PLH::x86Detour SetUEFObj((char*)syn::FindProcAddress(syn::kernel32, OBFUSCATE_STR("SetUnhandledExceptionFilter")), (char*)& SetUEFHook, &OriginalSetUEF, x86Disasm);
		if (!SetUEFObj.hook())
			throw std::exception(GrabPolyHookHistory(1).c_str());

		MEMORY_BASIC_INFORMATION PolyMBI{};
		if (!VirtualQuery((LPVOID) OriginalSetUEF, &PolyMBI, sizeof(PolyMBI)))
			throw std::exception(OBFUSCATE_STR("Poly VQ - Fail 0"));*/

		wchar_t Path[MAX_PATH];
		GetModuleFileNameW(mod, Path, MAX_PATH);

		const auto WS = std::filesystem::path(std::wstring(Path)).parent_path().parent_path().wstring() + L"\\workspace";

		syn::WorkspaceDirectory = WS;

		prof->AddProfile(OBFUSCATE_STR("AntiTamper Setup"));

		/* Setup anti-tamper */
		syn::AntiTamper::Setup();

		prof->AddProfile(OBFUSCATE_STR("AntiDump Setup"));

		/* Setup anti-dump */
		syn::AntiDump::Setup();

		prof->AddProfile(OBFUSCATE_STR("Done!"));

        VM_TIGER_LONDON_END;
	}

	return TRUE;
}

#pragma warning(disable : 4297)
extern "C" __declspec(dllexport) int Chad(DWORD Magic) 
{
	/* epic anti-LLA */
    VM_TIGER_LONDON_START;
	auto RMul = 0x7123A781 * GetCurrentProcessId();
	if (!(RMul % 2)) RMul++;
	Magic *= RMul;
	if ((Magic & 0xFFFF) != (GetCurrentProcessId() & 0xFFFF))
		CrashRoblox(true, OBFUSCATE_STR("AntiLoadLibrary - #1"));

	auto AutoLaunch = 0;
	if (Magic >> 30 & 1U)
		AutoLaunch = TRUE;

	syn::Profiler* prof = syn::Profiler::GetSingleton();

    /* Launch the debug console as soon as posbile, makes it easier to debug */
    DbgConsoleExec(syn::Console * DbgConsole = syn::Console::GetSingleton());
    DbgConsoleExec(DbgConsole->Info(SYNAPSE_VSTRING " - by 3dsboy08, brack4712, Louka, DefCon42, and Eternal"));

	volatile size_t Counter = 0;
	while (!syn::Module && Counter++ < 20)
		Sleep(250);

	if (!syn::Module)
		CrashRoblox();

	prof->AddProfile(OBFUSCATE_STR("PEB Unlink"));

#ifndef _PSEUDO_DEBUG
	/* Unlink from the PEB */
	UnlinkModuleFromPEB(syn::Module);
#endif

	/* Nuke PE header */
	prof->AddProfile(OBFUSCATE_STR("PE Wipe"));

	DWORD OldProtect, OldProtect2;
    syn::SafeVirtualProtect((LPVOID) syn::Module, 2, PAGE_EXECUTE_READWRITE, &OldProtect);
	WORD GenValue = (WORD) RandomInteger(0, 0xFFFF);
	while (GenValue == 0x5A4D) GenValue = (WORD) RandomInteger(0, 0xFFFF);
	*(WORD*)syn::Module = GenValue;
    syn::SafeVirtualProtect((LPVOID) syn::Module, 2, OldProtect, &OldProtect2);
	
	const auto DosHeader = (PIMAGE_DOS_HEADER) syn::Module;
	const auto NtHeader = (PIMAGE_NT_HEADERS)((char*)DosHeader + DosHeader->e_lfanew);
    syn::SafeVirtualProtect((LPVOID)NtHeader, 4, PAGE_EXECUTE_READWRITE, &OldProtect);
	uint32_t GenValue2 = RandomInteger(0, UINT_MAX);
	while (GenValue2 == 0x4550) GenValue2 = RandomInteger(0, UINT_MAX);
	*(DWORD*)NtHeader = GenValue2;
	
    syn::SafeVirtualProtect((LPVOID)NtHeader, 4, OldProtect, &OldProtect2);
	
	prof->AddProfile(OBFUSCATE_STR("Anti-Debug"));

	/* Setup anti-debug */
	syn::AntiDebug::Setup();

	if (syn::AntiDebug::Check())
		CrashRoblox(true, OBFUSCATE_STR("AntiDebug - #2"));

    prof->AddProfile(OBFUSCATE_STR("Initial fake scan"));
    syn::FakeMemcheck::Initialize();

	prof->AddProfile(OBFUSCATE_STR("Hook Setup"));

	/* Setup hooks */
    const auto IPHlp = syn::FindModule(OBFUSCATE_STR("IPHLPAPI.dll"));

	const auto RtlImageNtHeaderExPointer = syn::FindProcAddress(syn::ntdll, OBFUSCATE_STR("RtlImageNtHeaderEx"));
	const auto NtQIPPointer = syn::FindProcAddress(syn::ntdll, OBFUSCATE_STR("NtQueryInformationProcess"));
	const auto GetAdaptersAddressesPointer = syn::FindProcAddress(IPHlp, OBFUSCATE_STR("GetAdaptersAddresses"));

	MEMORY_BASIC_INFORMATION PolyMBI{};

	PLH::x86Detour RtlImageHookObj((char*) RtlImageNtHeaderExPointer, (char*) &RtlImageNtHeaderExHook, &OrigRtlImageNtHeaderEx, x86Disasm);
    if (!RtlImageHookObj.hook())
        throw std::exception(GrabPolyHookHistory(1).c_str());

	if (!VirtualQuery((LPVOID) OrigRtlImageNtHeaderEx, &PolyMBI, sizeof(PolyMBI)))
		throw std::exception(OBFUSCATE_STR("Poly VQ - Fail 1"));

	syn::SysHook::ProtectedMemory::GetSingleton()->Add((uintptr_t) PolyMBI.BaseAddress, PolyMBI.RegionSize);

	PLH::x86Detour NtQIPHookObj((char*) NtQIPPointer, (char*) &NtQIPHook, &OriginalNtQIP, x86Disasm);
    if (!NtQIPHookObj.hook())
        throw std::exception(GrabPolyHookHistory(2).c_str());

	if (!VirtualQuery((LPVOID) OriginalNtQIP, &PolyMBI, sizeof(PolyMBI)))
		throw std::exception(OBFUSCATE_STR("Poly VQ - Fail 2"));

	syn::SysHook::ProtectedMemory::GetSingleton()->Add((uintptr_t) PolyMBI.BaseAddress, PolyMBI.RegionSize);

	PLH::x86Detour GetAdaptersAddressesHookObj((char*) GetAdaptersAddressesPointer, (char*) &GetAdaptersAddressesHook, &OriginalGetAdaptersAddresses, x86Disasm);
	if (!GetAdaptersAddressesHookObj.hook())
	{
		if (AutoLaunch)
            throw std::exception(GrabPolyHookHistory(4).c_str());
	}
	else
	{
		if (!VirtualQuery((LPVOID) OriginalGetAdaptersAddresses, &PolyMBI, sizeof PolyMBI))
			throw std::exception(OBFUSCATE_STR("Poly VQ - Fail 3"));

		syn::SysHook::ProtectedMemory::GetSingleton()->Add((uintptr_t) PolyMBI.BaseAddress, PolyMBI.RegionSize);
	}

	syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("SysHook Setup"));

	MEMORY_BASIC_INFORMATION MBI{};
	if (!VirtualQuery((LPVOID)syn::Module, &MBI, sizeof(MBI)))
		throw std::exception(OBFUSCATE_STR("VQH Fail: 1"));

	syn::ModuleSize = MBI.RegionSize;

	MODULEINFO MI{};
	GetModuleInformation(syn::RobloxProcess, syn::ntdll, &MI, sizeof(MODULEINFO));
	syn::NtDllSize = MI.SizeOfImage;

	syn::SysHook::ProtectedMemory::GetSingleton()->Add((uintptr_t)syn::Module, MBI.RegionSize);

	if (syn::SysHook::Setup(AutoLaunch))
	{
		if (AutoLaunch)
		{
			//We need to hook ZwFilterToken in AutoLaunch. (its used as a comparison check)
			OriginalZwFT = (LPVOID) syn::SysHook::Hook((DWORD)syn::FindProcAddress(syn::ntdll, OBFUSCATE_STR("ZwFilterToken")), (DWORD)ZwFTHook);
		}

		OriginalNtQVM = (LPVOID) syn::SysHook::Hook((DWORD)syn::FindProcAddress(syn::ntdll, OBFUSCATE_STR("NtQueryVirtualMemory")), (DWORD)NtQVMHook);
		syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("SysHook Ready"));
	}
	else
	{
		MessageBox(NULL, OBFUSCATE_STR("Synapse X has failed to initialize extended anti-ban protection.\n\nWhile you will still be able to use Synapse X, you won't get extra protection that other users might get.\n\nPlease try using our AutoLaunch feature. If AutoLaunch still comes up with this message, please contact 3dsboy08 on Discord."), OBFUSCATE_STR("Synapse X"), MB_OK | MB_ICONWARNING);
		syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Failed to setup SysHook"));
	}

	prof->AddProfile(OBFUSCATE_STR("Main Init"));

	/* create init thread */
	CreateThread(NULL, NULL, SynapseMain, NULL, NULL, NULL);
    VM_TIGER_LONDON_END;

	return 1337;
}