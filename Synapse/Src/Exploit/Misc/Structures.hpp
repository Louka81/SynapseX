#pragma once

#include "./PointerObfuscation.hpp"

#include "../Execution/RbxLua.hpp"
#include "../../Utilities/Obfuscation/ObfuscatedNumber.hpp"

struct RLocVar
{
    TString* varname;
    int startpc;  /* first point where variable is active */
    int endpc;  /* first point where variable is dead */
    int unk; /* no idea why this even exists for */
};


/* Duplicate code due to the fact that i would like to move everything to its own overloaded class */
namespace syn::Structures
{
    class rProto
    {
    private:
        template <typename T>
        class rProtoEncryptedValue {
            rProto* Ptr;
            int Offset;

            syn::PointerObfuscation::Obf DoObfuscate;
            syn::PointerObfuscation::DeObf DoDeObfuscate;
 
        public:
            rProtoEncryptedValue(rProto& rp, const int off, 
                syn::PointerObfuscation::Obf obf = syn::PointerObfuscation::ObfuscateProto,
                syn::PointerObfuscation::DeObf deobf = syn::PointerObfuscation::DeObfuscateProto)
                : Ptr(&rp)
                , Offset(off)
                , DoObfuscate(obf)
                , DoDeObfuscate(deobf) {}

            __forceinline void operator=(const T& Val)
            {
                DoObfuscate(Ptr->Proto + Offset, (uintptr_t)Val);
            }

            __forceinline operator T()
            {
                return cast(T, DoDeObfuscate(Ptr->Proto + Offset));
            }

            __forceinline const T operator->() const
            {
                return operator const T();
            }
        };

        template <typename T> class rProtoValue {
        private:
            rProto* Ptr;
            int Offset;

        public:
            rProtoValue(rProto& rP, const int Off)
                : Ptr(&rP)
                , Offset(Off) { }

            __forceinline void operator=(const T& val)
            {
                *cast(T*, Ptr->Proto + Offset) = val;
            }

            __forceinline operator T()
            {
                return *cast(T*, Ptr->Proto + Offset);
            }

            __forceinline const T operator->() const
            {
                return operator const T();
            }

        };

    public:
        uintptr_t Proto;
        rProto(const uint32_t realRProto)
            : Proto(realRProto) {}

        rProtoEncryptedValue<RLocVar*> locvars = rProtoEncryptedValue<RLocVar*>(*this, PO_LOCVARS);
        rProtoEncryptedValue<TValue*> k = rProtoEncryptedValue<TValue*>(*this, PO_K);
        rProtoEncryptedValue<TString**> upvalues = rProtoEncryptedValue<TString**>(*this, PO_UPVALS);
        rProtoEncryptedValue<Instruction*> code = rProtoEncryptedValue<Instruction*>(*this, PO_CODE);
        rProtoEncryptedValue<TString*> source = rProtoEncryptedValue<TString*>(*this, PO_SOURCE);

        rProtoEncryptedValue<DWORD*> p = rProtoEncryptedValue<DWORD*>(*this, PO_P);
        rProtoEncryptedValue<int*> lineinfo = rProtoEncryptedValue<int*>(*this, PO_LINEINFO);

        rProtoValue<lu_byte> is_vararg = rProtoValue<lu_byte>(*this, PO_IS_VARARG);
        rProtoValue<lu_byte> numparams = rProtoValue<lu_byte>(*this, PO_NUMPARAMS);
        rProtoValue<lu_byte> maxstacksize = rProtoValue<lu_byte>(*this, PO_MAXSTACKSIZE);
        rProtoValue<lu_byte> nups = rProtoValue<lu_byte>(*this, PO_NUPS);

        rProtoValue<int> sizep = rProtoValue<int>(*this, PO_SIZEP);
        rProtoValue<int> sizelocvars = rProtoValue<int>(*this, PO_SIZELOCVARS);
        rProtoValue<int> sizelineinfo = rProtoValue<int>(*this, PO_SIZELINEINFO);
        rProtoValue<int> sizecode = rProtoValue<int>(*this, PO_SIZECODE);
        rProtoValue<int> sizeupvalues = rProtoValue<int>(*this, PO_SIZEUPVALUES);
        rProtoValue<int> sizek = rProtoValue<int>(*this, PO_SIZEK);

        rProtoValue<int> linedefined = rProtoValue<int>(*this, PO_LINEDEFINED);
        rProtoValue<int> lastlinedefined = rProtoValue<int>(*this, PO_LASTLINEDEFINED);

        rProtoValue<int> hash = rProtoValue<int>(*this, PO_HASH);
        rProtoEncryptedValue<int> flag = rProtoEncryptedValue<int>(*this, PO_FLAG, syn::PointerObfuscation::ObfuscateFlag, 
                                                                                   syn::PointerObfuscation::DeObfuscateFlag);

    };
}