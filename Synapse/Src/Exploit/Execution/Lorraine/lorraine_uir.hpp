
/*
 *	lorraine — LuaU compiler and analyser, written for Synapse X by Louka & Eternal
 *	uIR, intermediate representation (language) of Lorraine analysis
*/

#pragma once

#include "lorraine_device.hpp"
#include "lorraine_across.hpp"

namespace lorraine
{
	enum u_ir_op
	{
		/* STACK RESIZE AND GARBAGE COLLECTION */
		UIR_GROW,		/* GROW STACK			: stack.grow(op.indice[0]) */
		UIR_SHRINK,		/* SHRINK STACK			: stack.shrink(op.indice[0]) */
		UIR_DELETE,		/* DELETE VALUE			: delete stack[op.indice[0]) */
		UIR_DELETER,	/* DELETE RANGE			: delete stack[op.indice[1]] ... stack[op.indice[0]] */

		/* STACK DATA MANIPULATION */
		UIR_MOVE,		/* MOVE SINGLE			: stack[op.indice[1]] := stack[op.indice[0]] */
		UIR_MOVER,		/* MOVE RANGE			: stack[op.indice[1]] ... stack[op.indice[0]] := stack[op.indice[3]] ... stack[op.indice[2]] */
		UIR_XCHG,		/* EXCHANGE				: stack[op.indice[1]] <=> stack[op.indice[0]] */
		UIR_VARARG,		/* MOVE VARARG			: stack[op.indice[1]] ... stack[op.indice[0]] := vararg (count in op.indice[2]) */

		/* PUSHING CONSTANTS */
		UIR_ZCONSTR,	/* PUSH NULL RANGE		: stack[op.indice[1]] ... stack[op.indice[0]] := nullptr */
		UIR_ZCONST,		/* PUSH NULL CONST		: stack.push(nullptr) */
		UIR_ICONST,		/* PUSH INTEGER CONST	: stack.push(reinterpret_cast<long>(op.indice)) */
		UIR_FCONST,		/* PUSH FLOAT CONST		: stack.push(reinterpret_cast<float>(op.indice)) */
		UIR_BCONST,		/* PUSH BOOLEAN CONST	: stack.push(reinterpret_cast<bool>(op.indice[0])) */

		/* CREATING COLLECTIONS / COLLECTION MANIPULATION */
		UIR_COLLECTION,	/* PUSH COLLECTION		: stack.push({}) => is empty */
		UIR_COL_ARRAY,	/* PUSH ARRAY			: stack.push({ stack[op.indice[1]] ... stack[op.indice[0]] } => no keys (pure array) */
		UIR_COL_TABLE,	/* PUSH TABLE			: stack.push({ stack[op.indice[1]] ... stack[op.indice[0]] } => key/value pairs on stack (keys may be null) */
		UIR_COL_RANGE,	/* PUSH RANGE			: stack.push({ op.indice[1] .. op.indice[0] }) */
		UIR_UNPACK,		/* UNPACK COLLECTION	: stack[op.indice[1]] ... stack[op.indice[0]] := unpack(stack[op.indice[2])) */
		UIR_COUNT,		/* COUNT COLLECTION		: stack.push(#(stack[op.indice[0]])) */

		/* STRING CREATION / STRING MANIPULATION */
		UIR_STRINGZ,	/* PUSH EMPTY STRING	: stack.push(L"") */
		UIR_STRINGR,	/* PUSH STORED STRING	: stack.push(p.store[op.indice[0]]) */
		UIR_STR_CONCAT,	/* CONCATENATE STRING	: stack.push(stack[op.indice[1]] + stack[op.indice[0]]) */
		UIR_STR_SUBSTR,	/* SUB STRING			: stack.push(stack[op.indice[2]]->substr(op.indice[0], op.indice[1])) */
		UIR_STR_LENGTH,	/* STRING LENGTH		: stack.push(stack[op.indice[0]].length()) */

		/* MATHEMATICAL OPERATIONS (Constant Integers) */
		UIR_IADD8C,		/* ADD 8BIT INTEGER		: stack.push(stack[op.indice[0]] + op.indice[1]) */
		UIR_IADD16C,	/* ADD 16BIT INTEGER	: stack.push(stack[op.indice[0]] + _WORD(op.indice[2], op.indice[1])) */
		UIR_IADD24C,	/* ADD 24BIT INTEGER	: stack.push(stack[op.indice[0]] + _SWORD(op.indice[3], op.indice[2], op.indice[1])) */
		UIR_ISUB8C,		/* SUB 8BIT INTEGER		: stack.push(stack[op.indice[0]] - op.indice[1]) */
		UIR_ISUB16C,	/* SUB 16BIT INTEGER	: stack.push(stack[op.indice[0]] - _WORD(op.indice[2], op.indice[1])) */
		UIR_ISUB24C,	/* SUB 24BIT INTEGER	: stack.push(stack[op.indice[0]] - _SWORD(op.indice[3], op.indice[2], op.indice[1])) */
		UIR_IMUL8C,		/* MUL 8BIT INTEGER		: stack.push(stack[op.indice[0]] * op.indice[1]) */
		UIR_IMUL16C,	/* MUL 16BIT INTEGER	: stack.push(stack[op.indice[0]] * _WORD(op.indice[2], op.indice[1])) */
		UIR_IMUL24C,	/* MUL 24BIT INTEGER	: stack.push(stack[op.indice[0]] * _SWORD(op.indice[3], op.indice[2], op.indice[1])) */
		UIR_IDIV8C,		/* DIV 8BIT INTEGER		: stack.push(stack[op.indice[0]] / op.indice[1]) */
		UIR_IDIV16C,	/* DIV 16BIT INTEGER	: stack.push(stack[op.indice[0]] / _WORD(op.indice[2], op.indice[1])) */
		UIR_IDIV24C,	/* DIV 24BIT INTEGER	: stack.push(stack[op.indice[0]] / _SWORD(op.indice[3], op.indice[2], op.indice[1])) */
		UIR_IMOD8C,		/* MOD 8BIT INTEGER		: stack.push(stack[op.indice[0]] % op.indice[1]) */
		UIR_IMOD16C,	/* MOD 16BIT INTEGER	: stack.push(stack[op.indice[0]] % _WORD(op.indice[2], op.indice[1])) */
		UIR_IMOD24C,	/* MOD 24BIT INTEGER	: stack.push(stack[op.indice[0]] % _SWORD(op.indice[3], op.indice[2], op.indice[1])) */
		UIR_IPOW8C,		/* POW 8BIT INTEGER		: stack.push(stack[op.indice[0]] ^ op.indice[1]) */
		UIR_IPOW16C,	/* POW 16BIT INTEGER	: stack.push(stack[op.indice[0]] ^ _WORD(op.indice[2], op.indice[1])) */
		UIR_IPOW24C,	/* POW 24BIT INTEGER	: stack.push(stack[op.indice[0]] ^ _SWORD(op.indice[3], op.indice[2], op.indice[1])) */

		/* MATHEMATICAL OPERATIONS (Constant Half Floating Points) */
		UIR_HFADDC,		/* ADD 16BIT HFLOAT		: stack.push(stack[op.indice[0]] + _HFLOAT(op.indice[2], op.indice[1]) */
		UIR_HFSUBC,		/* SUB 16BIT HFLOAT		: stack.push(stack[op.indice[0]] - _HFLOAT(op.indice[2], op.indice[1]) */
		UIR_HFMULC,		/* MUL 16BIT HFLOAT		: stack.push(stack[op.indice[0]] * _HFLOAT(op.indice[2], op.indice[1]) */
		UIR_HFDIVC,		/* DIV 16BIT HFLOAT		: stack.push(stack[op.indice[0]] / _HFLOAT(op.indice[2], op.indice[1]) */
		UIR_HFMODC,		/* MOD 16BIT HFLOAT		: stack.push(stack[op.indice[0]] % _HFLOAT(op.indice[2], op.indice[1]) */
		UIR_HFPOWC,		/* POW 16BIT HFLOAT		: stack.push(stack[op.indice[0]] ^ _HFLOAT(op.indice[2], op.indice[1]) */

		/* MATHEMATICAL OPERATIONS (Non-constant Numbers/Arbitrary operations) */
		UIR_ARADD,		/* ADD FROM STACK		: stack.push(stack[op.indice[0]] + stack[op.indice[1]]) */
		UIR_ARSUB,		/* SUB FROM STACK		: stack.push(stack[op.indice[0]] - stack[op.indice[1]]) */
		UIR_ARMUL,		/* MUL FROM STACK		: stack.push(stack[op.indice[0]] * stack[op.indice[1]]) */
		UIR_ARDIV,		/* DIV FROM STACK		: stack.push(stack[op.indice[0]] / stack[op.indice[1]]) */
		UIR_ARMOD,		/* MOD FROM STACK		: stack.push(stack[op.indice[0]] % stack[op.indice[1]]) */
		UIR_ARPOW,		/* POW FROM STACK		: stack.push(stack[op.indice[0]] ^ stack[op.indice[1]]) */

		/* CONTROL FLOW OPERATIONS */
		UIR_FCALL,		/* FAST CALL			: stack[op.indice[0]]() => no arguments and return values discarded */
		UIR_TCALL,		/* TAIL CALL			: stack[op.indice[0]](...) => stack values reused */
		UIR_CALL,		/* CALL					: stack[op.indice[0]](...) */
		UIR_LEAVE,		/* LEAVE FUNCTION		: => returns from current function without any values (stack cleanup) */
		UIR_RETURN,		/* RETURN FROM FUNCTION	: => returns from current function, preserves returned values on stack */
	};

	struct u_ir_instruction
	{
		u_ir_op ir_op;
		unsigned char ir_indice[4];
	};

	struct u_ir_node
	{
		std::wstring node_name;		/* may be empty in certain cases */
		lorraine::uint node_id;		/* this id is solely useful in the context of a u_ir_proto  */
	};

	struct u_ir_proto
	{
		lorraine::uint unique_id{};				/* unique proto id */
		std::vector<u_ir_proto*> proto;			/* contains referenced protos */
		std::vector<u_ir_instruction> code;		/* contains the proto's code under uIR format */
		std::vector<std::wstring> store;		/* stored cached strings */
		lorraine::uint node_acc{};				/* node accumulator, keeps track of proto u_ir_nodes (order) */
		lorraine::uint stack_size{};				/* total_size = stack_size * sizeof(TValue) */
		lorraine::uint arg_size{};				/* total_size = arg_size * sizeof(TValue) */
		bool is_vararg{};							/* true if the proto accepts a variadic number of arguments */

		/* VECTORS BELOW MAY BE EMPTY. */
		std::vector<u_ir_node> stack_variables;	/* contains information related to stack variables */
		std::vector<u_ir_node> arg_variables;	/* contains information related to arguments */

		u_ir_proto& operator=(const u_ir_proto& other)
		{
			unique_id = other.unique_id;
			proto = other.proto;
			code = other.code;
			store = other.store;
			node_acc = other.node_acc;
			stack_size = other.stack_size;
			arg_size = other.arg_size;
			is_vararg = other.is_vararg;
			stack_variables = other.stack_variables;
			arg_variables = other.arg_variables;
		}

		bool operator==(const u_ir_proto& other) const
		{
			return unique_id == other.unique_id;
		}
	};

	class u_ir final
	{
	public:
		lorraine::device* ir_device;
		std::vector<u_ir_proto*> ir_proto;

		u_ir_proto* create_proto()
		{
			u_ir_proto* p = new u_ir_proto;
			p->unique_id = ir_proto.size();
			p->node_acc = 0;
			p->stack_size = 0;
			p->arg_size = 0;
			p->is_vararg = false;
			ir_proto.push_back(p);
			return p;
		}

		u_ir_proto* look_proto(lorraine::uint unique_id)
		{
			if (unique_id >= ir_proto.size())
				return nullptr;
			return ir_proto[unique_id];
		}
	};


	enum u_ir_trace_vartype
	{
		IR_TNULL,
		IR_TINTEGER,
		IR_TFLOAT,
		IR_TDOUBLE,
		IR_TNUMBER = IR_TDOUBLE,
		IR_TSTRING,
		IR_TCOLLECTION,
		IR_TBOOLEAN,
		IR_TFUNCTION,
		IR_TOTHER
	};

	/* i officially declare that C++ is cancer. i spent 30 minutes rewriting this bitch ass
	 * u_ir_trace_varunion (and almost converted it into a _class_ for convenience) because
	 * C++ couldn't figure out a way to properly copy unions. the solution, in the end, was
	 * to define operator= inside of u_ir_proto, which intellisense nor resharper EVER told
	 * me was the issue here, and creating a constructor that accepted a const ref to such
	 * a case (copying protos). im DONE BEYOND REALITY.
	 */
	union u_ir_trace_varunion
	{
		bool b;
		void* p;
		long n;
		float f;
		double d;
		std::wstring str;
		u_ir_proto fn;
		
		u_ir_trace_varunion operator=(const u_ir_trace_varunion& other)
		{
			*this = u_ir_trace_varunion(other);
			return *this;
		}

		u_ir_trace_varunion(const u_ir_trace_varunion& other)
		{
			fn = other.fn;
		}

		u_ir_trace_varunion()
		{
			b = false;
		}

		~u_ir_trace_varunion()
		{
			
		}
	};

	class u_ir_trace_vardt
	{
	public:
		u_ir_trace_varunion i;

		template <typename T = void*>
		T* get() const
		{
			return static_cast<T*>(i.p);
		}

		template <typename T = void*>
		void set(T* v)
		{
			i.p = static_cast<void*>(v);
		}
	};

	class u_ir_trace_var
	{
	public:
		u_ir_trace_vartype tt;
		u_ir_trace_vardt v;
		
        bool operator==(const u_ir_trace_var& var) const
        {
			switch (tt)
			{
			case IR_TNULL: return var.tt == tt;
			case IR_TINTEGER: return var.v.i.n == v.i.n;
			case IR_TFLOAT: return var.v.i.f == v.i.f;
			case IR_TDOUBLE: return var.v.i.d == v.i.d;
			case IR_TSTRING: return var.v.i.str == v.i.str;
			case IR_TCOLLECTION: return var.v.i.p == v.i.p;
			case IR_TBOOLEAN: return var.v.i.b == v.i.b;
			case IR_TFUNCTION: return var.v.i.fn == v.i.fn;
			case IR_TOTHER:
			default: return var.v.i.p == v.i.p;
			}
        }

		u_ir_trace_var(u_ir_trace_vartype type)
        {
			tt = type;	
        }

		u_ir_trace_var(const u_ir_trace_var& other)
		{
			*this = other;
		}

		u_ir_trace_var()
        {
			tt = IR_TNULL;
        }
	};

	class u_ir_trace_collection
	{
	public:
		std::vector<u_ir_trace_var> k;
		std::vector<u_ir_trace_var> kv;

		u_ir_trace_var map_index(const u_ir_trace_var& key) const
		{
			return kv[std::distance(k.begin(), std::find(k.begin(), k.end(), key))];
		}

		bool map_set(const u_ir_trace_var& key, const u_ir_trace_var& value)
		{
			auto v = std::find(k.begin(), k.end(), key);
			if (v != k.end()) /* already exists */
				kv[std::distance(k.begin(), v)] = value;
			else
			{
				k.push_back(key);
				kv.push_back(value);
			}
			return true;
		}

		u_ir_trace_var array_index(const lorraine::uint index) const
		{
			return kv[index];
		}

		bool array_insert(const u_ir_trace_var& value)
		{
			kv.push_back(value);
			return true;
		}
	};

	struct u_ir_flow
	{
		lorraine::uint flow_stack_top;
		lorraine::uint flow_stack_base;
		u_ir_proto* flow_proto;
	};

	class u_ir_tracer final
	{
	public:
		lorraine::u_ir* ir;
		std::vector<u_ir_flow> flow;
		std::vector<lorraine::uint> t_used;
		std::vector<lorraine::u_ir_trace_var> t_stack;
		lorraine::uint t_stack_top;
		lorraine::uint t_stack_base;

		bool save_flow(u_ir_proto* p)
		{
			u_ir_flow f{};
			f.flow_proto = p;
			f.flow_stack_top = t_stack_top;
			f.flow_stack_base = t_stack_base;
			flow.push_back(f);
			return true;
		}

		bool switch_flow(u_ir_flow f)
		{
			t_stack_top = f.flow_stack_top;
			t_stack_base = f.flow_stack_base;
		}

		u_ir_proto* f_first() const
		{
			return *ir->ir_proto.begin();
		}

		bool pass(u_ir_proto* p);
		bool trace();
	};
}