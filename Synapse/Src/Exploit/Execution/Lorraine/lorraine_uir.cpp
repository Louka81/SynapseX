
/*
 *	lorraine — LuaU compiler and analyser, written for Synapse X by Louka & Eternal
 *	uIR, intermediate representation (language) of Lorraine analysis
*/

/* HIIIIIIII! WE MIGHT SCRAP THIS!!!! DON'T TOUCH THIS ANY FURTHER!!! THANK YOU!!! */
/* I MAY HAVE A BETTER, FASTER IDEA VERY SOON! STAY IN TOUCH !!!! */

#include "lorraine_uir.hpp"
#include "half.hpp"

template <typename T = int>
__forceinline bool i_lorraine_op_addi(lorraine::u_ir_trace_var* left, T right)
{
	switch (left->tt)
	{
	case lorraine::IR_TINTEGER:
		left->v.i.n += right;
		break;
	case lorraine::IR_TFLOAT:
		left->v.i.f += right;
		break;
	case lorraine::IR_TDOUBLE:
		left->v.i.d += right;
		break;
	default: return false;
	}
	return true;
}

template <typename T = int>
__forceinline bool i_lorraine_op_subi(lorraine::u_ir_trace_var* left, T right)
{
	switch (left->tt)
	{
	case lorraine::IR_TINTEGER:
		left->v.i.n -= right;
		break;
	case lorraine::IR_TFLOAT:
		left->v.i.f -= right;
		break;
	case lorraine::IR_TDOUBLE:
		left->v.i.d -= right;
		break;
	default: return false;
	}
	return true;
}

template <typename T = int>
__forceinline bool i_lorraine_op_muli(lorraine::u_ir_trace_var* left, T right)
{
	switch (left->tt)
	{
	case lorraine::IR_TINTEGER:
		left->v.i.n *= right;
		break;
	case lorraine::IR_TFLOAT:
		left->v.i.f *= right;
		break;
	case lorraine::IR_TDOUBLE:
		left->v.i.d *= right;
		break;
	default: return false;
	}
	return true;
}

template <typename T = int>
__forceinline bool i_lorraine_op_divi(lorraine::u_ir_trace_var* left, T right)
{
	switch (left->tt)
	{
	case lorraine::IR_TINTEGER:
		left->v.i.n /= right;
		break;
	case lorraine::IR_TFLOAT:
		left->v.i.f /= right;
		break;
	case lorraine::IR_TDOUBLE:
		left->v.i.d /= right;
		break;
	default: return false;
	}
	return true;
}

template <typename T = int>
__forceinline bool i_lorraine_op_modi(lorraine::u_ir_trace_var* left, T right)
{
	switch (left->tt)
	{
	case lorraine::IR_TINTEGER:
		left->v.i.n %= right;
		break;
	case lorraine::IR_TFLOAT:
		left->v.i.f = fmodf(left->v.i.f, static_cast<float>(right));
		break;
	case lorraine::IR_TDOUBLE:
		left->v.i.d = fmod(left->v.i.d, static_cast<double>(right));
		break;
	default: return false;
	}
	return true;
}

template <typename T = int>
__forceinline bool i_lorraine_op_powi(lorraine::u_ir_trace_var* left, T right)
{
	switch (left->tt)
	{
	case lorraine::IR_TINTEGER:
	{
		int i = 1;
		for (int j = 1; j <= right; j++)
			i *= left->v.i.n;
		left->v.i.n = i;
		break;
	}
	case lorraine::IR_TFLOAT:
		left->v.i.f = powf(left->v.i.f, static_cast<float>(right));
		break;
	case lorraine::IR_TDOUBLE:
		left->v.i.d = pow(left->v.i.d, static_cast<double>(right));
		break;
	default: return false;
	}
	return true;
}

__forceinline bool i_lorraine_delete(lorraine::u_ir_trace_var* v)
{
	if (v->tt == lorraine::IR_TCOLLECTION)
		delete v->v.get<lorraine::u_ir_trace_collection>();
	if (v->tt == lorraine::IR_TSTRING)
		v->v.i.str.erase();
	*v = lorraine::u_ir_trace_var(lorraine::IR_TNULL);
	return true;
}

/* so you may be wondering, "Louka, why are you writing a vm?" 
 * this is not a virtual machine, its a tracer. it executes the instructions of
 * the IR in order to obtain information about its execution, which is then inserted
 * into a compilation context to generate optimized Luau bytecode. it doesn't:
 *	- call external functions
 *	- perform non-mathematical operations (non-mathematical table ops, strings, etc)
 *	- actually do anything that the lua vm does
 * it simply traces the instruction and control flow by executing it, and marks down
 * code that is used and code that isn't. since this is my first time writing a tracer,
 * you can expect several revisions and probably rewrites of the function below.
 */
bool lorraine::u_ir_tracer::pass(u_ir_proto* p)
{
	t_used[p->unique_id] = true;
	for (const u_ir_instruction& inst : p->code)
	{
		auto i = inst;
		switch (i.ir_op)
		{
			case UIR_GROW:
				for (auto r = 0; r <= i.ir_indice[0]; r++)
					t_stack.emplace_back(u_ir_trace_var(IR_TNULL));
				break;
			case UIR_SHRINK:
				t_stack.resize(t_stack.size() - i.ir_indice[0]);
				break;
			case UIR_DELETE:
				i_lorraine_delete(&t_stack[i.ir_indice[0]]);
				break;
			case UIR_DELETER:
			{
				int rangetop = i.ir_indice[1];
				int rangebot = i.ir_indice[0];
				for (auto r = rangetop; r >= rangebot; r--)
					i_lorraine_delete(&t_stack[r]);
				break;
			}
			case UIR_MOVE:
				t_stack[i.ir_indice[1]] = t_stack[i.ir_indice[0]];
				break;
			case UIR_MOVER:
			{
				int rangetop = i.ir_indice[3];
				int rangebot = i.ir_indice[2];
				for (auto r = rangetop; r >= rangebot; r--)
					t_stack[i.ir_indice[0] + (r - rangebot)] = t_stack[r];
				break;
			}
			case UIR_XCHG:
			{
				u_ir_trace_var a = t_stack[i.ir_indice[1]];
				t_stack[i.ir_indice[1]] = t_stack[i.ir_indice[0]];
				t_stack[i.ir_indice[0]] = a;
				break;
			}
			case UIR_VARARG:
			{
				/* varargs are NOT stored on the normal arg stack */
				unsigned char vararg_count = i.ir_indice[2];
				int rangetop = i.ir_indice[1];
				int rangebot = i.ir_indice[0];
				for (auto r = rangetop; r >= rangebot; r--)
				{
					u_ir_flow upflow = *(flow.end() - 1); /* get upflow args */
					t_stack[r] = t_stack[upflow.flow_stack_top - (r - rangebot)];
				}
				break;
			}
			case UIR_ZCONSTR:
			{
				int rangetop = i.ir_indice[1];
				int rangebot = i.ir_indice[0];
				for (auto r = rangetop; r >= rangebot; r--)
					t_stack[r] = u_ir_trace_var(IR_TNULL);
				break;
			}
			case UIR_ZCONST:
				t_stack.emplace_back(u_ir_trace_var(IR_TNULL));
				break;
			case UIR_ICONST:
			{
				u_ir_trace_var integer(IR_TINTEGER);
				integer.v.i.n = reinterpret_cast<long>(i.ir_indice);
				t_stack.push_back(integer);
				break;
			}
			case UIR_FCONST:
			{
				u_ir_trace_var fl(IR_TFLOAT);
				fl.v.i.f = *reinterpret_cast<float*>(&i.ir_indice);
				t_stack.push_back(fl);
				break;
			}
			case UIR_BCONST:
			{
				u_ir_trace_var b(IR_TBOOLEAN);
				b.v.i.f = i.ir_indice[0];
				t_stack.push_back(b);
				break;
			}
			case UIR_COLLECTION:
			{
				u_ir_trace_var b(IR_TCOLLECTION);
				b.v.set(new u_ir_trace_collection());
				t_stack.push_back(b);
				break;
			}
			case UIR_COL_ARRAY:
			{
				u_ir_trace_var b(IR_TCOLLECTION);
				u_ir_trace_collection* collection = new u_ir_trace_collection;
				int rangetop = i.ir_indice[1];
				int rangebot = i.ir_indice[0];
				for (auto r = rangetop; r >= rangebot; r--)
					collection->array_insert(t_stack[r - rangebot]);
				b.v.set(collection);
				t_stack.push_back(b);
				break;
			}
			case UIR_COL_TABLE:
			{
				u_ir_trace_var b(IR_TCOLLECTION);
				u_ir_trace_collection* collection = new u_ir_trace_collection;
				int rangetop = i.ir_indice[1];
				int rangebot = i.ir_indice[0];
				for (auto r = rangetop; r >= rangebot; r -= 2)
					collection->map_set(t_stack[r - rangebot], t_stack[r - rangebot + 1]);
				b.v.set(collection);
				t_stack.push_back(b);
				break;
			}
			case UIR_COL_RANGE:
			{
				u_ir_trace_var b(IR_TCOLLECTION);
				u_ir_trace_collection* collection = new u_ir_trace_collection;
				int rangetop = i.ir_indice[1];
				int rangebot = i.ir_indice[0];
				for (auto r = rangetop; r >= rangebot; r--)
				{
					u_ir_trace_var n(IR_TINTEGER);
					n.v.i.n = r - rangebot;
					collection->array_insert(n);
				}
				b.v.set(collection);
				t_stack.push_back(b);
				break;
			}
			case UIR_UNPACK:
			{
				u_ir_trace_collection* collection = t_stack[i.ir_indice[2]].v.get<u_ir_trace_collection>();
				int rangetop = i.ir_indice[1];
				int rangebot = i.ir_indice[0];
				for (auto r = rangetop; r >= rangebot; r--)
					t_stack[r] = collection->array_index(r - rangebot);
				break;
			}
			case UIR_COUNT:
			{
				u_ir_trace_collection* collection = t_stack[i.ir_indice[0]].v.get<u_ir_trace_collection>();
				u_ir_trace_var n(IR_TINTEGER);
				n.v.i.n = collection->kv.size();
				t_stack.push_back(n);
				break;
			}
			case UIR_STRINGZ:
			{
				u_ir_trace_var str(IR_TSTRING);
				str.v.i.str = std::wstring(); /* just in case */
				t_stack.push_back(str);
				break;
			}
			case UIR_STRINGR:
			{
				u_ir_trace_var str(IR_TSTRING);
				str.v.i.str = p->store[i.ir_indice[0]];
				t_stack.push_back(str);
				break;
			}
			case UIR_STR_CONCAT:
			{
				u_ir_trace_var a = t_stack[i.ir_indice[1]];
				u_ir_trace_var b = t_stack[i.ir_indice[0]];
				if (a.tt == IR_TSTRING)
				{
					u_ir_trace_var concat(IR_TSTRING);
					std::wstring concat_b;
					switch (b.tt)
					{
						case IR_TINTEGER: 
							concat_b = std::to_wstring(b.v.i.n);
							break;
						case IR_TFLOAT:
							concat_b = std::to_wstring(b.v.i.f);
							break;
						case IR_TDOUBLE:
							concat_b = std::to_wstring(b.v.i.d);
							break;
						case IR_TSTRING:
							concat_b = b.v.i.str;
						default: throw std::exception("attempt to concatenate non convertable value");
					}
					concat.v.i.str = a.v.i.str + concat_b;
					t_stack.push_back(concat);
				}
				else
				{
					/* no, this doesn't account for metamethods since its an optimization */
					throw std::exception("attempt to obtain sub string of invalid type");
				}
			}
			case UIR_STR_SUBSTR:
			{
				u_ir_trace_var str = t_stack[i.ir_indice[2]];
				if (str.tt == IR_TSTRING)
				{
					u_ir_trace_var substr(IR_TSTRING);
					substr.v.i.str = str.v.i.str.substr(i.ir_indice[0], i.ir_indice[1]);
					t_stack.push_back(substr);
				}
				else
				{
					/* ditto */
					throw std::exception("attempt to obtain sub string of invalid type");
				}
				break;
			}
			case UIR_STR_LENGTH:
			{
				u_ir_trace_var str = t_stack[i.ir_indice[0]];
				if (str.tt == IR_TSTRING)
				{
					u_ir_trace_var str_len(IR_TINTEGER);
					str_len.v.i.n = str.v.i.str.length();
					t_stack.push_back(str_len);
				}
				else
				{
					/* ditto */
					throw std::exception("attempt to retrieve string length of invalid type");
				}
				break;
			}
			case UIR_IADD8C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_addi<char>(&v, i.ir_indice[1]);
				t_stack.push_back(v);
				break;
			}
			case UIR_IADD16C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_addi<short>(&v, static_cast<unsigned short>(i.ir_indice[2]) << 8 | static_cast<unsigned char>(i.ir_indice[1]));
				t_stack.push_back(v);
				break;
			}
			case UIR_IADD24C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_addi<long>(&v, (i.ir_indice[2] << 16) | (i.ir_indice[1] << 8) | (i.ir_indice[0] << 0));
				t_stack.push_back(v);
				break;
			}
			case UIR_ISUB8C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_subi<char>(&v, i.ir_indice[1]);
				t_stack.push_back(v);
				break;
			}
			case UIR_ISUB16C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_subi<short>(&v, static_cast<unsigned short>(i.ir_indice[2]) << 8 | static_cast<unsigned char>(i.ir_indice[1]));
				t_stack.push_back(v);
				break;
			}
			case UIR_ISUB24C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_subi<long>(&v, i.ir_indice[3] << 16 | i.ir_indice[2] << 8 | i.ir_indice[1] << 0);
				t_stack.push_back(v);
				break;
			}
			case UIR_IMUL8C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_muli<char>(&v, i.ir_indice[1]);
				t_stack.push_back(v);
				break;
			}
			case UIR_IMUL16C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_muli<short>(&v, static_cast<unsigned short>(i.ir_indice[2]) << 8 | static_cast<unsigned char>(i.ir_indice[1]));
				t_stack.push_back(v);
				break;
			}
			case UIR_IMUL24C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_muli<long>(&v, i.ir_indice[3] << 16 | i.ir_indice[2] << 8 | i.ir_indice[1] << 0);
				t_stack.push_back(v);
				break;
			}
			case UIR_IDIV8C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_divi<char>(&v, i.ir_indice[1]);
				t_stack.push_back(v);
				break;
			}
			case UIR_IDIV16C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_divi<short>(&v, static_cast<unsigned short>(i.ir_indice[2]) << 8 | static_cast<unsigned char>(i.ir_indice[1]));
				t_stack.push_back(v);
				break;
			}
			case UIR_IDIV24C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_divi<long>(&v, i.ir_indice[3] << 16 | i.ir_indice[2] << 8 | i.ir_indice[1] << 0);
				t_stack.push_back(v);
				break;
			}
			case UIR_IMOD8C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_modi<char>(&v, i.ir_indice[1]);
				t_stack.push_back(v);
				break;
			}
			case UIR_IMOD16C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_modi<short>(&v, static_cast<unsigned short>(i.ir_indice[2]) << 8 | static_cast<unsigned char>(i.ir_indice[1]));
				t_stack.push_back(v);
				break;
			}
			case UIR_IMOD24C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_modi<long>(&v, i.ir_indice[3] << 16 | i.ir_indice[2] << 8 | i.ir_indice[1] << 0);
				t_stack.push_back(v);
				break;
			}
			case UIR_IPOW8C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_powi<char>(&v, i.ir_indice[1]);
				t_stack.push_back(v);
				break;
			}
			case UIR_IPOW16C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_powi<short>(&v, static_cast<unsigned short>(i.ir_indice[2]) << 8 | static_cast<unsigned char>(i.ir_indice[1]));
				t_stack.push_back(v);
				break;
			}
			case UIR_IPOW24C:
			{
				u_ir_trace_var v = t_stack[i.ir_indice[0]];
				i_lorraine_op_powi<long>(&v, i.ir_indice[3] << 16 | i.ir_indice[2] << 8 | i.ir_indice[1] << 0);
				t_stack.push_back(v);
				break;
			}
			case UIR_HFADDC: break;
			case UIR_HFSUBC: break;
			case UIR_HFMULC: break;
			case UIR_HFDIVC: break;
			case UIR_HFMODC: break;
			case UIR_HFPOWC: break;
			case UIR_ARADD: break;
			case UIR_ARSUB: break;
			case UIR_ARMUL: break;
			case UIR_ARDIV: break;
			case UIR_ARMOD: break;
			case UIR_ARPOW: break;
			case UIR_FCALL: break;
			case UIR_TCALL: break;
			case UIR_CALL: break;
			case UIR_LEAVE: break;
			case UIR_RETURN: break;
			default: ;
		}
	}
}

bool lorraine::u_ir_tracer::trace()
{
	return pass(this->f_first());
}
