
/*
 *	lorraine — LuaU compiler and analyser, written for Synapse X by Louka & Eternal
 *	
 *	This is the Luau lexer that I (Louka) mainly wrote, along with Eternal to help out
 *	sometimes. Luau is lego's new suite of Lua-related execution facilities, most of which
 *	redefined how Lua actually operates in terms of virtual machinery. Because of this, we
 *	had to completely rethink how we do our execution. Thankfully, I did previously experiment
 *	with compilation, grammar lexers, instruction generation so this is not completely new.
 *	However, this is the first time I target an instruction set with such complexity (but
 *	it's still pretty simple). 
 *	
 *	The compiler can be found in lorraine_code.hpp/lorrane_code.cpp.
 *	
 *	Features:
 *		- Soft-coded language information (just change a few vectors and the lexer will parse the language differently)
 *		- Compiles to uIR (an intermediate language format written for Lorraine, see lorraine_uir.hpp and lorraine_uir.cpp)
 *			- Can compile to Luau instructions or Lua instructions
 *			- uIR bytecode allows for dumping the IR to a portable format (security? obfuscation? who knows?)
 *		- LuaJIT-like unicode support (UTF-8), including:
 *			- Unicode variable names
 *			- Unicode function names
 *			- Unicode strings
 *			- Unicode comments
 *		- Written in C++ using standard libraries
 *		- Portable (uses only standard libraries so no platform-specific code :D)
 */

/*
 * TODO:
 * [x] Unicode gearbox (character manipulation toolbox for unicode formatting)
 * [x] String->number interpreters (convert number strings into number data)
 * [x] Whitespace recognition (not easy on UTF due to the sole number of whitespace chars)
 * [x] Keyword/operator interpreter (look in lorraine_llex.cpp)
 * [x] Needle-pass algorithm for interpreting scripts
 * [ ] Commment interpreter (lol yes this is still undone)
 * [ ] String interpreter (convert "abc" to a string object)
 * [ ] Optimization (make this use less memory/work faster)
 * [ ] Testing (see if this shit actually works as expected)
 */

#pragma once

#include <utility>
#include "lorraine_device.hpp"

namespace lorraine
{
	using lorraine_string_collection = std::vector<std::wstring>;

	/* so, why use the keyword "final" at the end of classes? 
	 * unless you want to inherit from the classes below, we
	 * can remove constructs such as virtual tables and some
	 * RTTI information if we specify that the class is
	 * 'final' (no inheritance). of course, it won't delete
	 * ALL class metadata embed into synx but it will guarantee
	 * that a virtual table won't be generated, whose info could
	 * leak into classinformer and some other binary analyzers.
	 * 
	 * of course, this implies that MSVC follows core c++ guidelines,
	 * which it rarely does. but let's hope it does this one time :)
	 */

	class lorraine_token final
	{
	public:
		lorraine::uint token_id;
		std::wstring token_string;

		bool is_same(const std::wstring& comparator) const
		{
			return token_string == comparator;
		}

		bool operator==(const lorraine_token& other) const
		{
			return token_id == other.token_id;
		}

		bool operator==(const std::wstring& other) const
		{
			return is_same(other);
		}

		lorraine_token(lorraine::uint t_id, const std::wstring& string)
		{
			token_id = t_id;
			token_string = string;
		}

        lorraine_token()
            : token_id(NULL) {}
	};

	enum lorraine_lexer_singlet_type
	{
		llex_none,		/* none */
		llex_name,		/* variable name */
		llex_number,	/* number (duh) */
		llex_keyword,	/* keyword (non-operator) */
		llex_operator,	/* operator (non-keyword) */
		llex_string,	/* string */
	};

	class lorraine_lexer_singlet final
	{
	public:
		lorraine_lexer_singlet_type tt;
		std::variant<lorraine_token, std::wstring, double> v;

		lorraine_token get_token()
		{
			return std::get<lorraine_token>(v);
		}

		std::wstring get_string()
		{
			return std::get<std::wstring>(v);
		}

		double get_number()
		{
			return std::get<double>(v);
		}

		lorraine_lexer_singlet()
		{
			tt = llex_none;
			v = std::variant<lorraine_token, std::wstring, double>();
		};
	};

	class lorraine_lexer_gearbox final
	{
	public:
		std::vector<lorraine_token> lang_keywords;
		std::vector<lorraine_token> lang_operators;
		std::vector<std::wstring> lang_keywords_wstring;
		std::vector<std::wstring> lang_operators_wstring;
		std::map<std::wstring, lorraine::uint> lang_usermap;

		lorraine::uint add_keyword(std::wstring tk_string)
		{
			lorraine_token tk;
			tk.token_id = lang_keywords.size();
			tk.token_string = std::move(tk_string);
			lang_keywords_wstring.push_back(tk.token_string);
			lang_keywords.push_back(tk);
			return tk.token_id;
		}

		lorraine::uint add_operator(std::wstring tk_string)
		{
			lorraine_token tk;
			tk.token_id = lang_operators.size();
			tk.token_string = std::move(tk_string);
			lang_operators_wstring.push_back(tk.token_string);
			lang_operators.push_back(tk);
			return tk.token_id;
		}

		bool is_keyword(const std::wstring& in) const
		{
			for (auto& tk : lang_keywords)
				if (tk == in)
					return true;
			return false;
		}

		bool is_operator(const std::wstring& in) const
		{
			for (auto& tk : lang_operators)
				if (tk == in)
					return true;
			return false;
		}

		static bool is_numerical(wchar_t in)
		{
			const std::pair<wchar_t, wchar_t> number_range = { 0x30, 0x39 };	/* U+0030 - U+0039 */
			return in >= number_range.first && in <= number_range.second;
		}

		static bool is_alphanumerical(wchar_t in)
		{
			const std::pair<wchar_t, wchar_t> number_range =		{ 0x30, 0x39 };	/* U+0030 - U+0039 */
			const std::pair<wchar_t, wchar_t> alphahigh_range =		{ 0x41, 0x5A };	/* U+0041 - U+005A */
			const std::pair<wchar_t, wchar_t> alphalow_range =		{ 0x61, 0x7A };	/* U+0061 - U+007A */
			return
				(in >= number_range.first && in <= number_range.second) ||
				(in >= alphahigh_range.first && in <= alphahigh_range.second) ||
				(in >= alphalow_range.first && in <= alphalow_range.second);
		}

		static bool is_hexadecimal(wchar_t in)
		{
			const std::pair<wchar_t, wchar_t> number_range = { 0x30, 0x39 };	/* U+0030 - U+0039 */
			const std::pair<wchar_t, wchar_t> alphahigh_range = { 0x41, 0x46 };	/* U+0041 - U+0046 */
			const std::pair<wchar_t, wchar_t> alphalow_range = { 0x61, 0x66 };	/* U+0061 - U+0066 */
			return
				(in >= number_range.first && in <= number_range.second) ||
				(in >= alphahigh_range.first && in <= alphahigh_range.second) ||
				(in >= alphalow_range.first && in <= alphalow_range.second);
		}

		static bool is_whitespace(wchar_t in)
		{
			const std::vector<wchar_t> whitespace =
			{
				/* typographical whitespace */
				0x0009, 0x000A, 0x000B, 0x000C,
				0x000D, 0x0020, 0x0085, 0x00A0,
				0x1680, 0x2000, 0x2001, 0x2002,
				0x2003, 0x2004, 0x2005, 0x2006,
				0x2007, 0x2008, 0x2009, 0x200A,
				0x2028, 0x2029, 0x202F, 0x205F,
				0x3000,

				/* technical whitespace */
				0x180E, 0x200B, 0x200C, 0x200D,
				0x2060, 0xFEFF
			};

			return std::find(whitespace.begin(), whitespace.end(), in) != whitespace.end();
		}

		static bool is_hexadecimal_number(const std::wstring& trynum)
		{
			auto hex_prefix = trynum.substr(1, 2);
			auto hex_suffix = trynum.substr(hex_prefix == L"0x" || hex_prefix == L"0X" ? 2 : 0, trynum.length());
			for (std::size_t i = 0; i <= trynum.length(); i++)
				if (!is_hexadecimal(hex_suffix.at(i)))
					return false;
			return true;
		}

		static bool is_number(const std::wstring& trynum)
		{
			for (std::size_t i = 0; i <= trynum.length(); i++)
				if (!is_numerical(trynum.at(i)))
					return false;
			return true;
		}

		/* if you have a better and faster way to do this, please implement */
		static double hexadecimal_numstring_to_double(const std::wstring& str)
		{
			std::wstringstream wstr;
			double nn;
			wstr << std::hex << str;
			wstr >> nn;
			return nn;
		}

		/* ditto */
		static double numstring_to_double(const std::wstring& str)
		{
			std::wstringstream wstr;
			double nn;
			wstr << str;
			wstr >> nn;
			return nn;
		}

		static const std::vector<std::wstring>& get_whitespace_vector()
		{
			static const std::vector<std::wstring>& whitespace_vector = 
			{	L"\x0009", L"\x000A", L"\x000B", L"\x000C", 
				L"\x000D", L"\x0020", L"\x0085", L"\x00A0", 
				L"\x1680", L"\x2000", L"\x2001", L"\x2002", 
				L"\x2003", L"\x2004", L"\x2005", L"\x2006", 
				L"\x2007", L"\x2008", L"\x2009", L"\x200A", 
				L"\x2028", L"\x2029", L"\x202F", L"\x205F", 
				L"\x3000", L"\x180E", L"\x200B", L"\x200C", 
				L"\x200D", L"\x2060", L"\xFEFF" };
			return whitespace_vector;
		}

		static std::vector<std::wstring> combine_wstring_vector(const std::vector<std::wstring>& a, const std::vector<std::wstring>& b)
		{
			std::vector<std::wstring> combine_vector;
			combine_vector.reserve(a.size() + b.size());
			combine_vector.insert(combine_vector.end(), a.begin(), a.end());
			combine_vector.insert(combine_vector.end(), b.begin(), b.end());
			return combine_vector;
		}

		static lorraine_lexer_gearbox* initialize_default_gearbox();
	};

	class lorraine_lexer final
	{
	private:
		std::vector<std::wstring> _i_ws_op_vector;
		const std::vector<std::wstring>& get_i_ws_op_vector()
		{
			if (_i_ws_op_vector.empty())
			{
				/* initialize and merge */
				_i_ws_op_vector = lorraine_lexer_gearbox::combine_wstring_vector(
					lorraine_lexer_gearbox::get_whitespace_vector(), gearbox.lang_operators_wstring);
			}
			return _i_ws_op_vector;
		}
	public:
		std::map<lorraine::qint, std::pair<lorraine::qint, lorraine::qint>> line_map;
		std::vector<lorraine_lexer_singlet> singlets;
		lorraine_lexer_gearbox gearbox;
		std::wstring_view lexer_input;
		lorraine::qint lexer_needle;

		using size_type = std::wstring::size_type;

		lorraine::qint get_line_for_char_position(lorraine::qint char_position)
		{
			for (auto& [lineno, range_pair] : line_map)
			{
				if (char_position >= range_pair.first && char_position <= range_pair.second)
					return lineno;
			}
			return 0;
		}

		wchar_t read_needle() const
		{
			return lexer_input.at(static_cast<size_type>(lexer_needle));
		}

		lorraine::qint position_of_next(wchar_t tk) const
		{
			auto needle = static_cast<size_type>(lexer_needle);
			auto view_size = lexer_input.size();
			while (needle <= view_size && lexer_input[needle] != tk)
				needle++;
			return needle >= view_size ? 0 : needle;
		}

		lorraine::qint position_of_next(const std::wstring& tk) const
		{
			auto needle = static_cast<size_type>(lexer_needle);
			auto view_size = lexer_input.size();
			while (needle <= view_size && lexer_input.substr(needle, tk.length()) != tk)
				needle++;
			return needle >= view_size ? 0 : needle;
		}

		lorraine::qint position_of_next(const std::vector<std::wstring>& vector) const
		{
			auto needle = static_cast<size_type>(lexer_needle);
			auto view_size = lexer_input.size();
			while (needle <= view_size)
			{
				for (auto& ref : vector)
					if (lexer_input.substr(needle, ref.length()) == ref)
						return needle;
				needle++;
			}
			return 0;
		}

		lorraine::qint position_of_next_char_in_range(const std::pair<wchar_t, wchar_t>& range) const
		{
			auto needle = static_cast<size_type>(lexer_needle);
			auto view_size = lexer_input.size();
			while (needle <= view_size && (lexer_input[needle] >= range.first && lexer_input[needle] <= range.first))
				needle++;
			return needle >= view_size ? 0 : needle;
		}

		lorraine::qint position_of_next_char_not_in_range(const std::pair<wchar_t, wchar_t>& range) const
		{
			auto needle = static_cast<size_type>(lexer_needle);
			auto view_size = lexer_input.size();
			while (needle <= view_size && (lexer_input[needle] < range.first || lexer_input[needle] > range.first))
				needle++;
			return needle >= view_size ? 0 : needle;
		}

		lorraine::qint position_of_next_char_above(const wchar_t above_char) const
		{
			auto needle = static_cast<size_type>(lexer_needle);
			auto view_size = lexer_input.size();
			while (needle <= view_size && lexer_input[needle] > above_char)
				needle++;
			return needle >= view_size ? 0 : needle;
		}

		lorraine::qint position_of_next_below(const wchar_t below_char) const
		{
			auto needle = static_cast<size_type>(lexer_needle);
			auto view_size = lexer_input.size();
			while (needle <= view_size && lexer_input[needle] < below_char)
				needle++;
			return needle >= view_size ? 0 : needle;
		}

		lorraine_lexer_singlet read_word()
		{
			lorraine_lexer_singlet singlet;
			auto init_position = static_cast<size_type>(lexer_needle);
			auto next_position = static_cast<size_type>(position_of_next(get_i_ws_op_vector()));
			if (next_position != 0)
			{
				std::wstring_view name_string = lexer_input.substr(init_position, next_position - 1);
				std::wstring rname_string(name_string.begin(), name_string.end());
				singlet.tt = llex_name;
				singlet.v = rname_string;
				lexer_needle = next_position;
				return singlet;
			}

			throw std::exception("not word"); /* to-do: more descriptive error messages */
		}

		lorraine_lexer_singlet read_number()
		{
			lorraine_lexer_singlet singlet;
			auto init_position = static_cast<size_type>(lexer_needle);
			auto next_position = static_cast<size_type>(position_of_next(get_i_ws_op_vector()));
			if (next_position != 0)
			{
				std::wstring_view number_string = lexer_input.substr(init_position, next_position - 1);
				std::wstring rnumber_string(number_string.begin(), number_string.end());
				if (lorraine_lexer_gearbox::is_hexadecimal_number(rnumber_string))
				{
					singlet.tt = llex_number;
					singlet.v = lorraine_lexer_gearbox::hexadecimal_numstring_to_double(rnumber_string);
					lexer_needle = next_position;
					return singlet;
				}
				if (lorraine_lexer_gearbox::is_number(rnumber_string))
				{
					singlet.tt = llex_number;
					singlet.v = lorraine_lexer_gearbox::numstring_to_double(rnumber_string);
					lexer_needle = next_position;
					return singlet;
				}
			}

			throw std::exception("not number");
		}

		lorraine_lexer_singlet read_keyword()
		{
			lorraine_lexer_singlet singlet;
			auto init_position = static_cast<size_type>(lexer_needle);
			auto next_position = static_cast<size_type>(position_of_next(get_i_ws_op_vector()));
			if (next_position != 0)
			{
				std::wstring_view keyword_string = lexer_input.substr(init_position, next_position - 1);
				std::wstring rkeyword_string(keyword_string.begin(), keyword_string.end());
				for (auto& tk_ref : gearbox.lang_keywords)
				{
					if (tk_ref == rkeyword_string)
					{
						singlet.tt = llex_keyword;
						singlet.v = tk_ref;
						lexer_needle = next_position;
						return singlet;
					}
				}
			}

			throw std::exception("not keyword");
		}

		lorraine_lexer_singlet read_operator()
		{
			lorraine_lexer_singlet singlet;
			auto init_position = static_cast<size_type>(lexer_needle);
			auto next_position = static_cast<size_type>(position_of_next_char_not_in_range(std::make_pair(0x21, 0x30)));
			if (next_position != 0)
			{
				std::wstring_view operator_string = lexer_input.substr(init_position, next_position - 1);
				std::wstring roperator_string(operator_string.begin(), operator_string.end());
				for (auto& tk_ref : gearbox.lang_operators)
				{
					if (tk_ref == roperator_string)
					{
						singlet.tt = llex_keyword;
						singlet.v = tk_ref;
						lexer_needle = next_position;
						return singlet;
					}
				}
			}

			throw std::exception("not operator");
		}

		bool skip_whitespace_if_exists()
		{
			if (!lorraine_lexer_gearbox::is_whitespace(read_needle()))
				return false;
			while (lorraine_lexer_gearbox::is_whitespace(read_needle()))
				lexer_needle++;
			return true;
		}

		lorraine_lexer_singlet_type get_type() const
		{
			/* to-do: implement */
			return llex_keyword;
		}

		bool pass()
		{
			const auto i_size = lexer_input.size();
			while (lexer_needle < i_size)
			{
				skip_whitespace_if_exists();
				switch (get_type())
				{
					case llex_none:
						throw std::exception("attempt to pass llex_none");
					case llex_name:
						singlets.push_back(read_word()); break;
					case llex_number:
						singlets.push_back(read_number()); break;
					case llex_keyword:
						singlets.push_back(read_keyword()); break;
					case llex_operator:
						singlets.push_back(read_operator()); break;
					case llex_string:
						throw std::exception("unimplemented");
				}
			}
			return true;
		}
	};
}