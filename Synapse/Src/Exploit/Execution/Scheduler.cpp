#include "./Scheduler.hpp"

#include "./RbxApi.hpp"
#include "./Virtual Machine/HSVM.hpp"

#include "../Security/AntiTamper.hpp"
#include "../Security/AntiDebug.hpp"
#include "../Misc/PointerObfuscation.hpp"
#include "../../Utilities/MemSpoofer.hpp"
#include "../Security/MemCheck.hpp"
#include "../../Utilities/FakeMemoryHasher.hpp"
#include "../Security/AntiProxy.hpp"

bool i_scheduler_onteleport(syn::Scheduler* scheduler)
{
	using namespace syn;
	bool was_zero = syn::LastDataModel == 0;
	syn::LastDataModel = syn::DataModel;
	if (was_zero)
		return false;
	syn::Profiler::GetSingleton()->AddProfile("Teleport start");
	syn::Teleported = true;

#pragma region Teleport D3D Clear
	auto D3D = syn::D3D::GetSingleton();
	std::vector<D3DObject*> RenderClearList{};
	for (auto Obj : D3D->RenderChain)
		RenderClearList.push_back(Obj);
	for (auto Obj : RenderClearList)
		D3D->RemoveFromRenderList(Obj);
	for (auto Obj : RenderClearList)
	{
		switch (Obj->Header.Type)
		{
			case D3_LINE:
				delete reinterpret_cast<D3DLine*>(Obj->Ptr);
				break;
			case D3_TEXT:
			{
				const auto Text = reinterpret_cast<D3DText*>(Obj->Ptr);
				delete Text->Text;
				delete Text;
				break;
			}
			case D3_CIRCLE:
				delete reinterpret_cast<D3DCircle*>(Obj->Ptr);
				break;
			case D3_SQUARE:
				delete reinterpret_cast<D3DSquare*>(Obj->Ptr);
				break;
		}

		delete Obj;
	}
#pragma endregion

	syn::PipeHandle = CreateFile(TEXT(OBFUSCATE_STR("\\\\.\\pipe\\SynapseInteract")),
		GENERIC_READ | GENERIC_WRITE, 0,
		NULL, OPEN_EXISTING, 0, NULL);
	syn::RbxApi::reattach_write_pipe(syn::PipeHandle, OBFUSCATE_STR("SYN_SCANNING"));
	scheduler->Initialized = false;
	syn::Profiler::GetSingleton()->AddProfile("Teleport phase 2");
	return true;
}

bool i_scheduler_initialize(syn::Scheduler* sh)
{
	using namespace syn;
	VM_TIGER_WHITE_START;

	DWORD scriptContext = syn::Instance(syn::DataModel).GetChildFromClassName(OBFUSCATE_STR("ScriptContext"));
	if (!scriptContext || *(DWORD*)(scriptContext + 872) == 1) //check core key for initialization (if this is set, cKey is set as well)
		return false;

	syn::Profiler::GetSingleton()->AddProfile("Scheduler init start");

	DWORD scriptState = syn::PointerObfuscation::DeObfuscateScriptState(scriptContext + OBFUSCATED_NUM(164));
	DWORD globalState = syn::PointerObfuscation::DeObfuscateGlobalState(scriptState + OBFUSCATED_NUM(L_GS));

	DWORD cKey = syn::PointerObfuscation::DeObfuscateCKey(globalState + OBFUSCATED_NUM(G_CKEY));
	
	VM_TIGER_WHITE_END;

	const auto prof = syn::Profiler::GetSingleton();
	prof->AddProfile(OBFUSCATE_STR("Set DKey"));

	syn::LuaTranslator::GetSingleton()->SetDecodeKey(cKey);

	prof->AddProfile(OBFUSCATE_STR("GlobalState setup"));
	syn::RbxLua::GlobalState(scriptState);

	prof->AddProfile(OBFUSCATE_STR("Set Static Variables"));
	syn::Static::Initialize();

	SecureLuaFlag = false;
	ScriptRunCounter = 0;

	VM_TIGER_WHITE_START;

	prof->AddProfile(OBFUSCATE_STR("Checking LuaU"));
	if (*(BYTE*)(globalState + G_LUAU))
	{
		IsLuaU = true;

#ifndef EnableHSVM
#ifndef EnableHSVMOnlyLuaU
#ifndef EnableLuaUTranslator
		MessageBox(NULL, "Synapse X has detected that Lua U is enabled on this game, which is currently unsupported by release Synapse X.\n\nIf you wish to use Synapse X on this game, please enable Beta Release to test our new Lua U execution system.", "Synapse X", MB_OK);
		TerminateProcess(GetCurrentProcess(), 0);
#endif
#endif
#endif
	}
	else
	{
		IsLuaU = false;
	}

#if defined(EnableHSVMOnlyLuaU) && !defined(EnableMemCheckBypass)
	static auto MCheckInit = false;
	static auto ErrSpoofInit = false;

	syn::RbxLua RTL(scriptState);
	syn::RbxLua LSTState = RTL.NewThread(false);
	RTL.SetField(LUA_REGISTRYINDEX, RandomString(16).c_str());

	LSTState.SetupThread();
	LSTState.SetIdentity(6);

	LSTState.GetGlobal(OBFUSCATE_STR("game"));
	LSTState.GetField(-1, OBFUSCATE_STR("GameId"));

	const auto GameId = LSTState.ToNumber(-1);

	LSTState.Pop(2);

	const auto RequiresErrorSpoofing = GameId == OBFUSCATED_NUM(1087859240) || GameId == OBFUSCATED_NUM(833423526) || GameId == OBFUSCATED_NUM(447789585);

	if (!MCheckInit && (IsLuaU || RequiresErrorSpoofing))
	{
		auto MCheck = new syn::MemCheck();

		MCheck->AddSegment((char*)OBFUSCATE_STR(".text"));
		MCheck->AddSegment((char*)OBFUSCATE_STR(".rdata"));
		MCheck->AddSegment((char*)OBFUSCATE_STR(".vmp0"));
		MCheck->AddSegment((char*)OBFUSCATE_STR(".vmp1"));

		syn::MemCheck::HookMemCheck(syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::MemCheck::Hasher)), syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::MemCheck::HasherJmpBack)));

		DbgConsoleExec(syn::Console::GetSingleton()->Warning("MemCheck bypass enabled."));

		MCheckInit = true;
	}

	if (!ErrSpoofInit && RequiresErrorSpoofing)
	{
		OriginalErrHook = syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::Signal::FireError)) + 5;
		OriginalMsgOutHook = syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::Signal::FireSingle)) + 5;

		syn::MemCheck::RawHook(syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::Signal::FireError)), (DWORD)ErrHook);
		syn::MemCheck::RawHook(syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::Signal::FireSingle)), (DWORD)MsgOutHook);

		ErrSpoofInit = true;
	}

#endif
#ifdef EnableMemCheckBypass
	static auto MCheckInit = false;

	if (!MCheckInit)
	{
		auto MCheck = new syn::MemCheck();

		MCheck->AddSegment((char*)OBFUSCATE_STR(".text"));
		MCheck->AddSegment((char*)OBFUSCATE_STR(".rdata"));
		MCheck->AddSegment((char*)OBFUSCATE_STR(".vmp0"));
		MCheck->AddSegment((char*)OBFUSCATE_STR(".vmp1"));

		syn::MemCheck::HookMemCheck(syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::MemCheck::Hasher)), syn::RobloxBase(OBFUSCATED_NUM(syn::Offsets::MemCheck::HasherJmpBack)));

		DbgConsoleExec(syn::Console::GetSingleton()->Warning("MemCheck bypass enabled."));

		MCheckInit = true;
	}
#endif

#ifdef EnableHSVMOnlyLuaU
	if (IsLuaU)
	{
		prof->AddProfile(OBFUSCATE_STR("Attaching HSVM"));
		syn::HSVM::Attach();
	}
#endif
#ifdef EnableHSVM
	prof->AddProfile(OBFUSCATE_STR("Attaching HSVM"));
	syn::HSVM::Attach();
#endif

	VM_TIGER_WHITE_END;

	syn::RbxLua RL(scriptState);
	syn::RbxLua LSState = RL.NewThread(false);
	RL.SetField(LUA_REGISTRYINDEX, RandomString(16).c_str());

	LSState.SetupThread();
	LSState.SetIdentity(6);

	sh->MainThread = LSState;
	sh->Push([](DWORD nRL)
	{
		syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Syn push libs"));
		syn::RbxApi::PushLibraries(nRL, syn::RbxLua::GlobalState());
	});

	syn::InitScript->Process();
#ifndef EnableLuaUTranslator
	sh->Push(syn::InitScript->Get());
#endif
	syn::InitScript->Process();

	const auto AutoExec = std::filesystem::path(syn::WorkspaceDirectory).parent_path().wstring() + L"\\autoexec";

	if (std::filesystem::is_directory(AutoExec))
	{
		for (const auto& File : std::filesystem::directory_iterator(AutoExec))
		{
			std::ifstream Stream(File.path(), std::ios_base::binary);
			std::string Final((std::istreambuf_iterator<char>(Stream)),
				std::istreambuf_iterator<char>());

			VM_TIGER_WHITE_START

			if (!SecureLuaFlag)
			{
				ScriptRunCounter++;

				sh->Push(Final);
			}

			VM_TIGER_WHITE_END
		}
	}

	if (syn::Teleported)
		syn::RbxApi::reattach_write_pipe(syn::PipeHandle, OBFUSCATE_STR("SYN_REATTACH_READY"));
	else
		syn::RbxApi::reattach_write_pipe(syn::PipeHandle, OBFUSCATE_STR("SYN_READY"));

	CloseHandle(syn::PipeHandle);

	syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Main thread ready"));
	sh->Initialized = true;
	return true;
}

void syn::Scheduler::StepSchedule()
{
	if (!syn::DataModel)
		syn::RbxApi::SetDataModel(syn::RbxApi::GetDataModel());
	if (!syn::DataModel)
		return;
	
	auto sh = GetSingleton();
	if (syn::DataModel != syn::LastDataModel)
		if (!i_scheduler_onteleport(sh))
			return;
	if (!sh->Initialized)
		if (!i_scheduler_initialize(sh))
			return;

	sh->Step++;
	if (sh->Step % 300 == 0) 
	{
		if (syn::AntiDebug::Check())
			CrashRoblox(true, OBFUSCATE_STR("AntiDump - #5"));
		if (syn::AntiDump::Check())
			CrashRoblox(true, OBFUSCATE_STR("AntiDebug - #5.5"));
	}

	if (sh->Empty())
		return;

	while (!sh->Empty())
	{
		Task ToRun = sh->Pop();

		syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Scheduler run task"));

		if (ToRun.isC)
			ToRun.FunctionValue(sh->MainThread);
		else
		{
			if (syn::AntiTamper::CheckFull() != syn::AntiTamper::OK)
				CrashRoblox(true, OBFUSCATE_STR("AntiTamper - #5.5"));

			try
			{
				const auto MSpoofCallback = syn::MemSpoofer::Spoof();

				//SecureLua agent
				if (ToRun.ScriptValue.size() > 9 && ToRun.ScriptValue.rfind(OBFUSCATE_STR("\\SX_SLUA_")) == 0)
				{
					VM_DOLPHIN_BLACK_START;

					//TODO: finalize this
					if (ScriptRunCounter > 1)
						ToRun.ScriptValue = "";

					VM_DOLPHIN_BLACK_END;
				}

				syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Scheduler run script"));
#ifdef EnableLuaUTranslator
				LuaU_MagicMul = 227;
#endif
				syn::RbxLua Sthread = syn::LuaTranslator::GetSingleton()->Convert(sh->MainThread, ToRun.ScriptValue, ToRun.ScriptMode, nullptr);
#ifdef EnableLuaUTranslator
				LuaU_MagicMul = 1;
#endif

				struct RbxThreadRef
				{
					BYTE Pad[8];
					DWORD L;
				};

				RbxThreadRef Ref{};
				Ref.L = Sthread;

				const auto ScriptContext = syn::Instance(DataModel).GetChildFromClassName(OBFUSCATE_STR("ScriptContext"));
				static DWORD RResume = 0;

				if (!RResume)
					RResume = RobloxBase(syn::Lua::RbxResume);

				MSpoofCallback();

				((int(__thiscall*)(int, RbxThreadRef*, int))RResume)(ScriptContext, &Ref, 0);
				syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Scheduler finish script exec"));
			}
			catch (const std::exception& ex)
			{
				sh->MainThread.GetGlobal("warn");
				sh->MainThread.PushString(ex.what());
				sh->MainThread.PCall(1, 0, 0);
			}
		}
	}
}

void syn::Scheduler::Attach()
{
	LastDefineKey = (int) RandomInteger(INT_MAX / 2, INT_MAX - 1);

#ifdef EnableHSVM
	syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Scheduler + HSVM attach"));
#else
	syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Scheduler attach"));
#endif

	syn::Profiler::GetSingleton()->AddProfile(OBFUSCATE_STR("Scheduler attach finish"));
}