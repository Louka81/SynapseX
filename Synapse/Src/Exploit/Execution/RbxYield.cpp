#include "RbxApi.hpp"
#include <themida/ThemidaSDK.h>

namespace syn
{
	RbxYield::RbxYield(RbxLua _L) : L(_L)
	{
	}

	int RbxYield::Execute(const std::function<YieldRetFunc()>& YieldedFunction) const
	{
		auto LState = L;

		static std::map<uintptr_t, std::string> YieldMap;

		auto& YMS = YieldMap[LState];
		if (YMS.empty())
			YMS = RandomString(16);

		LState.PushThread();
		LState.SetField(LUA_REGISTRYINDEX, YMS.c_str());

		std::thread([YieldedFunction, LState]
		{
			auto Sched = syn::Scheduler::GetSingleton();

			YieldRetFunc ReturnedFunc;
			try
			{
				ReturnedFunc = YieldedFunction();
			}
			catch (std::exception& Ex)
			{
				Sched->Push([LState, Ex](DWORD)
				{
					LState.PushString(Ex.what());

					const auto ScriptContext = syn::Instance(DataModel).GetChildFromClassName(
						OBFUSCATE_STR("ScriptContext"));
					((int(__thiscall*)(int, int))RobloxBase(OBFUSCATED_NUM(syn::Lua::RbxError)))(ScriptContext, LState);

					LState.Pop(LState.GetTop());
				});

				return;
			}

			Sched->Push([ReturnedFunc, LState](DWORD)
			{
				const auto Returns = ReturnedFunc(LState);

				RbxThreadRef Ref{};
				Ref.L = LState;

				const auto ScriptContext = syn::Instance(DataModel).GetChildFromClassName(
					OBFUSCATE_STR("ScriptContext"));
				((int(__thiscall*)(int, RbxThreadRef*, int))RobloxBase(OBFUSCATED_NUM(syn::Lua::RbxResume)))(
					ScriptContext, &Ref, Returns);
			});
		}).detach();

		*(BYTE*)(L - 36) |= 1;
		return L.RYield(0);
	}
}
