/*
 *	HSVM - Hook-Based Synapse Virtual Machine
 *	Written by 3dsboy08
 */

#include "./HSVM.hpp"
#include "./VMBase.hpp"

#include "../RbxLua.hpp"
#include "../../../Utilities/Spoofer.hpp"
#include "../../Security/MemCheck.hpp"
#include "../../../Source Dependencies/Lua/lvm.h"
#include "../../Misc/Structures.hpp"
#include "../../Misc/PointerObfuscation.hpp"
#include "../Conversion/RbxLuauConversion.hpp"
#include "../Scheduler.hpp"
#include "../RbxApi.hpp"

uint32_t OriginalVMJmp;
uint32_t OriginalLuaUVMJmp;
uint32_t OriginalLuaUCallVMJmp;
uint32_t OriginalLuaUDispatcherJmp;

uint32_t OriginalLuaUDispatcher;

/* prevent warning */
#undef setobj
#define RA(i)	(base+GETARG_A(i))
#define RB(i)	(base+GETARG_B(i))
#define RC(i)	(base+GETARG_C(i))
#define RKB(i)	(ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
#define RKC(i)	(ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
#define KBx(i)	(k+GETARG_Bx(i))
#define setobj(obj1,obj2) \
  { const TValue *o2=(obj2); TValue *o1=(obj1); \
    o1->value = o2->value; o1->tt=o2->tt; }

#ifndef EnableHSVMOnlyLuaU

#define Protect(x)	{ \
	if (IsLuaU)\
		*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc; \
	else\
		syn::PointerObfuscation::ObfuscateSavedPC(L + L_SAVEDPC, (DWORD)pc); \
	{x;}; base = *(StkId*) (L + L_BASE);\
}

#else

#define Protect(x)	{ \
	*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc; \
	{x;}; base = *(StkId*) (L + L_BASE);\
}

#endif

#define r_iscollectable(v) (ttype(v) >= R_LUA_TSTRING)
#define r_iswhite(x) test2bits((x), WHITE0BIT, WHITE1BIT)
#define r_isblack(x) testbit((x), BLACKBIT)
#define r_valiswhite(x) (r_iscollectable(x) && r_iswhite(*cast(lu_byte*, gcvalue(x) + 4)))
#define r_black2gray(x) resetbit((x), BLACKBIT)

#define r_luaD_checkstack(L, n)	\
  if ((cast(char*, *(TValue**)((L) + L_STKLAST)) - cast(char*, *(TValue**)((L) + L_TOP))) <= ((n)*(int)sizeof(TValue))) \
    SL.DGrowStk(n);

#define r_tonumber_forprep(rL, o, n) (ttype(o) == R_LUA_TNUMBER || (((o) = (rL)->VToNumberForPrep(o, n)) != NULL))

#define runtime_check(L, c)	{ if (!(c)) break; }

#define arith_op(op,tm) { \
        TValue *rb = RKB(i); \
        TValue *rc = RKC(i); \
        if (ttype(rb) == R_LUA_TNUMBER && ttype(rc) == R_LUA_TNUMBER) { \
          lua_Number nb = SL.XorDouble(nvalue(rb)), nc = SL.XorDouble(nvalue(rc)); \
          r_setnvalue(ra, SL.XorDouble(op(nb, nc))); \
        } \
        else \
          Protect(SL.VArith(ra, rb, rc, tm)); \
      }

#define R_TM_ADD 8
#define R_TM_SUB 11
#define R_TM_MUL 6
#define R_TM_DIV 7
#define R_TM_MOD 9
#define R_TM_POW 12
#define R_TM_UNM 10
#define R_TM_LEN 14
#undef and

namespace syn::HSVM
{
#pragma region HSVM Normal
	int __cdecl Execute(DWORD L, int nexeccalls, int from)
	{
		DWORD cl;
		StkId base;
		TValue* k;
		Instruction* pc;
		Instruction* pcBase;
		syn::RbxLua SL(L);

        auto SEntry = false;

	reentry:  /* entry point */
		cl = **(DWORD**)(*(DWORD*)(L + L_CI) + CI_FUNC);
		syn::Structures::rProto P(syn::PointerObfuscation::DeObfuscateLClosure(cl + 20));

		if (P.lastlinedefined != LastDefineKey)
		{
			if (from && SEntry)
			{
				auto Ret = nexeccalls + 1;
				Ret |= 1UL << 20;
				return Ret;
			}

			return nexeccalls + 1;
		}

		pcBase = P.code;
		k = P.k;

		//OP_CALL from LuaU does not set ci->savedpc, we have to do that ourselves.
		if (from && !SEntry)
			*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pcBase;
		
		SEntry = true;

		const auto VMMarker = (HSvmSettings*) (uint32_t) P.linedefined;
		auto ShadowK = VMMarker->ShadowK;

#ifndef EnableHSVMOnlyLuaU
		if (IsLuaU)
			pc = *(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC);
		else
			pc = (Instruction*) syn::PointerObfuscation::DeObfuscateSavedPC(L + L_SAVEDPC);
#else
		pc = *(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC);
#endif

#ifndef EnableHSVMOnlyLuaU
		if (IsLuaU && pcBase == pc)
#else
		if (pcBase == pc)
#endif
		{
			/* If its a vararg function, use emulated OP_INIT2. */
			if (P.is_vararg)
			{
				DWORD v533 = P.numparams;
				DWORD v534 = *(DWORD*)(L + L_CI);
				*(DWORD*)(v534 + CI_SAVEDPC) = (DWORD)pc;
				DWORD v535 = v533 + *(unsigned __int8*)(cl + LCL_MAXSTACKSIZE);
				DWORD v536 = *(DWORD*)(L + L_STKLAST) - *(DWORD*)(L + L_TOP);
				DWORD v560 = v535;
				if (v536 <= 16 * v535)
				{
					SL.DGrowStk(v560);
				}
				DWORD v537 = (*(DWORD*)(L + L_TOP) - *(DWORD*)(L + L_BASE)) >> 4;
				if (v537 < v533)
				{
					DWORD v538 = v533 - v537;
					v537 += v538;
					do
					{
						*(DWORD*)(*(DWORD*)(L + L_TOP) + 8) = 0;
						*(DWORD*)(L + L_TOP) += 16;
						--v538;
					} while (v538);
				}
				DWORD v8 = *(DWORD*)(L + L_TOP);
				DWORD v539 = *(DWORD*)(L + L_TOP) - 16 * v537;
				DWORD v568 = *(DWORD*)(L + L_TOP);
				v560 = v539;
				if (v533)
				{
					DWORD v562 = v8 - v560;
					DWORD v540 = v8 - v560;
					DWORD v561 = v8;
					DWORD v541 = v560 + 8;
					DWORD v542 = v8;
					DWORD v543 = v533;
					do
					{
						v542 += 16;
						*(DWORD*)(v542 - 16) = *(DWORD*)(v541 - 8);
						v541 += 16;
						*(DWORD*)(v542 - 12) = *(DWORD*)(v541 - 20);
						*(DWORD*)(v540 + v541 - 16) = *(DWORD*)(v541 - 16);
						*(DWORD*)(v541 - 16) = 0;
						--v543;
					} while (v543);
					v8 = v568;
				}

				*(DWORD*)(*(DWORD*)(L + L_CI) + CI_BASE) = v8;
				*(DWORD*)(*(DWORD*)(L + L_CI) + CI_TOP) = v8 + 16 * *(unsigned __int8*)(cl + LCL_MAXSTACKSIZE);
				DWORD v544 = *(DWORD*)(*(DWORD*)(L + L_CI) + CI_TOP);

				for (auto j = v8 + 16 * v533; j < v544; j += 16)
					*(DWORD*)(j + 8) = 0;

				*(DWORD*)(L + L_TOP) = v544;
				*(DWORD*)(L + L_BASE) = v8;
			}

			/* If not, just use OP_INIT */
			else
			{
				auto CITop = *(DWORD*)(*(DWORD*)(L + L_CI) + CI_TOP);
				for (auto r = *(DWORD*)(L + L_TOP); r < CITop; r += 16)
					*(DWORD*)(r + 8) = 0;
				*(DWORD*)(L + L_TOP) = CITop;
			}
		}

		base = *(StkId*)(L + L_BASE);

		/* main loop of interpreter */
		for (;;)
		{
			const Instruction i = *pc++;

			/* warning!! several calls may realloc the stack and invalidate `ra' */
			switch (GET_OPCODE(i))
			{
				case OpCode::OP_MOVE:
				{
					StkId ra = RA(i);
					r_setobj(ra, RB(i));
					continue;
				}
				case OpCode::OP_LOADK:
				{
					StkId ra = RA(i);
					r_setobj(ra, KBx(i));
					continue;
				}

				case OpCode::OP_LOADBOOL:
				{
					StkId ra = RA(i);
					r_setbvalue(ra, GETARG_B(i));
					if (GETARG_C(i)) pc++;  /* skip next instruction (if C) */
					continue;
				}
				case OpCode::OP_LOADNIL:
				{
					StkId ra = RA(i);
					TValue* rb = RB(i);
					do {
						r_setnilvalue(rb--);
					} while (rb >= ra);
					continue;
				}
				case OpCode::OP_GETUPVAL:
				{
					StkId ra = RA(i);
					int b = GETARG_B(i);
					UpVal** upvals = (UpVal**)(cl + LCL_UPVALS);
					r_setobj(ra, upvals[b]->v);
					continue;
				}
				case OpCode::OP_CGETGLOBAL:
				{
					StkId ra = RA(i);
					TValue* env = *(TValue**)(cl + LCL_ENV);

					if (*(uint8_t*)((uintptr_t) env + T_UNTOUCHED)) /* are we untouched? */
					{
						TValue* rks = ShadowK + GETARG_Bx(i);

						if (ttype(rks) != R_LUA_TNIL) /* do we already have a cached constant? */
						{
							r_setobj(ra, rks); /* yes, set to ra */
						}
						else /* no, create a cache */
						{
							TValue* rb = KBx(i);
							TValue g;
							r_sethvalue(&g, env);
							Protect(SL.VGetTable(&g, rb, ra));
							/* set cache constant */
							r_setobj(rks, ra);
							if (ttype(rks) != R_LUA_TNIL && 
								ttype(rks) != R_LUA_TNONE &&
								ttype(rks) != R_LUA_TNUMBER &&
								ttype(rks) != R_LUA_TBOOLEAN &&
								ttype(rks) != R_LUA_TLIGHTUSERDATA) /* is this a GCable type? */
							{
								/* yes, set marked to be fixed */
								uintptr_t gcval = (uintptr_t) rks->value.gc;
								l_setbit(*(uint8_t*)(gcval + GCO_MARKED), FIXEDBIT);
							}
						}
					}
					else /* no? fallback to regular OP_GETGLOBAL */
					{
						TValue g;
						TValue* rb = KBx(i);
						r_sethvalue(&g, env);
						Protect(SL.VGetTable(&g, rb, ra));
					}

					continue;
				}
				case OpCode::OP_GETGLOBAL:
				{
					StkId ra = RA(i);
					TValue g;
					TValue* rb = KBx(i);
					r_sethvalue(&g, *(TValue**)(cl + LCL_ENV));
					Protect(SL.VGetTable(&g, rb, ra));
					continue;
				}
				case OpCode::OP_GETTABLE:
				{
					StkId ra = RA(i);
					Protect(SL.VGetTable(RB(i), RKC(i), ra));
					continue;
				}
				case OpCode::OP_SETGLOBAL:
				{
					StkId ra = RA(i);
					TValue g;
					r_sethvalue(&g, *(TValue**)(cl + LCL_ENV));
					Protect(SL.VSetTable(&g, KBx(i), ra));
					continue;
				}
				case OpCode::OP_CSETGLOBAL:
				{
					StkId ra = RA(i);
					TValue* env = *(TValue**)(cl + LCL_ENV);

					if (*(uint8_t*)((uintptr_t) env + T_UNTOUCHED))  /* are we untouched? */
					{
						TValue* rks = ShadowK + GETARG_Bx(i);
						/* set cache to new global */
						r_setobj(rks, ra);
						if (ttype(rks) != R_LUA_TNIL && 
							ttype(rks) != R_LUA_TNONE &&
							ttype(rks) != R_LUA_TNUMBER &&
							ttype(rks) != R_LUA_TBOOLEAN &&
							ttype(rks) != R_LUA_TLIGHTUSERDATA) /* is this a GCable type? */
						{
							/* yes, set marked to be fixed */
							uintptr_t gcval = (uintptr_t) rks->value.gc;
							l_setbit(*(uint8_t*)(gcval + GCO_MARKED), FIXEDBIT);
						}
						TValue g;
						r_sethvalue(&g, env);
						Protect(SL.VSetTable(&g, KBx(i), ra));
					}
					else /* no? fallback to regular OP_SETGLOBAL */
					{
						TValue g;
						r_sethvalue(&g, env);
						Protect(SL.VSetTable(&g, KBx(i), ra));
					}

					continue;
				}
				case OpCode::OP_SETUPVAL:
				{
					StkId ra = RA(i);
					UpVal** upvals = (UpVal**)(cl + LCL_UPVALS);
					UpVal* uv = upvals[GETARG_B(i)];
					r_setobj(uv->v, ra);
					SL.CBarrier((DWORD)uv, (DWORD)ra);
					continue;
				}
				case OpCode::OP_SETTABLE:
				{
					StkId ra = RA(i);
					Protect(SL.VSetTable(ra, RKB(i), RKC(i)));
					continue;
				}
				case OpCode::OP_NEWTABLE:
				{
					StkId ra = RA(i);
					int b = GETARG_B(i);
					int c = GETARG_C(i);
					r_sethvalue(ra, SL.HNew(luaO_fb2int(b), luaO_fb2int(c)));
                    Protect(SL.CheckGC());
					continue;
				}
				case OpCode::OP_SELF:
				{
					StkId ra = RA(i);
					StkId rb = RB(i);

#ifndef EnableHSVMOnlyLuaU
					if (!IsLuaU)
					{
						//Namecall optimization.
						auto Ret = SL.VNameCall(rb);

						if (*(uintptr_t*)(Ret + 8) == R_LUA_TFUNCTION)
						{
							r_setobj(ra, rb);
							r_setobj(ra + 1, RKC(i));
							continue;
						}
					}
#endif

					r_setobj(ra + 1, rb);
					Protect(SL.VGetTable(rb, RKC(i), ra));
					continue;
				}
				case OpCode::OP_ADD:
				{
					StkId ra = RA(i);
					arith_op(luai_numadd, R_TM_ADD);
					continue;
				}
				case OpCode::OP_SUB:
				{
					StkId ra = RA(i);
					arith_op(luai_numsub, R_TM_SUB);
					continue;
				}
				case OpCode::OP_MUL:
				{
					StkId ra = RA(i);
					arith_op(luai_nummul, R_TM_MUL);
					continue;
				}
				case OpCode::OP_DIV:
				{
					StkId ra = RA(i);
					arith_op(luai_numdiv, R_TM_DIV);
					continue;
				}
				case OpCode::OP_MOD:
				{
					StkId ra = RA(i);
					arith_op(luai_nummod, R_TM_MOD);
					continue;
				}
				case OpCode::OP_POW:
				{
					StkId ra = RA(i);
					arith_op(luai_numpow, R_TM_POW);
					continue;
				}
				case OpCode::OP_UNM:
				{
					StkId ra = RA(i);
					TValue* rb = RB(i);
					if (ttype(rb) == R_LUA_TNUMBER)
					{
						lua_Number nb = SL.XorDouble(nvalue(rb));
						r_setnvalue(ra, SL.XorDouble(luai_numunm(nb)));
					}
					else
					{
						Protect(SL.VArith(ra, rb, rb, R_TM_UNM));
					}
					continue;
				}
				case OpCode::OP_NOT:
				{
					StkId ra = RA(i);
					int res = l_isfalse(RB(i));  /* next assignment may change this value */
					r_setbvalue(ra, res);
					continue;
				}
				case OpCode::OP_LEN:
				{
					StkId ra = RA(i);
					const TValue* rb = RB(i);
					switch (ttype(rb))
					{
						case R_LUA_TTABLE:
						{
							r_setnvalue(ra, SL.XorDouble(cast_num(SL.HGetN(hvalue(rb)))));
							break;
						}
						case R_LUA_TSTRING:
						{
							r_setnvalue(ra, SL.XorDouble(SL.RawSLen(rawtsvalue(rb))));
							break;
						}
						default:
						{
							Protect(
								if (!SL.CallBinTM(rb, luaO_nilobject, ra, R_TM_LEN))
									SL.GTypeError(rb, "get length of");
							)
						}
					}
					continue;
				}
				case OpCode::OP_CONCAT:
				{
					int b = GETARG_B(i);
					int c = GETARG_C(i);
                    Protect(SL.VConcat(c - b + 1, c); SL.CheckGC());
					r_setobj(RA(i), base + b); /* previous call may change the stack */
					continue;
				}
				case OpCode::OP_JMP:
				{
					dojump(pc, GETARG_sAx(i));
					continue;
				}
				case OpCode::OP_EQ:
				{
					TValue* rb = RKB(i);
					TValue* rc = RKC(i);
					if ((ttype(rb) == ttype(rc) && SL.VEqualVal(rb, rc)) == GETARG_A(i))
						dojump(pc, GETARG_sAx(*pc));
					pc++;
					continue;
				}
				case OpCode::OP_LT:
				{
					Protect(
						if (SL.LessThan(RKB(i), RKC(i)) == GETARG_A(i))
							dojump(pc, GETARG_sAx(*pc));
					)
					pc++;
					continue;
				}
				case OpCode::OP_LE:
				{
					Protect(
						if (SL.LessEqual(RKB(i), RKC(i)) == GETARG_A(i))
							dojump(pc, GETARG_sAx(*pc));
					)
					pc++;
					continue;
				}
				case OpCode::OP_TEST:
				{
					StkId ra = RA(i);
					if (l_isfalse(ra) != GETARG_C(i))
						dojump(pc, GETARG_sAx(*pc));
					pc++;
					continue;
				}
				case OpCode::OP_TESTSET:
				{
					StkId ra = RA(i);
					TValue* rb = RB(i);
					if (l_isfalse(rb) != GETARG_C(i)) 
					{
						r_setobj(ra, rb);
						dojump(pc, GETARG_sAx(*pc));
					}
					pc++;
					continue;
				}
				case OpCode::OP_CALL:
				{
					StkId ra = RA(i);
					int b = GETARG_B(i);
					int nresults = GETARG_C(i) - 1;
					if (b != 0) *(DWORD*)(L + L_TOP) = (DWORD)(ra + b);  /* else previous instruction set top */

#ifndef EnableHSVMOnlyLuaU
					if (IsLuaU)
						*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc;
					else
                        syn::PointerObfuscation::ObfuscateSavedPC(L + L_SAVEDPC, (DWORD)pc);

					int Pcr = 0;
					if (IsLuaU)
						Pcr = SL.DPreCallU(ra, nresults);
					else
						Pcr = SL.DPreCall(ra, nresults);
#else
					*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc;

					auto Pcr = SL.DPreCallU(ra, nresults);
#endif

					switch (Pcr)
					{
						case PCRLUA:
						{
							nexeccalls++;
							goto reentry;  /* restart syn::HSVM::Execute over new Lua function */
						}
						case PCRC:
						{
							/* it was a C function (`precall' called it); adjust results */
							if (nresults >= 0) *(DWORD*)(L + L_TOP) = *(DWORD*)(*(DWORD*)(L + L_CI) + CI_TOP);
							base = *(StkId*)(L + L_BASE);
							continue;
						}
						default:
						{
							return 0;  /* yield */
						}
					}
				}
				case OpCode::OP_RETURN:
				{
					StkId ra = RA(i);
					int b = GETARG_B(i);
					if (b != 0) *(DWORD*)(L + L_TOP) = (DWORD)(ra + b - 1);

					if (*(DWORD*)(L + OpenUpV)) /* L->openupval */
                        SL.FClose(base);

#ifndef EnableHSVMOnlyLuaU
                   	if (IsLuaU)
						*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc;
					else
                        syn::PointerObfuscation::ObfuscateSavedPC(L + L_SAVEDPC, (DWORD) pc);
#else
					*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc;
#endif

					b = SL.DPosCall(ra);

					if (--nexeccalls == 0)  /* was previous function running `here'? */
						return 0;  /* no: return */
					else
					{
						/* yes: continue its execution */
						if (b) *(DWORD*)(L + L_TOP) = *(DWORD*)(*(DWORD*)(L + L_CI) + CI_TOP);
						goto reentry;
					}
				}
				case OpCode::OP_FORLOOP:
				{
					StkId ra = RA(i);
					lua_Number step = nvalue(ra + 2);
					lua_Number idx = luai_numadd(nvalue(ra), step); /* increment index */
					lua_Number limit = nvalue(ra + 1);

					if (luai_numlt(0, step) ? luai_numle(idx, limit)
						                    : luai_numle(limit, idx))
					{
						dojump(pc, GETARG_sBx(i));  /* jump back */
						r_setnvalue(ra, idx);  /* update internal index... */
						r_setnvalue(ra + 3, SL.XorDouble(idx));  /* ...and external index */
					}
					continue;
				}
				case OpCode::OP_FORPREP:
				{
					StkId ra = RA(i);
					TValue* init = ra;
					TValue* plimit = ra + 1;
					TValue* pstep = ra + 2;

					/* next steps may throw errors */
#ifndef EnableHSVMOnlyLuaU
					if (IsLuaU)
						*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc;
					else
                        syn::PointerObfuscation::ObfuscateSavedPC(L + L_SAVEDPC, (DWORD)pc);
#else
					*(Instruction**)(*(DWORD*)(L + L_CI) + CI_SAVEDPC) = pc;
#endif

					if (!r_tonumber_forprep(&SL, init, ra))
                        SL.GRunError("'for' initial value must be a number");
					else if (!r_tonumber_forprep(&SL, init, ra))
                        SL.GRunError("'for' limit must be a number");
					else if (!r_tonumber_forprep(&SL, init, ra))
						SL.GRunError("'for' step must be a number");

					r_setnvalue(ra, luai_numsub(SL.XorDouble(nvalue(ra)), SL.XorDouble(nvalue(pstep))));

					r_setnvalue(plimit, SL.XorDouble(nvalue(plimit)));
					r_setnvalue(pstep, SL.XorDouble(nvalue(pstep)));

					dojump(pc, GETARG_sBx(i));
					continue;
				}
				case OpCode::OP_TFORLOOP:
				{
					StkId ra = RA(i);
					StkId cb = ra + 3;  /* call base */
					r_setobj(cb + 2, ra + 2);
					r_setobj(cb + 1, ra + 1);
					r_setobj(cb, ra);
					*(DWORD*)(L + L_TOP) = (DWORD)(cb + 3);  /* func. + 2 args (state and index) */
					Protect(SL.DCall(cb, GETARG_C(i)));
					*(DWORD*)(L + L_TOP) = *(DWORD*)(*(DWORD*)(L + L_CI) + CI_TOP);
					cb = RA(i) + 3;  /* previous call may change the stack */
					if (ttype(cb) != R_LUA_TNIL)
					{
						r_setobj(cb - 1, cb);  /* save control variable */
						dojump(pc, GETARG_sAx(*pc));  /* jump back */
					}
					pc++;
					continue;
				}
				case OpCode::OP_SETLIST:
				{
					StkId ra = RA(i);
					int n = GETARG_B(i);
					int c = GETARG_C(i);
					int last;
					DWORD h;
					if (n == 0) 
					{
						n = cast_int(*(TValue**)(L + L_TOP) - ra) - 1;
						*(DWORD*)(L + L_TOP) = *(DWORD*)(*(DWORD*)(L + L_CI) + CI_TOP);
					}
					if (c == 0) c = cast_int(*pc++);

                    runtime_check(L, ttype(ra) == R_LUA_TTABLE);

					h = (DWORD)hvalue(ra);
					last = ((c - 1) * LFIELDS_PER_FLUSH) + n;
					if (last > *(int*)(h + 12))  /* needs more space? */
						SL.HResizeArray((Table*)h, last); /* pre-alloc it at once */

					for (; n > 0; n--) 
					{
						TValue* val = ra + n;
						r_setobj(SL.HSetNum((Table*)h, last--), val);
						SL.CBarrierT((DWORD)h, (DWORD)val);
					}
					continue;
				}
				case OpCode::OP_CLOSE:
				{
					StkId ra = RA(i);
					SL.FClose(ra);
					continue;
				}
				case OpCode::OP_CLOSURE:
				{
					StkId ra = RA(i);
					DWORD p;
					int nup, j;
					DWORD* rp = P.p;
					p = rp[GETARG_Bx(i)];
					nup = *(BYTE*)(p + PO_NUPS);

                    DWORD lc = SL.NewLClosure(nup, *(BYTE*)(p + PO_MAXSTACKSIZE), *(DWORD*)(cl + LCL_ENV));
                    syn::PointerObfuscation::ObfuscateLClosure(lc + 20, p);

					auto upvals = (UpVal**) (lc + LCL_UPVALS);
					auto oupvals = (UpVal**) (cl + LCL_UPVALS);

					for (j = 0; j < nup; j++, pc++)
					{
						if (GET_OPCODE(*pc) == OpCode::OP_GETUPVAL)
							upvals[j] = oupvals[GETARG_B(*pc)];
						else
						{
							upvals[j] = SL.FFindUpval(base + GETARG_B(*pc));
						}
					}

					r_setclvalue(ra, lc);
                    Protect(SL.CheckGC());
					continue;
				}
				case OpCode::OP_VARARG:
				{
					StkId ra = RA(i);
					int b = GETARG_B(i) - 1;
					int j;

					int n = cast_int(*(TValue**)(*(DWORD*)(L + L_CI) + CI_BASE) - *(TValue**)(*(DWORD*)(L + L_CI) + CI_FUNC)) -
						*(BYTE*)(syn::PointerObfuscation::DeObfuscateLClosure(cl + 20) + PO_NUMPARAMS) - 1;

					if (b == LUA_MULTRET)
					{
                        Protect(r_luaD_checkstack(L, n));

						ra = RA(i);  /* previous call may change the stack */
						b = n;
						*(DWORD*)(L + L_TOP) = (DWORD)(ra + n);
					}
					for (j = 0; j < b; j++)
					{
						if (j < n)
						{
							r_setobj(ra + j, *(TValue**)(*(DWORD*)(L + L_CI) + CI_BASE) - n + j);
						}
						else
						{
							r_setnilvalue(ra + j);
						}
					}
					continue;
				}
				default:
				{
					continue;
				}
			}
		}
	}
#pragma endregion

	__declspec(naked) void VMHook()
	{
		__asm
		{
			//Backup registers
			push eax
			push ecx
			push edx
			//Push L + nexecalls
			push 0
			push [ebx + 0xC]
			push esi
			//Call HSVM
			call syn::HSVM::Execute
			//Pop arguments
			add esp, 12
			//Restore registers
			pop edx
			pop ecx
			//Check for call type
			cmp eax, 0
			jne RealVM

			//HSVM executed it, we can return.
			pop eax
			//Actual return, after we pop eax from our original code.
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			mov esp, ebx
			pop ebx
			retn

			//Not a HSVM function, jmp to real VM.
			RealVM:
			//Set nexecalls to real value 
			dec eax
			mov [ebx + 0xC], eax
			//Restore eax (unused here)
			pop eax
			//Set L->ci & associated registers
			lea eax, [esi + 0x10]
			mov [ebp - 0x30], edx
			mov [ebp - 0x4C], eax
			//Prepare jmp back to real VM.
			mov eax, [esi + 0x10]
			mov edi, [edx]
			jmp [OriginalVMJmp]
		}
	}

	__declspec(naked) void VMLuaUHook()
	{
		__asm
		{
			//Backup registers
			push eax
			push ecx
			push edx
			//Push L + nexecalls
			push 0
			push [ebx + 0xC]
			push esi
			//Call HSVM
			call syn::HSVM::Execute
			//Pop arguments
			add esp, 12
			//Restore registers
			pop edx
			pop ecx
			//Check for call type
			cmp eax, 0
			jne RealVM

			//HSVM executed it, we can return.
			pop eax
			//Actual return, after we pop eax from our original code.
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			mov esp, ebx
			pop ebx
			retn

			//Not a HSVM function, jmp to real LuaU VM.
			RealVM:
			//Set nexeccalls
			dec eax
			mov [ebx + 0xC], eax
			//Restore eax
			pop eax
			//Set eax to L->ci
			mov eax, [esi + 0x10]
			//Get ci->func
			mov edi, [eax + 4]
			mov eax, [eax]
			//Do original code.
			mov eax, [eax]
			mov [ebp - 0x28], eax
			//Jmp back to real LuaU VM.
			jmp [OriginalLuaUVMJmp]
		}
	}

#undef xor
	__declspec(naked) void VMLuaUCallHook()
	{
		__asm
		{
			//Backup registers
			push eax
			push ecx
			push edx
			//Push L + nexecalls
			push 1
			push [ebx + 0xC]
			push esi
			//Call HSVM
			call syn::HSVM::Execute
			//Pop arguments
			add esp, 12
			//Restore registers
			pop edx
			pop ecx
			//Check for call type
			cmp eax, 0
			jne RealVM

			//HSVM executed it, we can return.
			pop eax
			//Actual return, after we pop eax from our original code.
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			mov esp, ebx
			pop ebx
			retn

			//Not a HSVM function, jmp to real LuaU VM.
			RealVM:
			//Check for Syn flag.
			push eax
			shr eax, 20
			and eax, 1
			cmp eax, 1
			pop eax
			je RealVMFromSyn
			//Set nexeccalls
			dec eax
			mov [ebx + 0xC], eax
			//Restore eax
			pop eax
			//Do original code we hooked
			xor eax, ecx
			add eax, 0x24
			//Jmp back to real LuaU VM.
			jmp [OriginalLuaUCallVMJmp]

			//Not a HSVM function, jmp to real LuaU VM.
			RealVMFromSyn:
			//Remove Syn flag
			and eax, -1048577
			//Set nexeccalls
			dec eax
			mov [ebx + 0xC], eax
			//Restore eax
			pop eax
			//Set L->ci for callback
			mov edx, [esi + 0x10]
			mov edi, [edx + 4]
			mov eax, [edx]
			//Set L->base
			mov edx, [esi + 8]
			mov [ebp - 0xC], edx
			//Jmp back to real LuaU VM.
			jmp [OriginalLuaUDispatcherJmp]
		}
	}

	void Attach()
	{
		VM_DOLPHIN_RED_START

#ifndef EnableHSVMOnlyLuaU
		OriginalVMJmp = syn::RobloxBase(VMJmp);
#endif
		OriginalLuaUVMJmp = syn::RobloxBase(VMLuaUJmp);
		OriginalLuaUCallVMJmp = syn::RobloxBase(VMLuaUOpCallJmp);
		OriginalLuaUDispatcherJmp = syn::RobloxBase(VMLuaUDispatcher);

#ifndef EnableHSVMOnlyLuaU
		static auto VMHookInit = false;
#endif
		static auto VMHookUInit = false;

		if (IsLuaU && !VMHookUInit)
		{
			syn::MemCheck::RawHook(syn::RobloxBase(VMLuaUCall), (DWORD) VMLuaUHook);
			syn::MemCheck::RawHook(syn::RobloxBase(VMLuaUOpCallCall), (DWORD) VMLuaUCallHook);
			VMHookUInit = true;
		}
#ifndef EnableHSVMOnlyLuaU
		else if (!VMHookInit)
		{
			syn::MemCheck::RawHook(syn::RobloxBase(VMCall), (DWORD) VMHook);
			VMHookInit = true;
		}
#endif

        VM_DOLPHIN_RED_END;
	}
}