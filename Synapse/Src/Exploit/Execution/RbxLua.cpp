#include "./RbxLua.hpp"

#include "../Misc/Flags.hpp"
#include "../Security/DataBin.hpp"
#include "../Security/SysHook.hpp"

#include "../../Utilities/Utils.hpp"
#include "../../Utilities/Spoofer.hpp"
#include "../../Utilities/Hashing/fnv.hpp"
#include "../../Utilities/Obfuscation/ObfuscatedNumber.hpp"

#include "../../Source Dependencies/Lua/lvm.h"
#include "../Misc/PointerObfuscation.hpp"
#include "./Virtual Machine/VMBase.hpp"

#include <cryptopp/rng.h>

/* Helper macros */
#define GetFuncInformation(name, addr, cc) \
       (addr) = GetBinValue(FNVA1_CONSTEXPR(#name)); \
       (cc) = (CallingConvention)GetBinValue(FNVA1_CONSTEXPR("CC_" TO_STR(name)))

int CallcheckProxy(DWORD rL);
namespace syn
{
	uintptr_t RetAddr;

	/* HSVM cached addresses */
	uintptr_t HGetNAddr, HNewAddr, GTypeErrAddr, GRunErrAddr, VConcatAddr,
              VArithAddr, FFindUpvalAddr, FCloseAddr, CallBinTMAddr,
	          LessThanAddr, LessEqualAddr, VEqualValAddr, HResizeArrayAddr,
	          HSetNumAddr, DPreCallAddr, DPreCallUAddr, DGrowStkAddr,
	          DPosCallAddr, DCallAddr, CStepAddr, CBarRFAddr, VGetTableAddr,
	          VSetTableAddr, VGetNameCallAddr, RLuaNilObject;

    /* Lua cached addresses */
    uintptr_t LNewLStr, LPcall, LMalloc, LRError, LIndex2Adr, LPushCClosure, LToPointer,
        LGetMetaTable, LSetupThread, LRawGetI, LNext, LGetMetaField, LYield,
        LSetMetaTable, LGetStack, LGetInfo, LGetLocal, LSetLocal, LGetUpvalue,
        LSetUpvalue, LNewThread;

    /* Lua cached calling conventions */
    CallingConvention CCLNewLStr, CCLPcall, CCLMalloc, CCLRError, CCLIndex2Adr, CCLPushCClosure,
        CCLToPointer, CCLGetMetaTable, CCLSetupThread, CCLRawGetI, CCLNext,
        CCLGetMetaField, CCLYield, CCLSetMetaTable, CCLGetStack, CCLGetInfo,
        CCLGetLocal, CCLSetLocal, CCLGetUpvalue, CCLSetUpvalue, CCLNewThread;

    /* Misc cached data */
    r_lua_CFunction CallcheckHook;
    PEXCEPTION_ROUTINE ExceptionRoutine;

    //CallingConvention conv = (syn::CallingConvention)GetBinValue(OBFUSCATE_STR("CC_" TO_STR(binname)))
	uintptr_t DXorKey;

    void RbxLua::_PushCFunction(RbxLua* rL, r_lua_CFunction cF)
    {
        const auto CC = new SynCClosure();
        CC->Address = (DWORD)cF;
        CC->ExtraSpace = 0;
        rL->PushLightUserData(CC);
        rL->PushCClosure(CallcheckHook, 1);
    }

    void RbxLua::_PushCClosure(RbxLua* rL, DWORD upvalues)
    {
        rL->PushCClosure(CallcheckHook, upvalues);
    }

    double RbxLua::XorDouble(double num)
    {
        uint64_t U64_Xor = *reinterpret_cast<uint64_t*>(&num) ^ *reinterpret_cast<uint64_t*>(DXorKey);
        return *reinterpret_cast<double*>(&U64_Xor);
    }

    const TValue* RbxLua::VToNumber(const TValue* obj, TValue* n) const
    {
        lua_Number num;
        if (ttype(obj) == R_LUA_TNUMBER) return obj;
        if (ttype(obj) == R_LUA_TSTRING && luaO_str2d(GetStr(rawtsvalue(obj)), &num)) {
            r_setnvalue(n, XorDouble(num));
            return n;
        }
        else
            return NULL;
    }

	TValue* RbxLua::VToNumberForPrep(TValue* obj, TValue* n) const
	{
		lua_Number num;
		if (ttype(obj) == R_LUA_TNUMBER) return obj;
		if (ttype(obj) == R_LUA_TSTRING && luaO_str2d(GetStr(rawtsvalue(obj)), &num)) {
			r_setnvalue(n, XorDouble(num));
			return n;
		}
		else
			return NULL;
	}

    int RbxLua::VToString(StkId obj) const
    {
        if (ttype(obj) != R_LUA_TNUMBER)
            return 0;
        else {
            char s[LUAI_MAXNUMBER2STR];
            lua_Number n = nvalue(obj);
            lua_number2str(s, n);
            r_setsvalue(obj, SNew(s));
            return 1;
        }
    }

    uintptr_t RbxLua::GetBinValue(const uint32_t BinHash) noexcept
    {
        syn::BinManager* bm = syn::BinManager::GetSingleton();
        syn::OffsetBin* try_get = reinterpret_cast<syn::OffsetBin*>(bm->GetBin(BinHash));
        if (try_get)
            return try_get->Value();

        return NULL;
    }

    void RbxLua::Initialize()
    {
        VM_TIGER_WHITE_START;

		auto DbgCore = syn::FindModule(OBFUSCATE_STR("dbgcore.dll"));
		auto MiniDumpPointer = syn::FindProcAddress(DbgCore, OBFUSCATE_STR("MiniDumpWriteDump"));

		if (!MiniDumpPointer)
		{
			auto DbgHelp = syn::FindModule(OBFUSCATE_STR("dbghelp.dll"));
			MiniDumpPointer = syn::FindProcAddress(DbgHelp, OBFUSCATE_STR("MiniDumpWriteDump"));
		}

		RetAddr = syn::RobloxBase(syn::Spoofer::ReturnAddress);

        /* Efficency at a cost... */
        CallcheckHook = reinterpret_cast<r_lua_CFunction>(syn::RobloxBase(OBFUSCATED_NUM(syn::CallCheck::CallcheckAddress)));
        ExceptionRoutine = (PEXCEPTION_ROUTINE)RobloxBase(syn::Spoofer::ExceptionHandlerAddress);

        GetFuncInformation(lua_newlstring, LNewLStr, CCLNewLStr);
        GetFuncInformation(lua_pcall, LPcall, CCLPcall);
        GetFuncInformation(lua_malloc, LMalloc, CCLMalloc);
        GetFuncInformation(index2addr, LIndex2Adr, CCLIndex2Adr);
        GetFuncInformation(lua_pushcclosure, LPushCClosure, CCLPushCClosure);
        GetFuncInformation(lua_topointer, LToPointer, CCLToPointer);
        GetFuncInformation(lua_getmetatable, LGetMetaTable, CCLGetMetaTable);
        GetFuncInformation(lua_error, LRError, CCLRError);
        GetFuncInformation(setupthread, LSetupThread, CCLSetupThread);
        GetFuncInformation(lua_rawgeti, LRawGetI, CCLRawGetI);
        GetFuncInformation(lua_next, LNext, CCLNext);
        GetFuncInformation(lua_getmetafield, LGetMetaField, CCLGetMetaField);
        GetFuncInformation(lua_yield, LYield, CCLYield);
        GetFuncInformation(lua_setmetatable, LSetMetaTable, CCLSetMetaTable);
        GetFuncInformation(lua_getstack, LGetStack, CCLGetStack);
        GetFuncInformation(lua_getinfo, LGetInfo, CCLGetInfo);
        GetFuncInformation(lua_getlocal, LGetLocal, CCLGetLocal);
        GetFuncInformation(lua_setlocal, LSetLocal, CCLSetLocal);
        GetFuncInformation(lua_getupvalue, LGetUpvalue, CCLGetUpvalue);
        GetFuncInformation(lua_setupvalue, LSetUpvalue, CCLSetUpvalue);
        GetFuncInformation(lua_newthread, LNewThread, CCLNewThread);

        /* Setup HSVM addresses */
        GTypeErrAddr = syn::RobloxBase(TypeErr);
        GRunErrAddr = syn::RobloxBase(RunErr);
        VConcatAddr = syn::RobloxBase(LVConcat);
        VArithAddr = syn::RobloxBase(VMArith);
        FFindUpvalAddr = syn::RobloxBase(FindUpv);
        FCloseAddr = syn::RobloxBase(LClose);
        CallBinTMAddr = syn::RobloxBase(VMBinTM);
        LessThanAddr = syn::RobloxBase(VLessTh);
        LessEqualAddr = syn::RobloxBase(VLessEq);
        VEqualValAddr = syn::RobloxBase(VEqualV);
        HResizeArrayAddr = syn::RobloxBase(ReSzArr);
        HSetNumAddr = syn::RobloxBase(VHSetNum);
        HNewAddr = syn::RobloxBase(LuaHNew);
        HGetNAddr = syn::RobloxBase(LuaGetN);
        DPreCallAddr = syn::RobloxBase(PreCall);
        DPreCallUAddr = syn::RobloxBase(PreCallU);
        DGrowStkAddr = syn::RobloxBase(GrowStk);
        DPosCallAddr = syn::RobloxBase(PosCall);
        DCallAddr = syn::RobloxBase(LDCall);
        CStepAddr = syn::RobloxBase(LCStep);
        CBarRFAddr = syn::RobloxBase(BarRF);
		VGetNameCallAddr = syn::RobloxBase(VGetNameCall);
		RLuaNilObject = syn::RobloxBase(LSNilObject);

		VGetTableAddr = GetBinValue(FNVA1_CONSTEXPR("luav_gettable"));
		VSetTableAddr = GetBinValue(FNVA1_CONSTEXPR("luav_settable"));

		/* Setup static addresses */
		DXorKey = GetBinValue(FNVA1_CONSTEXPR("XorConstant"));

		uint64_t OriginalMiniDump;
		MEMORY_BASIC_INFORMATION PolyMBI{};

		PLH::x86Detour MiniDumpHookObj((char*)MiniDumpPointer, (char*)&CallcheckProxy, &OriginalMiniDump, x86Disasm);
		if (!MiniDumpHookObj.hook())
			throw std::exception((std::string(OBFUSCATE_STR("PolyHook - Fail 4 ")) + PLH::ErrorLog::singleton().pop().msg).c_str());
		if (!VirtualQuery((LPVOID) OriginalMiniDump, &PolyMBI, sizeof PolyMBI))
			throw std::exception(OBFUSCATE_STR("Poly VQ - Fail 4"));

		syn::SysHook::ProtectedMemory::GetSingleton()->Add((uintptr_t) PolyMBI.BaseAddress, PolyMBI.RegionSize);

        VM_TIGER_WHITE_END;
    }

    int RbxLua::PCall(int nargs, int nresults, int nhandler) const
    {
        DWORD exceptionChain = __readfsdword(0);
        EXCEPTION_REGISTRATION_RECORD* exrecord = reinterpret_cast<EXCEPTION_REGISTRATION_RECORD*>(exceptionChain);
        EXCEPTION_REGISTRATION_RECORD backrecord[2] = { exrecord[0], exrecord[1] };
        exrecord[0].Handler = ExceptionRoutine;
        exrecord[1].Handler = ExceptionRoutine;
        R_LUA_CALL(int, LPcall, CCLPcall, RState, nargs, nresults, nhandler);
        exrecord[0].Handler = backrecord[0].Handler;
        exrecord[1].Handler = backrecord[1].Handler;
        return Ret;
    }

    void* RbxLua::Realloc(void* block, size_t osize, size_t nsize, int mode) const
    {
        R_LUA_RETCALL(void*, LMalloc, CCLMalloc, RState, block, osize, nsize, mode);
    }

	void* RbxLua::Alloc(size_t size, int mode) const
	{
        return Realloc(NULL, 0, size, mode);
	}

	int RbxLua::Error() const
    {
        R_LUA_RETCALL(int, LRError, CCLRError, RState);
    }

    int RbxLua::LError(const char* fmt, ...) const
    {
        /* Sorry about this */
        constexpr size_t BuffSz = 512; /* short_src[256], shouldn't be a problem */
        char TraceStr[BuffSz]{};
        char ErrStr[BuffSz]{};
        char FinalStr[(BuffSz * 2) + 1]{};

        va_list argp;
        va_start(argp, fmt);

        /*  luaL_where(L, 1); */
        /* --- luaL_where --- */
        int level = 1;
        lua_Debug ar;
        if (GetStack(level, &ar)) {  /* check function at level */
            GetInfo("Sl", &ar);  /* get info about it */
            if (ar.currentline > 0) {  /* is there info? */
                sprintf_s(TraceStr, "%s:%d: ", ar.short_src, ar.currentline);
            }
        }
        { } /* else, no information available... */
        /* --- luaL_where --- */

        vsnprintf(ErrStr, BuffSz, fmt, argp);
        va_end(argp);

        strcpy_s(FinalStr, TraceStr);
        strcat_s(FinalStr, ErrStr);

        PushString(FinalStr);

        return Error();
    }

    int RbxLua::ArgError(int narg, const char *extramsg) const
    {
        lua_Debug ar;
        if (!GetStack(0, &ar))  /* no stack frame? */
            return LError("bad argument #%d (%s)", narg, extramsg);
        GetInfo("n", &ar);
        if (strcmp(ar.namewhat, "method") == 0) {
            narg--;  /* do not count `self' */
            if (narg == 0)  /* error is in the self argument itself? */
                return LError("calling " LUA_QS " on bad self (%s)",
                    ar.name, extramsg);
        }
        if (ar.name == NULL)
            ar.name = "?";
        return LError("bad argument #%d to " LUA_QS " (%s)",
            narg, ar.name, extramsg);
    }

    int RbxLua::TypeError(int narg, const char* tname) const
    {
        char buff[256];
        sprintf_s(buff, "%s expected, got %s", tname, TypeName(Type(narg)));
        PushString(buff);
        return ArgError(narg, buff);
    }

    void RbxLua::TagError(int narg, int tag) const
    {
        /* TypeError should be marked as [[maybe_unused]] for internal use, however
         * attribute use is a little weird on the current MSVC release */
        UNUSED(TypeError(narg, TypeName(tag)));
    }

    void RbxLua::GTypeError(const TValue* o, const char* op) const
    {
        ((void(__cdecl*)(uintptr_t, const TValue*, const char*))GTypeErrAddr)(RState, o, op);
    }

    void RbxLua::GRunError(const char* fmt, ...) const
    {
        char buf[256]; /* TODO: >_> */
        va_list args;
        va_start(args, fmt);
        vsprintf_s(buf, fmt, args);
        va_end(args);

        ((void(__cdecl*)(uintptr_t, const char*))GRunErrAddr)(RState, buf);
    }

    TValue* RbxLua::Index2Adr(int idx) const
    {
		if (idx >= 0)
		{
			auto StkObj = (uintptr_t)luaO_nilobject;
			if ((unsigned int) (16 * idx + *(uintptr_t*)(RState + L_BASE) - 16) < *(uintptr_t*)(RState + L_TOP))
				StkObj = 16 * idx + *(uintptr_t*)(RState + L_BASE) - 16;

			return (TValue*) StkObj;
		}

        R_LUA_RETCALL(TValue*, LIndex2Adr, CCLIndex2Adr, RState, idx);
    }

    int RbxLua::Type(int idx) const
    {
        StkId o = Index2Adr(idx);
        return (o == luaO_nilobject || o == (TValue*) RLuaNilObject) ? R_LUA_TNONE : ttype(o);
    }

    const char* RbxLua::TypeName(int t) const
    {
        switch (t) {
        case R_LUA_TNONE:
            return "no value";
        case R_LUA_TNIL:
            return "nil";
        case R_LUA_TUSERDATA:
        case R_LUA_TLIGHTUSERDATA:
            return "userdata";
        case R_LUA_TNUMBER:
            return "number";
        case R_LUA_TBOOLEAN:
            return "boolean";
        case R_LUA_TSTRING:
            return "string";
        case R_LUA_TTHREAD:
            return "thread";
        case R_LUA_TFUNCTION:
            return "function";
        case R_LUA_TTABLE:
            return "table";
        case R_LUA_TPROTO:
            return "proto";
        case R_LUA_TUPVAL:
            return "upval";
        default:
            return "no value";
        }
    }

    int RbxLua::ObjLen(int idx) const
    {
        StkId o = Index2Adr(idx);
        switch (ttype(o)) {
            case LUA_TSTRING: return RawSLen(rawtsvalue(o));
            case LUA_TUSERDATA: return 0; // uvalue(o)->len; TODO: Is there a use case for this?
            case LUA_TTABLE: return HGetN(hvalue(o));
            case LUA_TNUMBER: return VToString(o)? RawSLen(rawtsvalue(o)) : 0;
            default: return 0;
        }
    }

    void RbxLua::PushValue(int idx) const
    {
        r_setobj(RState, *(TValue**)(RState + L_TOP), (TValue*)Index2Adr(idx));
        r_incr_top(RState);
    }

    void RbxLua::PushNil() const
    {
        r_setnilvalue(*(TValue**)(RState + L_TOP));
        r_incr_top(RState);
    }

	void RbxLua::PushThread() const
	{
		r_setthvalue(*(TValue**)(RState + L_TOP), RState);
		r_incr_top(RState);
	}

    void RbxLua::PushBoolean(bool b) const
    {
        r_setbvalue(*(TValue**)(RState + L_TOP), b != 0);
        r_incr_top(RState);
    }

    void RbxLua::PushNumber(lua_Number n) const
    {
        r_setnvalue(*(TValue**)(RState + L_TOP), XorDouble(n));
        r_incr_top(RState);
    }

    void RbxLua::PushInteger(lua_Integer n) const
    {
        lua_Number conv = cast_num(n);
        r_setnvalue(*(TValue**)(RState + L_TOP), XorDouble(conv));
        r_incr_top(RState);
    }

    void RbxLua::PushLString(const char* s, size_t len) const
    {
        r_setsvalue(*(TValue**)(RState + L_TOP), NewLString(s, len));
        r_incr_top(RState);
    }

    uintptr_t RbxLua::NewLString(const char* str, size_t l) const
    {
        R_LUA_RETCALL(uintptr_t, LNewLStr, CCLNewLStr, RState, str, l);
    }

    void RbxLua::PushString(const char* s) const
    {
        if (s == NULL)
            PushNil();
        else
            PushLString(s, strlen(s));
    }

    void RbxLua::PushLightUserData(void* p) const
    {
        r_setpvalue(*(TValue**)(RState + L_TOP), p);
        r_incr_top(RState);
    }

    void RbxLua::PushCClosure(r_lua_CFunction cf, int nups) const
    {
        R_LUA_VOIDCALL(LPushCClosure, CCLPushCClosure, RState, (int) cf, nups);
    }

    void RbxLua::VGetTable(const TValue* t, TValue* key, StkId val) const
    {
		((void(__cdecl*)(uintptr_t, const TValue*, const TValue*, StkId, int))VGetTableAddr)(RState, t, key, val, 1);
    }

    void RbxLua::VSetTable(const TValue* t, TValue* key, StkId val) const
    {
		((void(__cdecl*)(uintptr_t, const TValue*, const TValue*, StkId))VSetTableAddr)(RState, t, key, val);
    }

	uintptr_t RbxLua::VNameCall(StkId b) const
	{
		return ((uintptr_t(__cdecl*)(uintptr_t, StkId))VGetNameCallAddr)(RState, b);
	}

    void RbxLua::GetField(int idx, const char* k) const
    {
        StkId t;
        TValue key;
        t = Index2Adr(idx);
        r_setsvalue(&key, SNew(k));
        VGetTable(t, &key, *(TValue **)(RState + L_TOP));
        r_incr_top(RState);
    }

    void RbxLua::SetField(int idx, const char* k) const
    {
        StkId t;
        TValue key;
        t = Index2Adr(idx);
        r_setsvalue(&key, SNew(k));
        VSetTable(t, &key, *(TValue**)(RState + L_TOP) - 1);
        r_decr_top(RState);  /* pop value */
    }

    int RbxLua::GetTop() const
    {
        return (int)(*(TValue**)(RState + L_TOP) - *(TValue**)(RState + L_BASE));
    }

    void RbxLua::SetTop(int idx) const
    {
        if (idx >= 0) {
            while (*(TValue**)(RState + L_TOP) < *(TValue**)(RState + L_BASE) + idx)
                r_setnilvalue((*(TValue**)(RState + L_TOP))++);
            *(TValue**)(RState + L_TOP) = *(TValue**)(RState + L_BASE) + idx;
        }
        else
            *(TValue**)(RState + L_TOP) += idx + 1;
    }

    void* RbxLua::ToUserData(int idx) const
    {
        TValue* o = (TValue*)Index2Adr(idx);
        switch (ttype(o))
        {
          case R_LUA_TUSERDATA: return (void*) (*(uintptr_t*)(uintptr_t) o + 16);
          case R_LUA_TLIGHTUSERDATA: return pvalue(o);
          default: return NULL;
        }
    }

    uintptr_t RbxLua::ToPointer(int idx) const
    {
        R_LUA_RETCALL(uintptr_t, LToPointer, CCLToPointer, RState, idx);
    }

    int RbxLua::GetMetaTable(int idx) const
    {
        R_LUA_RETCALL(int, LGetMetaTable, CCLGetMetaTable, RState, idx);
    }

    bool RbxLua::ToBoolean(int idx) const
    {
        const TValue* o = Index2Adr(idx);
        return !((o)->tt == R_LUA_TNIL || ((o)->tt == R_LUA_TBOOLEAN && (o)->value.b == 0));
    }

    lua_Number RbxLua::ToNumber(int idx) const
    {
        TValue n;
        const TValue* o = Index2Adr(idx);
        if (r_tonumber(this, o, &n))
        {
            lua_Number no = nvalue(o);
            return XorDouble(no);
        }
        else
            return 0;
    }

    lua_Integer RbxLua::ToInteger(int idx) const
    {
        TValue n;
        const TValue* o = Index2Adr(idx);

        /* No encryption is needed when dealing with string conversion */
        bool doConvert = ttype(o) != R_LUA_TSTRING;
        if (r_tonumber(this, o, &n))
        {
            lua_Integer res;
            lua_Number num = nvalue(o);
            num = doConvert ? XorDouble(num) : num;

            lua_number2integer(res, num);
            return res;
        }
        else
            return 0;
    }

    void RbxLua::SetupThread() const
    {
        R_LUA_VOIDCALL(LSetupThread, CCLSetupThread, RState);
    }

    void RbxLua::SetIdentity(BYTE ctx) const
    {
        uintptr_t* v3 = (uintptr_t*)(RState - 40);
        *v3 ^= (ctx ^ (unsigned __int8)*v3) & 0x1F;
    }

    int RbxLua::Ref(int t) const
    {
        int ref;
        t = (t > 0 || t <= LUA_REGISTRYINDEX)? (t) : GetTop() + t + 1;
        if (Type(-1)) {
            Pop(1);  /* remove from stack */
            return LUA_REFNIL;  /* `nil' has a unique fixed reference */
        }
        RawGetI(t, 0);  /* get first free element */
        ref = (int)ToInteger(-1);  /* ref = t[FREELIST_REF] */
        Pop(1);  /* remove it from stack */
        if (ref != 0) {  /* any free element? */
            RawGetI(t, ref);  /* remove it from list */
            RawSetI(t, 0);  /* (t[FREELIST_REF] = t[ref]) */
        }
        else {  /* no free elements */
            ref = (int)ObjLen(t);
            ref++;  /* create new reference */
        }
        RawSetI(t, ref);

        return ref;
    }

    void RbxLua::RawGetI(int Index, int N) const
    {
        R_LUA_VOIDCALL(LRawGetI, CCLRawGetI, RState, Index, N);
    }

    void syn::RbxLua::RawSetI(int idx, int n) const
    {
        StkId o;
        o = Index2Adr(idx);
        r_setobj(RState, HSetNum(hvalue(o), n), *(TValue**)(RState + L_TOP) - 1);
        CBarrier((uintptr_t)hvalue(o), (uintptr_t)(*(TValue**)(RState + L_TOP) - 1));
        r_decr_top(RState);
    }

    void RbxLua::XMove(RbxLua To, int N) const
    {
        if (RState == To.RState) return;

        *(TValue**)(RState + L_TOP) -= N;
        for (int i = 0; i < N; i++)
        {
            setobj2s(To.RState, (*(TValue**)(To.RState + L_TOP))++, (*(TValue**)(RState + L_TOP)) + i);
        }
    }

    void RbxLua::Insert(int idx) const
    {
        StkId p;
        StkId q;
        p = Index2Adr(idx);
        for (q = *(TValue**)(RState + L_TOP); q > p; q--) setobjs2s(L, q, q - 1);
        r_setobj(RState, p, *(TValue**)(RState + L_TOP));
    }

    void RbxLua::Remove(int idx) const
    {
        StkId p = Index2Adr(idx);
        while (++p < *(TValue**)(RState + L_TOP)) r_setobj(rL, p - 1, p);
        r_decr_top(RState);
    }

    int RbxLua::Next(int idx) const
    {
        R_LUA_RETCALL(int, LNext, CCLNext, RState, idx);
    }

    int RbxLua::GetMetaField(int obj, const char* e) const
    {
        R_LUA_RETCALL(int, LGetMetaField, CCLGetMetaField, RState, obj, e);
    }

    int RbxLua::RYield(int nresults) const
    {
        R_LUA_RETCALL(int, LYield, CCLYield, RState, nresults);
    }

    void RbxLua::VConcat(int total, int last) const
    {
        ((int(__cdecl*)(uintptr_t, int, int))VConcatAddr)(RState, total, last);
    }

    void RbxLua::VArith(StkId ra, const TValue* rb, const TValue* rc, int op) const
    {
        ((void(__cdecl*)(uintptr_t, StkId, const TValue*, const TValue*, int))VArithAddr)(RState, ra, rb, rc, op);
    }

    UpVal* RbxLua::FFindUpval(StkId level) const
    {
        return ((UpVal*(__cdecl*)(uintptr_t, StkId))FFindUpvalAddr)(RState, level);
    }

    void RbxLua::FClose(StkId level) const
    {
        ((void(__cdecl*)(uintptr_t, StkId))FCloseAddr)(RState, level);
    }

    int RbxLua::CallBinTM(const TValue* p1, const TValue* p2, StkId res, int event) const
    {
        return ((int(__cdecl*)(uintptr_t, const TValue*, const TValue*, StkId, int))CallBinTMAddr)(RState, p1, p2, res, event);
    }

    int RbxLua::LessThan(const TValue* l, const TValue* r) const
    {
        return ((int(__cdecl*)(uintptr_t, const TValue*, const TValue*))LessThanAddr)(RState, l, r);
    }

    int RbxLua::LessEqual(const TValue* l, const TValue* r) const
    {
        return ((int(__cdecl*)(uintptr_t, const TValue*, const TValue*))LessEqualAddr)(RState, l, r);
    }

    int RbxLua::VEqualVal(const TValue* t1, const TValue* t2) const
    {
        return ((int(__cdecl*)(uintptr_t, const TValue*, const TValue*))VEqualValAddr)(RState, t1, t2);
    }

    void RbxLua::HResizeArray(Table* t, int nasize) const
    {
        ((void(__cdecl*)(uintptr_t, Table*, int))HResizeArrayAddr)(RState, t, nasize);
    }

    TValue* RbxLua::HSetNum(Table* t, int key) const
    {
        return ((TValue*(__cdecl*)(uintptr_t, Table*, int))HSetNumAddr)(RState, t, key);
    }	

	int RbxLua::DCall(StkId func, int nResults) const
	{
		return ((int(__cdecl*)(uintptr_t, StkId, int))DCallAddr)(RState, func, nResults);
	}

    int RbxLua::DPreCall(StkId ra, int nresults) const
    {
        return syn::SpoofCall<int>(CallingConvention::CDECL, (void*)DPreCallAddr, RState, ra, nresults);
    }

    int RbxLua::DPreCallU(StkId ra, int nresults) const
    {
        return ((int(__cdecl*)(uintptr_t, StkId, int))DPreCallUAddr)(RState, ra, nresults);
    }

    int RbxLua::DPosCall(StkId ra) const
    {
        return ((int(__cdecl*)(uintptr_t, StkId))DPosCallAddr)(RState, ra);
    }

    void RbxLua::DGrowStk(int n) const
    {
        ((void(__cdecl*)(uintptr_t, int))DGrowStkAddr)(RState, n);
    }

    void RbxLua::CreateTable(int narray, int nrec) const
    {
        CheckGC();
        r_sethvalue(*(TValue**)(RState + L_TOP), HNew(narray, nrec));
        r_incr_top(RState);
    }

    uintptr_t RbxLua::NewLClosure(int nups, int maxstacksize, uintptr_t e) const
    {
        uintptr_t lc = (uintptr_t)Alloc(4 * nups + 24, 4);
        SecureZeroMemory((void*) lc, 4 * nups + 24);
        LinkGC(lc, R_LUA_TFUNCTION);
        *(uintptr_t*)(lc + LCL_ENV) = e; /* cl->env */
        *(lu_byte*)(lc + LCL_NUPVALS) = cast(lu_byte, nups); /* p->nups */
		*(lu_byte*)(lc + LCL_MAXSTACKSIZE) = cast(lu_byte, maxstacksize); /* p->maxstacksize */

        return lc;
    }

    uintptr_t RbxLua::NewProto() const
    {
        uintptr_t P = (uintptr_t)Alloc(84, 6);
        SecureZeroMemory((void*)P, 84);
        LinkGC(P, R_LUA_TPROTO);

        return P;
    }

    uintptr_t RbxLua::HNew(int narray, int nhash) const
    {
        return ((uintptr_t(__cdecl*)(uintptr_t, int, int))HNewAddr)(RState, narray, nhash);
    }

    void RbxLua::SetTable(int idx) const
    {
        StkId t;
        lua_lock(L);
        t = Index2Adr(idx);
        VSetTable(t, *(TValue **)(RState + L_TOP) - 2, *(TValue **)(RState + L_TOP) - 1);
        *(TValue **)(RState + L_TOP) -= 2;  /* pop index and value */
    }

    int RbxLua::SetMetaTable(int objindex) const
    {
        R_LUA_RETCALL(int, LSetMetaTable, CCLSetMetaTable, RState, objindex);
    }

    void RbxLua::GetTable(int idx) const
    {
        StkId t;
        lua_lock(L);
        t = Index2Adr(idx);
        VGetTable(t, *(TValue **)(RState + L_TOP) - 1, *(TValue **)(RState + L_TOP) - 1);
    }

    int RbxLua::GetStack(int level, lua_Debug* ar) const
    {
        R_LUA_RETCALL(int, LGetStack, CCLGetStack, RState, level, ar);
    }

    int RbxLua::GetInfo(const char* what, lua_Debug* ar) const
    {
        R_LUA_RETCALL(int, LGetInfo, CCLGetInfo, RState, what, ar);
    }

    int RbxLua::HGetN(Table* t) const
    {
        return ((int(__cdecl*)(Table*))HGetNAddr)(t);
    }

    const char* RbxLua::GetLocal(lua_Debug* ar, int n) const
    {
        R_LUA_RETCALL(const char*, LGetLocal, CCLGetLocal, RState, (const lua_Debug*)ar, n);
    }

    const char* RbxLua::SetLocal(lua_Debug* ar, int n) const
    {
        R_LUA_RETCALL(const char*, LSetLocal, CCLSetLocal, RState, (const lua_Debug*)ar, n);
    }

    const char* RbxLua::GetUpvalue(int idx, int n) const
    {
        R_LUA_RETCALL(const char*, LGetUpvalue, CCLGetUpvalue, RState, idx, n);
    }

    const char* RbxLua::SetUpvalue(int idx, int n) const
    {
        R_LUA_RETCALL(const char*, LSetUpvalue, CCLSetUpvalue, RState, idx, n);
    }

    DWORD RbxLua::GetIdentity() const
    {
		return *(BYTE*)(RState - 40) & 0x1F;
    }

	RbxLua RbxLua::NewThread(BOOL DoPop) const
	{
		R_LUA_CALL(uintptr_t, LNewThread, CCLNewThread, RState);
		if (DoPop) Pop(1);
		return Ret;
	}

    const char* RbxLua::ToLString(int idx, size_t* len) const
    {
        StkId o = Index2Adr(idx);
        if (ttype(o) != R_LUA_TSTRING) {
            if (!VToString(o)) {  /* conversion failed? */
                if (len != NULL)* len = 0;
                return NULL;
            }
            CheckGC();
            o = Index2Adr(idx);  /* previous call may reallocate the stack */
        }
        if (len != NULL) *len = RawSLen(rawtsvalue(o));
        return GetStr(rawtsvalue(o));
    }

    void RbxLua::PushCFunction(r_lua_CFunction cf)
    {
        return syn::RbxLua::_PushCFunction(this, cf);
    }

	int LambdaWrap(uintptr_t rL)
    {
		syn::RbxLua NRL(rL);

		return (*(std::function<int(uintptr_t)>*)NRL.ToUserData((uintptr_t)lua_upvalueindex(2)))(rL);
    }

	void RbxLua::PushLambda(std::function<int(uintptr_t)> lam)
    {
		syn::RbxLua RL(RState);

    	const auto CC = new SynCClosure();
        
		const auto Copied = new std::function<int(uintptr_t)>(std::move(lam));

		CC->Address = (uintptr_t)&LambdaWrap;
		CC->ExtraSpace = 0;
		RL.PushLightUserData(CC);
		RL.PushLightUserData(Copied);
		RL.PushCClosure(CallcheckHook, 2);
    }

	void RbxLua::CreateCClosure(int upvalues)
    {
        return syn::RbxLua::_PushCClosure(this, upvalues);
    }

    void RbxLua::PushObject(const TValue* o) const
    {
        r_setobj(RState, *(TValue**)(RState + L_TOP), o);
        r_incr_top(RState);
    }

    void RbxLua::PushRawObject(uintptr_t o, int type) const
    {
        StkId& Top = *(StkId*)(RState + L_TOP);
        Top->tt = type;
        Top->value.p = (void*)o;
        r_incr_top(RState);
    }

    int RbxLua::RawSLen(TString* ts) const
    {
        return syn::PointerObfuscation::DeObfuscateStringLen((uintptr_t)ts + STR_LEN);
    }

	void RbxLua::LinkGC(uintptr_t GCObject, BYTE Type) const
	{
        uintptr_t GS = syn::PointerObfuscation::DeObfuscateGlobalState(RState + L_GS);
		auto& Root = *(uintptr_t*)(GS + G_ROOTGC);

		*(uintptr_t*)GCObject = Root;
		Root = GCObject;

		*(BYTE*)(GCObject + GCO_MARKED) = *(BYTE*)(GS + G_WMASK) & 3;
		*(BYTE*)(GCObject + GCO_TT) = Type;
	}

    void RbxLua::CStep() const
    {
        ((void(__cdecl*)(uintptr_t))CStepAddr)(RState);
    }

	void RbxLua::CBarRF(uintptr_t o, uintptr_t v) const
	{
		((void(__cdecl*)(uintptr_t, uintptr_t, uintptr_t))CBarRFAddr)(RState, o, v);
	}

    void RbxLua::CheckGC() const
    {
		/* TODO: Revert this to Eternal's once speed issue is fixed (smh) */
		if (*(uintptr_t*)(*(uintptr_t*)(RState + 12) - (RState + 12) + 80) >= *(uintptr_t*)(*(uintptr_t*)(RState + 12) - (RState + 12) + 92))
			CStep();
    }

    void RbxLua::CBarrierT(uintptr_t hval, uintptr_t tval) const
    {
        /* iscollectable */
        if (*(uintptr_t*)(tval + 8) >= 4)
        {
            /* valiswhite */
            if (*(BYTE*)(*(uintptr_t*)tval + 4) & 3)
            {
                /* isblack */
                BYTE Marked = *(BYTE*)(hval + 4);
                if (Marked & 4)
                {
                    uintptr_t GS = syn::PointerObfuscation::DeObfuscateGlobalState(RState + L_GS);
                    *(BYTE*)(hval + 4) = Marked & ~bitmask(BLACKBIT);

					/* TODO: Note: the hval + 20 offset can update too - be careful! */
                    *(uintptr_t*)(hval + T_GCLIST) = *(uintptr_t*)(GS + G_GRAYAGAIN); /* gS->greyagain */
                    *(uintptr_t*)(GS + G_GRAYAGAIN) = hval;
                }
            }
        }
    }

    void RbxLua::CBarrier(uintptr_t o, uintptr_t v) const
    {
        if (*(uintptr_t*)(v + 8) >= 4 && *(BYTE*)(*(uintptr_t*)v + 4) & 3 && *(BYTE*)(o + 4) & 4)
            CBarRF(o, *(uintptr_t*)v);
    }

	int RbxLua::LTypeToRType(int LType)
	{
		switch (LType)
		{
			case LUA_TNIL:
				return R_LUA_TNIL;
			case LUA_TUSERDATA:
				return R_LUA_TUSERDATA;
			case LUA_TNUMBER:
				return R_LUA_TNUMBER;
			case LUA_TBOOLEAN:
				return R_LUA_TBOOLEAN;
			case LUA_TSTRING:
				return R_LUA_TSTRING;
			case LUA_TTHREAD:
				return R_LUA_TTHREAD;
			case LUA_TFUNCTION:
				return R_LUA_TFUNCTION;
			case LUA_TTABLE:
				return R_LUA_TTABLE;
			case LUA_TLIGHTUSERDATA:
				return R_LUA_TLIGHTUSERDATA;
			case LUA_TPROTO:
				return R_LUA_TPROTO;
			case LUA_TUPVAL:
				return R_LUA_TUPVAL;
			default:
				return R_LUA_TNONE;
		}
	}

	int RbxLua::RTypeToLType(int LType)
	{
		switch (LType)
		{
			case R_LUA_TNIL:
				return LUA_TNIL;
			case R_LUA_TUSERDATA:
				return LUA_TUSERDATA;
			case R_LUA_TNUMBER:
				return LUA_TNUMBER;
			case R_LUA_TBOOLEAN:
				return LUA_TBOOLEAN;
			case R_LUA_TSTRING:
				return LUA_TSTRING;
			case R_LUA_TTHREAD:
				return LUA_TTHREAD;
			case R_LUA_TFUNCTION:
				return LUA_TFUNCTION;
			case R_LUA_TTABLE:
				return LUA_TTABLE;
			case R_LUA_TLIGHTUSERDATA:
				return LUA_TLIGHTUSERDATA;
			case R_LUA_TPROTO:
				return LUA_TPROTO;
			case R_LUA_TUPVAL:
				return LUA_TUPVAL;
			default:
				return LUA_TNONE;
		}
	}

    bool RbxLua::IsCFunction(int idx) const
    {
        StkId o = Index2Adr(idx);
        return ttype(o) == R_LUA_TFUNCTION && clvalue(o)->c.isC;
    }

    bool RbxLua::IsNumber(int idx) const
    {
        TValue n;
        const TValue* o = Index2Adr(idx);
        return ttype(o) == LUA_TNUMBER || (((o) = VToNumber(o, &n)) != NULL);
    }

    bool RbxLua::IsString(int idx) const
    {
        int t = Type(idx);
        return (t == R_LUA_TSTRING || t == R_LUA_TNUMBER);
    }

    bool RbxLua::IsUserData(int idx) const
    {
        const TValue* o = Index2Adr(idx);
        return (ttype(o) == R_LUA_TUSERDATA || ttype(o) == R_LUA_TLIGHTUSERDATA);
    }

    void RbxLua::CheckType(int narg, int t) const
    {
        if (Type(narg) != t)
            TagError(narg, t);
    }

    void RbxLua::CheckAny(int narg) const
    {
        if (Type(narg) == R_LUA_TNONE)
            ArgError(narg, "value expected");
    }

    const char* RbxLua::CheckLString(int narg, size_t * len) const
    {
        const char* s = ToLString(narg, len);
        if (!s) TagError(narg, R_LUA_TSTRING);
        return s;
    }

    const char* RbxLua::OptLString(int narg, const char* def, size_t * len) const
    {
        if (IsNoneOrNil(narg)) {
            if (len)
                *len = (def ? strlen(def) : 0);
            return def;
        }
        else return CheckLString(narg, len);
    }

    lua_Number RbxLua::CheckNumber(int narg) const
    {
        lua_Number d = ToNumber(narg);
        if (d == 0 && !IsNumber(narg))  /* avoid extra test when d is not 0 */
            TagError(narg, R_LUA_TNUMBER);

        return d;
    }

    lua_Number RbxLua::OptNumber(int narg, lua_Number def) const
    {
        return IsNoneOrNil(narg) ? def : CheckNumber(narg);
    }

    lua_Integer RbxLua::CheckInteger(int narg) const
    {
        lua_Integer d = ToInteger(narg);
        if (d == 0 && !IsNumber(narg))  /* avoid extra test when d is not 0 */
            TagError(narg, R_LUA_TNUMBER);

        return d;
    }

    lua_Integer RbxLua::OptInteger(int narg, lua_Integer def) const
    {
        return IsNoneOrNil(narg) ? def : CheckInteger(narg);
    }

    /* LocalScript state */
    uintptr_t RbxLua::GlobalState(uintptr_t RS)
	{
		static uintptr_t GState = 0;
		if (RS) GState = RS;
		return GState;
	}

	RbxLua::RbxLua(uintptr_t RS)
	{
        RState = RS;
	}
}
