
/*
*
*	SYNAPSE X
*	File.:	RbxOp.hpp
*	Desc.:	Roblox obfuscation ("encryption") solutions
*
*/

#pragma once
#pragma warning(disable: 4554)

#include "../../Misc/Static.hpp"
#include "../../../Utilities/Obfuscation/ObfuscatedNumber.hpp"

#define STORE_OP(L, R) (((L) << SIZE_OP) + (R))

#define ReadROpcode(n) (opcodes[(n)] & MASK1(SIZE_OP, 0))
#define ReadLOpcode(n) (opcodes[(n)] >> SIZE_OP)
inline int opcodes[NUM_OPCODES]
{
    STORE_OP(OP_LOADBOOL,  0x06 /* OP_MOVE      */),
    STORE_OP(OP_GETTABLE,  0x04 /* OP_LOADK     */),
    STORE_OP(OP_GETUPVAL,  0x00 /* OP_LOADBOOL  */),
    STORE_OP(OP_SETGLOBAL, 0x07 /* OP_LOADNIL   */),
    STORE_OP(OP_LOADK,     0x02 /* OP_GETUPVAL  */),
    STORE_OP(OP_SETUPVAL,  0x08 /* OP_GETGLOBAL */),
    STORE_OP(OP_MOVE,      0x01 /* OP_GETTABLE  */),
    STORE_OP(OP_LOADNIL,   0x03 /* OP_SETGLOBAL */),
    STORE_OP(OP_GETGLOBAL, 0x05 /* OP_SETUPVAL  */),
    STORE_OP(OP_SELF,      0x0F /* OP_SETTABLE  */),
    STORE_OP(OP_DIV,       0x0D /* OP_NEWTABLE  */),
    STORE_OP(OP_SUB,       0x09 /* OP_SELF      */),
    STORE_OP(OP_MOD,       0x10 /* OP_ADD       */),
    STORE_OP(OP_NEWTABLE,  0x0B /* OP_SUB       */),
    STORE_OP(OP_POW,       0x11 /* OP_MUL       */),
    STORE_OP(OP_SETTABLE,  0x0A /* OP_DIV       */),
    STORE_OP(OP_ADD,       0x0C /* OP_MOD       */),
    STORE_OP(OP_MUL,       0x0E /* OP_POW       */),
    STORE_OP(OP_LEN,       0x18 /* OP_UNM       */),
    STORE_OP(OP_LT,        0x16 /* OP_NOT       */),
    STORE_OP(OP_JMP,       0x12 /* OP_LEN       */),
    STORE_OP(OP_LE,        0x19 /* OP_CONCAT    */),
    STORE_OP(OP_NOT,       0x14 /* OP_JMP       */),
    STORE_OP(OP_TEST,      0x1A /* OP_EQ        */),
    STORE_OP(OP_UNM,       0x13 /* OP_LT        */),
    STORE_OP(OP_CONCAT,    0x15 /* OP_LE        */),
    STORE_OP(OP_EQ,        0x17 /* OP_TEST      */),
    STORE_OP(OP_TAILCALL,  0x21 /* OP_TESTSET   */),
    STORE_OP(OP_TFORLOOP,  0x1F /* OP_CALL      */),
    STORE_OP(OP_FORLOOP,   0x1B /* OP_TAILCALL  */),
    STORE_OP(OP_SETLIST,   0x22 /* OP_RETURN    */),
    STORE_OP(OP_CALL,      0x1D /* OP_FORLOOP   */),
    STORE_OP(OP_CLOSE,     0x23 /* OP_FORPREP   */),
    STORE_OP(OP_TESTSET,   0x1C /* OP_TFORLOOP  */),
    STORE_OP(OP_RETURN,    0x1E /* OP_SETLIST   */),
    STORE_OP(OP_FORPREP,   0x20 /* OP_CLOSE     */),
    STORE_OP(OP_VARARG,    0x25 /* OP_CLOSURE   */),
    STORE_OP(OP_CLOSURE,   0x24 /* OP_VARARG    */),
};

#define RPOS_OP		(RPOS_A + SIZE_A)
#define RPOS_A	    (RPOS_C + SIZE_C)
#define RPOS_C		(RPOS_B + SIZE_B)
#define RPOS_B		0
#define RPOS_Bx		0

#define RGET_OPCODE(i)	(((i)>>RPOS_OP) & MASK1(SIZE_OP,0))
#define RSET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,RPOS_OP)) | \
		((cast(Instruction, o)<<RPOS_OP)&MASK1(SIZE_OP,RPOS_OP))))

#define RGETARG_A(i)	(cast(int, ((i)>>RPOS_A) & MASK1(SIZE_A,0)))
#define RSETARG_A(i,u)	((i) = (((i)&MASK0(SIZE_A,RPOS_A)) | \
		((cast(Instruction, u)<<RPOS_A)&MASK1(SIZE_A,RPOS_A))))

#define RGETARG_B(i)	(cast(int, ((i)>>RPOS_B) & MASK1(SIZE_B,0)))
#define RSETARG_B(i,b)	((i) = (((i)&MASK0(SIZE_B,RPOS_B)) | \
			((cast(Instruction, b)<<RPOS_B)&MASK1(SIZE_B,RPOS_B))))

#define RGETARG_C(i)	(cast(int, ((i)>>RPOS_C) & MASK1(SIZE_C,0)))
#define RSETARG_C(i,b)	((i) = (((i)&MASK0(SIZE_C,RPOS_C)) | \
			((cast(Instruction, b)<<RPOS_C)&MASK1(SIZE_C,RPOS_C))))

#define RGETARG_Bx(i)	(cast(int, ((i)>>RPOS_Bx) & MASK1(SIZE_Bx,0)))
#define RSETARG_Bx(i,b)	((i) = (((i)&MASK0(SIZE_Bx,RPOS_Bx)) | \
			((cast(Instruction, b)<<RPOS_Bx)&MASK1(SIZE_Bx,RPOS_Bx))))

#define RGETARG_sBx(i)	(RGETARG_Bx(i)-MAXARG_sBx)
#define RSETARG_sBx(i,b) RSETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))

namespace syn
{
    class InstructionTranslator final
    {
    public:
        unsigned int EncodeKey;
        unsigned int DecodeKey;

        static __forceinline Instruction RetEncrypt(Instruction inst, uint32_t pc)
        {
            uint32_t res = 0;

            for (uint32_t mask = 1; mask; mask <<= 1)
            {
                uint32_t x = res * pc - OBFUSCATED_NUM(0x541B9F);
                uint32_t y = res * (pc + OBFUSCATED_NUM(0x1F3D8AF)) - OBFUSCATED_NUM(0x1C0BCC3);

                if ((mask & (x ^ y)) != (mask & inst))
                    res = res | mask;
            }

            return res;
        }

        static __forceinline uint32_t CallClosureEncryption(Instruction instr, uint32_t pc, int a, int b, int c)
        {
            uint32_t res = 0;

            for (unsigned int mask = 1; mask; mask <<= 1)
            {
                auto x = pc + res * a;
                auto y = pc + res * b + c;

                if ((mask & (x ^ y)) != (mask & instr))
                    res = res | mask;
            }

            return res;
        }

        /* Abuse double rot bijection (still have to bruteforce ): ) */
        static __forceinline Instruction InverseRot(Instruction Inst, int rotr, int rotl)
        {
            VM_MUTATE_ONLY_START;

            auto res = Inst;

            for (uint8_t i = 0; i < 5; i++)
            {
                res = res ^ _rotr(res, rotr) ^ _rotl(res, rotl);
                rotr = rotr * 2 % 32;
                rotl = rotl * 2 % 32;
            }
            
            VM_MUTATE_ONLY_END;

            return res;
        }

        static __forceinline Instruction JumpEncode(Instruction Inst, uint32_t PC)
        {
            return InverseRot(Inst ^ OBFUSCATED_NUM(0xFFFFD8AF) * PC & OBFUSCATED_NUM(0x3FFFF), 6, 9);
        }

        static __forceinline Instruction JumpDecode(Instruction Inst, uint32_t PC)
        {
            return Inst ^ (OBFUSCATED_NUM(0xFFFFD8AF) * PC & OBFUSCATED_NUM(0x3FFFF) ^ (_rotr(Inst, 6) ^ _rotl(Inst, 9)));
        }

        static __forceinline Instruction JumpEncryption(Instruction Inst, uint32_t PC)
        {
            for (auto i = 0; i <= MAXARG_A; i++)
            {
                auto NewInstr = Inst;
                RSETARG_A(NewInstr, i);

                auto Sol = JumpEncode(NewInstr, PC);
                RSET_OPCODE(Sol, ReadROpcode(OP_JMP));

                if (NewInstr == JumpDecode(Sol, PC))
                    return Sol;
            }

            return NULL;
        }

        static __forceinline Instruction SetUpvalEncode(Instruction Inst, uint32_t PC)
        {
            return InverseRot(Inst ^ OBFUSCATED_NUM(0x961C86) * PC & OBFUSCATED_NUM(0x3FC01FF), 7, 13);
        }

        static __forceinline Instruction SetUpvalDecode(Instruction Inst, uint32_t PC)
        {
            return Inst ^ (OBFUSCATED_NUM(0x961C86) * PC & OBFUSCATED_NUM(0x3FC01FF) ^ (_rotr(Inst, 7) ^ _rotl(Inst, 13)));
        }

        static __forceinline Instruction SetUpvalEncryption(Instruction Inst, uint32_t PC)
        {
            for (auto i = 0; i <= MAXARG_C; i++)
            {
                auto NewInstr = Inst;
                RSETARG_C(NewInstr, i);

                auto Sol = SetUpvalEncode(NewInstr, PC);
                RSET_OPCODE(Sol, ReadROpcode(OP_SETUPVAL));

                if (NewInstr == SetUpvalDecode(Sol, PC))
                    return Sol;
            }

            return NULL;
        }

        DWORD ConvertEncrypt(Instruction Inst, uint32_t PC) const
        {
            DWORD RInst = 0;
            const Instruction Op = GET_OPCODE(Inst);
            RSET_OPCODE(RInst, ReadROpcode(Op));

            switch (getOpMode(Op))
            {
                case iABC:
                    RSETARG_A(RInst, GETARG_A(Inst));
                    RSETARG_B(RInst, GETARG_B(Inst));
                    RSETARG_C(RInst, GETARG_C(Inst));
                    break;

                case iABx:
                    RSETARG_A(RInst, GETARG_A(Inst));
                    RSETARG_Bx(RInst, GETARG_Bx(Inst));
                    break;

                case iAsBx:
                    RSETARG_A(RInst, GETARG_A(Inst));
                    RSETARG_sBx(RInst, GETARG_sBx(Inst));
                    break;

                default: break;
            }

            switch (Op)
            {
                case OP_JMP:
                    RInst = JumpEncryption(RInst, PC);
                    RSET_OPCODE(RInst, ReadROpcode(Op));
                    break;

                case OP_CALL:
                    RInst = CallClosureEncryption(RInst, PC, OBFUSCATED_NUM(0x1F3D8AF), (int)OBFUSCATED_NUM(-0x1C6B438), (int)OBFUSCATED_NUM(-0x541B9F));
                    RSET_OPCODE(RInst, ReadROpcode(Op));
                    break;

                case OP_RETURN:
                    RInst = RetEncrypt(RInst, PC);
                    RSET_OPCODE(RInst, ReadROpcode(Op));
                    break;

                case OP_CLOSURE:
                    RInst = CallClosureEncryption(RInst, PC, (int)OBFUSCATED_NUM(0x961C86), (int)OBFUSCATED_NUM(0x1F3D8AF), (int)OBFUSCATED_NUM(-0x1C0BCC3));
                    RSET_OPCODE(RInst, ReadROpcode(Op));
                    break;

                case OP_SETUPVAL:
                    RInst = SetUpvalEncryption(RInst, PC);
                    RSET_OPCODE(RInst, ReadROpcode(Op));
                    break;

                case OP_MOVE:
                    RSETARG_C(RInst, 1); /* convex: lets add a useless part to our MOVE instruction, that will stop them! */
                    break;

                default: break;
            }

            return RInst * EncodeKey;
        }

        DWORD ConvertDecrypt(DWORD RInst, DWORD PC) const
        {
            DWORD Inst = 0;
            RInst *= DecodeKey;

            const int ROpCode = RGET_OPCODE(RInst);
            const auto LOpCode = ReadLOpcode(ROpCode);

            switch (LOpCode)
            {
                case OP_SETUPVAL:
                    RInst ^= OBFUSCATED_NUM(0x961C86) * PC & OBFUSCATED_NUM(0x3FC01FF) ^ _rotr(RInst, 7) ^ _rotl(RInst, 13);
                    break;
                case OP_JMP:
                    RInst ^= OBFUSCATED_NUM(0xFFFFD8AF) * PC & OBFUSCATED_NUM(0x3FFFF) ^ _rotr(RInst, 6) ^ _rotl(RInst, 9);
                    break;
                case OP_CALL:
                    RInst = PC + OBFUSCATED_NUM(0x1F3D8AF) * RInst ^ PC - OBFUSCATED_NUM(0x1C6B438) * RInst - OBFUSCATED_NUM(0x541B9F);
                    break;
                case OP_CLOSURE:
                    RInst = PC + OBFUSCATED_NUM(0x961C86) * RInst ^ OBFUSCATED_NUM(0x1F3D8AF) * RInst + PC - OBFUSCATED_NUM(0x1C0BCC3);
                    break;
                case OP_RETURN:
                    RInst = RInst * (PC + OBFUSCATED_NUM(0x1F3D8AF)) - OBFUSCATED_NUM(0x1C0BCC3) ^ PC * RInst - OBFUSCATED_NUM(0x541B9F);
                    break;
                default:
                    break;
            }

            SET_OPCODE(Inst, LOpCode);

            switch (getOpMode(GET_OPCODE(Inst)))
            {
                case iABC:
                {
                    SETARG_A(Inst, RGETARG_A(RInst));
                    SETARG_B(Inst, RGETARG_B(RInst));
                    SETARG_C(Inst, RGETARG_C(RInst));
                    break;
                }
                case iABx:
                {
                    SETARG_A(Inst, RGETARG_A(RInst));
                    SETARG_Bx(Inst, RGETARG_Bx(RInst));
                    break;
                }
                case iAsBx:
                {
                    SETARG_A(Inst, RGETARG_A(RInst));
                    SETARG_sBx(Inst, RGETARG_sBx(RInst));
                    break;
                }
            }

            return Inst;
        }

        explicit InstructionTranslator(DWORD EncKey, DWORD DecKey)
        {
            EncodeKey = EncKey;
            DecodeKey = DecKey;
        }
    };
}