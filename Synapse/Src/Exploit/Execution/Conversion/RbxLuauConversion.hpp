
/*
*
*	SYNAPSE X
*	File.:	RbxLuauConversion.hpp
*	Desc.:	Lua -> Luau conversion
*
*/

#pragma once
#include "../../Misc/Static.hpp"
#include "../../../Utilities/Obfuscation/ObfuscatedNumber.hpp"
#include "../../Misc/Structures.hpp"

namespace syn
{
#if defined(EnableLuaUDecompiler) || defined(EnableLuaUTranslator)
	extern uint8_t LuaU_MagicMul;

#pragma pack(push, 1)
	union LuauInstruction
	{
		struct
		{
			uint8_t OpCode;
			uint8_t A;
			union
			{
				struct
				{
					uint8_t B;
					uint8_t C;
				};
				uint16_t Bx;
				int16_t sBx;
			};
		};
		uint32_t Value;

		[[nodiscard]] uint32_t GetAx() const { return Value >> 8; }
		[[nodiscard]] int32_t GetsAx() const { return (int32_t) GetAx(); }
		void SetAx(const uint32_t value) { Value = Value & 0xFF | value << 8; }
		void SetsAx(const int32_t value) { SetAx((uint32_t) value); }

		explicit LuauInstruction()
		{
			Value = 0;
		}

		explicit LuauInstruction(const Instruction C)
		{
			Value = C;
		}

		void SetOpCode(const uint8_t ROpCode)
		{
			OpCode = (uint8_t)((uint8_t)ROpCode * LuaU_MagicMul);
		}

		explicit operator Instruction() const
		{
			return Value;
		}

		explicit operator DWORD() const
		{
			return Value;
		}
	};
	static_assert(sizeof(LuauInstruction) == sizeof(uint32_t), "LuauInstruction size mismatch");
#pragma pack(pop)
#endif

#ifdef EnableLuaUTranslator
	/* OneWay = Lua -> Luau, TwoWay = Lua -> Luau -> Lua */
	class OneWayLuauTranslator
	{
	private:
		Proto* CurrentProto = nullptr;
	public:
		__declspec(noinline) std::vector<LuauInstruction> Convert(Instruction* Instrs, size_t Size) const;

		OneWayLuauTranslator(Proto* p)
		{
			CurrentProto = p;
		}
	};
#endif

#ifdef EnableLuaUDecompiler
	/* OneWay = Lua -> Luau, TwoWay = Lua -> Luau -> Lua */
	class OneWayLuauDecompiler
	{
	public:
		__declspec(noinline) static std::vector<LuauInstruction> Convert(LuauInstruction* OInstrs, size_t Size);
	};
#endif
}
