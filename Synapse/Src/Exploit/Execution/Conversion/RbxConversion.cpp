#include "../../../Utilities/Obfuscation/ObfuscatedString.hpp"
#include "../../../Utilities/Utils.hpp"
#include "../../Misc/Profiler.hpp"
#include "../../Security/AntiDump.hpp"
#include "./RbxConversion.hpp"
#include "../RbxApi.hpp"
#include "../../Security/AntiDebug.hpp"
#include "../../Misc/PointerObfuscation.hpp"
#include "./RbxLuauConversion.hpp"

#pragma warning(disable : 4146)
namespace syn
{
	int LastDefineKey;

	DWORD CreateString(RbxLua RS, TString* Str)
	{
		DWORD Ptr = RS.NewLString(getstr(Str), Str->tsv.len);
		//l_setbit(*(BYTE*)(Ptr + GCO_MARKED), FIXEDBIT);
		return Ptr;
	}

	DWORD CreateString(RbxLua RS, const std::string& Str)
	{
		DWORD Ptr = RS.NewLString(Str.c_str(), Str.length());
		//l_setbit(*(BYTE*)(Ptr + GCO_MARKED), FIXEDBIT);
		return Ptr;
	}

    FORCEINLINE uint32_t ModInverse(uint32_t a)
	{
        VM_MUTATE_ONLY_START;

		uint32_t x;
		x = 3 * a ^ 2; // 5 bits
		x *= 2 - a * x; // 10
		x *= 2 - a * x; // 20
		x *= 2 - a * x; // 40 -- 32 low bits

        VM_MUTATE_ONLY_END;

		return x;
	}

	DWORD SolveProtoHash(std::unique_ptr<Structures::rProto>& P, DWORD DecodeKey)
	{
        VM_TIGER_WHITE_START;
		
		int SizeP = P->sizep;
        int SizeCode = P->sizecode;
        int SizeK = P->sizek;
        Instruction* Code = P->code;

        short ShuffleHi = MAKEWORD(P->is_vararg, P->maxstacksize);
        short ShuffleLow = MAKEWORD(P->numparams, P->nups);

        int Shuffle = MAKELONG(ShuffleLow, ShuffleHi);

		DWORD Const1 = OBFUSCATED_NUM(-0x532ABD45) * SizeK - OBFUSCATED_NUM(0x6D991385) * Shuffle -
			OBFUSCATED_NUM(0x76D62959) * SizeP - OBFUSCATED_NUM(0x43111B53) * SizeCode;

        DWORD Const2 = OBFUSCATED_NUM(0x1C5FB920) * SizeK + OBFUSCATED_NUM(0x5C326D8F) * SizeP -
			OBFUSCATED_NUM(0x2A18BD67) * SizeCode - OBFUSCATED_NUM(0x7C78D027) * Shuffle;

        DWORD Hash = Const1;
		if (SizeCode <= 8)
		{
			Hash = Const2 ^ Const1;
		}
		else
		{
			/* Calculate the partial hash based on a 'random' 8 instructions */
            int InstructionBase = (Const1 + 4) % (unsigned int)(SizeCode - 4);
			Hash += RGET_OPCODE(DecodeKey * Code[InstructionBase])
				+ RGET_OPCODE(DecodeKey * Code[InstructionBase + 1])
				+ RGET_OPCODE(DecodeKey * Code[InstructionBase + 2])
				+ RGET_OPCODE(DecodeKey * Code[InstructionBase + 3]);

            InstructionBase = (Const2 + 4) % (unsigned int)(SizeCode - 4);
			Const2 += RGET_OPCODE(DecodeKey * Code[InstructionBase])
				+ RGET_OPCODE(DecodeKey * Code[InstructionBase + 1])
				+ RGET_OPCODE(DecodeKey * Code[InstructionBase + 2])
				+ RGET_OPCODE(DecodeKey * Code[InstructionBase + 3]);
		}

        VM_TIGER_WHITE_END;

		return syn::InstructionTranslator::InverseRot(Hash, 7, 11) * ModInverse(Const2 | 1);
	}

	void LuaTranslator::ConvertConstant(RbxLua RS, TValue* LVal, TValue* RVal) const
	{
		switch (ttype(LVal))
		{
			case LUA_TNIL:
				r_setnilvalue(RVal);
				break;
			case LUA_TBOOLEAN:
				r_setbvalue(RVal, bvalue(LVal));
				break;
			case LUA_TNUMBER:
				r_setnvalue(RVal, syn::RbxLua::XorDouble(nvalue(LVal)));
				break;
			case LUA_TSTRING:
				r_setsvalue(RVal, CreateString(RS, rawtsvalue(LVal)));
				break;
            default: break;
		}
	}

	DWORD LuaTranslator::ConvertProto(RbxLua RS, lua_State* L, Proto* LP, const std::string& Source)
	{
        VM_TIGER_WHITE_START;

        std::unique_ptr<Structures::rProto> P = std::make_unique<Structures::rProto>(RS.NewProto());
        P->source = Source.empty() ? (TString*)CreateString(RS, LP->source) : (TString*)CreateString(RS, Source);
        P->flag = 0;

        P->numparams = LP->numparams;
        P->maxstacksize = LP->maxstacksize;
		P->nups = LP->nups;
		P->is_vararg = LP->is_vararg;
        
		P->sizelocvars = LP->sizelocvars;
		P->sizecode = LP->sizecode;
        P->sizek = LP->sizek;
        P->sizelineinfo = LP->sizelineinfo;
        P->sizeupvalues = LP->sizeupvalues;
        P->sizep = LP->sizep;

		auto HSS = (HSvmSettings*) operator new(sizeof(HSvmSettings));
		HSS->VM = SECURELUA_VM_NONE;
		HSS->MulInvKey = LP->mulinvkey;

		if (LP->linedefined == 0x1FFF)
		{
			HSS->VM = SECURELUA_VM_MARKED;
		}
		if (LP->linedefined == 0x2FFF)
		{
			HSS->VM = SECURELUA_VM_MINIMAL;
		}
		if (LP->linedefined == 0x3FFF)
		{
			HSS->VM = SECURELUA_VM_LOW;
		}
		else if (LP->linedefined == 0x4FFF)
		{
			HSS->VM = SECURELUA_VM_MEDIUM;
		}
		else if (LP->linedefined == 0x5FFF)
		{
			HSS->VM = SECURELUA_VM_HIGH;
		}

        P->linedefined = (uint32_t) HSS;
		//This marks the proto as our own. I use this instead of is_vararg as using the other method causes performance problems (every function is treated as a vararg function, causing obvious issues)
        P->lastlinedefined = LastDefineKey;

        VM_TIGER_WHITE_END;

		HSS->ShadowK = (TValue*) operator new(sizeof(TValue) * LP->sizek);
		SecureZeroMemory((void*) HSS->ShadowK, sizeof(TValue) * LP->sizek);

		/* Convert initial allocations */
		P->p = (DWORD*) RS.Alloc(sizeof(int) * LP->sizep, 3);
        P->k = (TValue*) RS.Alloc(sizeof(TValue) * LP->sizek, 3);
		P->code = (Instruction*) RS.Alloc(sizeof(Instruction) * LP->sizecode, 3);
        P->locvars = (RLocVar*) RS.Alloc(sizeof(RLocVar) * LP->sizelocvars, 3);
        P->lineinfo = (int*) RS.Alloc(sizeof(int) * LP->sizelineinfo, 3);
        P->upvalues = (TString**) RS.Alloc(sizeof(TString*) * LP->sizeupvalues, 3);

#ifndef EnableHSVM
		if (IsLuaU)
		{
#ifdef EnableHSVMOnlyLuaU
			for (int pc = 0; pc < LP->sizecode; ++pc)
			{
				Instruction LInstr = LP->code[pc];

				/* Tailcalls are not generated */
				if (HSS->VM < SECURELUA_VM_LOW && GET_OPCODE(LInstr) == OpCode::OP_TAILCALL)
					SET_OPCODE(LInstr, OpCode::OP_CALL);
				P->code[pc] = LInstr;
			}
#endif
#ifdef EnableLuaUTranslator
			const auto Conv = syn::OneWayLuauTranslator(LP).Convert(LP->code, LP->sizecode);

			P->sizecode = Conv.size();
			P->code = (Instruction*) RS.Alloc(sizeof(Instruction) * Conv.size(), 3);

			for (auto i = 0; i < Conv.size(); i++)
				P->code[i] = (Instruction)Conv[i];
#endif
		}
		else
		{
#endif
			for (int pc = 0; pc < LP->sizecode; ++pc)
			{
				Instruction LInstr = LP->code[pc];

				/* Tailcalls are not generated */
				if (HSS->VM < SECURELUA_VM_LOW && GET_OPCODE(LInstr) == OpCode::OP_TAILCALL)
					SET_OPCODE(LInstr, OpCode::OP_CALL);

#ifndef EnableHSVM

				/* Extended setlist contains a psuedo-instruction */
				if (HSS->VM < SECURELUA_VM_LOW && GET_OPCODE(LInstr) == OpCode::OP_SETLIST && GETARG_C(LInstr) == 0)
					pc++;
				else
					P->code[pc] = InstTranslator->ConvertEncrypt(LInstr, pc);
#else
				P->code[pc] = LInstr;
#endif
			}
#ifndef EnableHSVM
		}
#endif

        for (int i = 0; i < LP->sizek; ++i)
            ConvertConstant(RS, &LP->k[i], &P->k[i]);

        for (int i = 0; i < LP->sizelocvars; ++i)
        {
            LocVar* LV = &LP->locvars[i];
            RLocVar* RLV = &P->locvars[i];

            RLV->startpc = LV->startpc;
            RLV->endpc = LV->endpc;
            RLV->varname = (TString*)CreateString(RS, LV->varname);
        }

        for (int i = 0; i < P->sizelineinfo; ++i)
            P->lineinfo[i] = LP->lineinfo[i];  //^ i << 8;

        for (int i = 0; i < LP->sizeupvalues; ++i)
            P->upvalues[i] = (TString*)CreateString(RS, LP->upvalues[i]);

		/* Generate proto hash */
		P->hash = SolveProtoHash(P, DK);

		/* Convert inner protos */
		for (auto i = 0; i < LP->sizep; ++i)
			P->p[i] = ConvertProto(RS, L, LP->p[i], "");

		return P->Proto;
	}

	TString* LuaTranslator::DumpString(RbxLua RS, lua_State* LS, TString* Str)
	{
		return luaS_newlstr(LS, RS.GetStr(Str), RS.RawSLen(Str));
	}

	void LuaTranslator::DumpCode(RbxLua RS, Proto* P, DWORD* RCode) const
	{
		for (int i = 0; i < P->sizecode; i++)
		{
			const auto Inst = InstTranslator->ConvertDecrypt(RCode[i], i);

			P->code[i] = Inst;

			if (GET_OPCODE(Inst) == OpCode::OP_SETLIST && GETARG_C(Inst) == 0)
			{
				i++;

				//This is a extended SETLIST instruction, we need to treat the next psuedo-instruction as data.
				P->code[i] = RCode[i] * InstTranslator->DecodeKey;
			}
		}
	}

	void LuaTranslator::DumpConstant(RbxLua RS, lua_State* LS, TValue* LVal, TValue* RVal) const
	{
		switch (ttype(RVal))
		{
			case R_LUA_TNIL:
				setnilvalue(LVal);
				break;
			case R_LUA_TBOOLEAN:
				setbvalue(LVal, bvalue(RVal));
				break;
			case R_LUA_TNUMBER:
				setnvalue(LVal, syn::RbxLua::XorDouble(nvalue(RVal)))
				break;
			case R_LUA_TSTRING:
				setsvalue(LS, LVal, DumpString(RS, LS, rawtsvalue(RVal)));
				break;
			default:
				setnilvalue(LVal);
				break;
		}
	}

	Proto* LuaTranslator::DumpProto(RbxLua RS, lua_State* LS, DWORD P) const
	{
		Proto* LP = luaF_newproto(LS);
        std::unique_ptr<Structures::rProto> rP = std::make_unique<Structures::rProto>(P);

		/* Convert source */
		LP->source = DumpString(RS, LS, rP->source);

        VM_TIGER_WHITE_START;

		LP->numparams = rP->numparams;
		LP->maxstacksize = rP->maxstacksize;
		LP->nups = rP->nups;
		LP->is_vararg = rP->is_vararg;

		LP->sizelocvars = rP->sizelocvars;
		LP->sizecode = rP->sizecode;
		LP->sizek = rP->sizek;
		LP->sizelineinfo = rP->sizelineinfo;
		LP->sizeupvalues = rP->sizeupvalues;
		LP->sizep = rP->sizep;

		LP->linedefined = rP->linedefined;
		LP->lastlinedefined = rP->lastlinedefined;

        VM_TIGER_WHITE_END;

		/* Create initial allocations */
		LP->p = luaM_newvector(LS, LP->sizep, Proto*);
		LP->code = luaM_newvector(LS, LP->sizecode, Instruction);
		LP->k = luaM_newvector(LS, LP->sizek, TValue);
		LP->locvars = luaM_newvector(LS, LP->sizelocvars, LocVar);
		LP->lineinfo = luaM_newvector(LS, LP->sizelineinfo, int);
		LP->upvalues = luaM_newvector(LS, LP->sizeupvalues, TString*);

#ifdef EnableLuaUDecompiler
		if (IsLuaU)
		{
			VM_TIGER_WHITE_START

			auto Converted = syn::OneWayLuauDecompiler::Convert((LuauInstruction*) &rP->code[0], LP->sizecode);
			memcpy((void*) &LP->code[0], &Converted[0], LP->sizecode * sizeof(LuauInstruction));

			VM_TIGER_WHITE_END
		}
		else
		{
#endif
			for (int pc = 0; pc < LP->sizecode; ++pc)
			{
				const auto Inst = InstTranslator->ConvertDecrypt(rP->code[pc], pc);
				LP->code[pc] = Inst;

				/* Extended setlist contains a psuedo-instruction */
				if (GET_OPCODE(Inst) == OpCode::OP_SETLIST && GETARG_C(Inst) == 0)
				{
					pc++;

					LP->code[pc] = rP->code[pc] * InstTranslator->DecodeKey;
				}
			}
#ifdef EnableLuaUDecompiler
		}
#endif

        for (int i = 0; i < LP->sizek; ++i)
            DumpConstant(RS, LS, &LP->k[i], &rP->k[i]);

        for (int i = 0; i < LP->sizelocvars; ++i)
        {
            RLocVar* RLV = &rP->locvars[i];
            LocVar* LV = &LP->locvars[i];
            
            LV->startpc = RLV->startpc;
            LV->endpc = RLV->endpc;
            LV->varname = (TString*)DumpString(RS, LS, RLV->varname);
        }

        for (int i = 0; i < LP->sizelineinfo; i++)
        {
            LP->lineinfo[i] = rP->lineinfo[i]; //^ i << 8;
        }

        for (int i = 0; i < LP->sizeupvalues; i++)
        {
            LP->upvalues[i] = DumpString(RS, LS, rP->upvalues[i]);
        }

		/* Convert inner protos */
		for (int i = 0; i < LP->sizep; i++)
			LP->p[i] = DumpProto(RS, LS, rP->p[i]);

		return LP;
	}

	void LuaTranslator::ConvertInCurrentThread(RbxLua RL, const std::string& Script, std::uint8_t ScriptMode, std::string* ChunkName)
	{
        VM_TIGER_WHITE_START;
		/* Create our randomly generated chunk name */
		std::string Src = "@" + RandomString(RandomInteger(10, 24));
		if (ChunkName == nullptr)
			ChunkName = &Src;
		ChunkNamesVec.push_back(Src.substr(1));

		syn::Profiler* prof = syn::Profiler::GetSingleton();
		prof->AddProfile(OBFUSCATE_STR("New state"));

        VM_TIGER_WHITE_END;

		lua_State* NState = luaL_newstate();

#ifdef EnableHSVM
		int BytecodeStyle = BS_HSVM;
#else
		int BytecodeStyle = IsLuaU ? BS_HSVM : BS_SYNAPSE;
#endif
		if (ScriptMode)
			BytecodeStyle = BS_SECURELUA;

		if (luaL_loadbuffer(NState, Script.c_str(), Script.size(), BytecodeStyle, ChunkName->c_str()))
		{
			/* Error while compiling, report back to translation caller */
			std::string Err = lua_tostring(NState, -1);
			lua_close(NState);
			throw std::exception(Err.c_str());
		}

		Closure* C = (Closure*) lua_topointer(NState, -1);
		Proto* LP = C->l.p;

        VM_TIGER_WHITE_START;
		prof->AddProfile(OBFUSCATE_STR("Convert start"));

		/* Convert */
		DWORD RP = ConvertProto(RL, NState, LP, Src);

		prof->AddProfile(OBFUSCATE_STR("Closure start"));

		/* Set our environment to untouched if we are on LuaU */
		if (IsLuaU)
		{
			*(uint8_t*)(*(uintptr_t*)(RL + L_ENV) + T_UNTOUCHED) = 1;
		}

        DWORD LC = RL.NewLClosure(0 /* No upvals */, *(BYTE*)(RP + PO_MAXSTACKSIZE), *(DWORD*)(RL + L_ENV));

		prof->AddProfile(OBFUSCATE_STR("Obfuscate"));

        syn::PointerObfuscation::ObfuscateLClosure(LC + 20, RP); /* obfuscate proto ptr */

        VM_TIGER_WHITE_END;

		/* Push LClosure to stack */
        r_setclvalue(*(TValue**)(RL + L_TOP), LC);
        r_incr_top(RL);

		prof->AddProfile(OBFUSCATE_STR("Close"));

		/* Close */
		lua_close(NState);

		prof->AddProfile(OBFUSCATE_STR("Conversion done!"));
	}

	RbxLua LuaTranslator::Convert(RbxLua RS, const std::string& Script, std::uint8_t ScriptMode, std::string* ChunkName)
	{
        VM_TIGER_WHITE_START;

		if (syn::AntiDump::Check())
			CrashRoblox(true, OBFUSCATE_STR("AntiDump - #4"));

		if (syn::AntiDebug::Check())
			CrashRoblox(true, OBFUSCATE_STR("AntiDebug - #4.5"));

		syn::Profiler* prof = syn::Profiler::GetSingleton();
		prof->AddProfile(OBFUSCATE_STR("New thread"));

		RbxLua RL = RS.NewThread(false);
		RS.SetField(LUA_REGISTRYINDEX, RandomString(16).c_str());

		prof->AddProfile(OBFUSCATE_STR("Setup thread"));

		RL.SetupThread();
		RL.SetIdentity(6);

		prof->AddProfile(OBFUSCATE_STR("Set script global"));

		/* script = Instance.new("LocalScript") script.Name = <random> */
		RL.GetGlobal(OBFUSCATE_STR("Instance"));
		RL.GetField(-1, OBFUSCATE_STR("new"));
		RL.PushString(OBFUSCATE_STR("LocalScript"));
		RL.PCall(1, 1, 0);

		RL.PushString(RandomString(RandomInteger(10, 24)).c_str());
		RL.SetField(-2, OBFUSCATE_STR("Name"));
		RL.SetGlobal(OBFUSCATE_STR("script"));
		RL.SetTop(0);

		ConvertInCurrentThread(RL, Script, ScriptMode, ChunkName);
        VM_TIGER_WHITE_END;

		return RL;
	}

	int LuaTranslator::DumpWriter(lua_State* L, const void* b, size_t size, void* B)
	{
		UNUSED(L);
		luaL_addlstring((luaL_Buffer*)B, (const char*)b, size);
		return 0;
	}

	std::string LuaTranslator::Dump(RbxLua RS, bool Strip) const
	{
        VM_TIGER_WHITE_START;

		/* Get proto pointer */
		DWORD P = RS.ToPointer(-1);

		if (RS.Type(-1) != R_LUA_TPROTO)
			P = syn::PointerObfuscation::DeObfuscateLClosure(P + 20);

		lua_State* NState = luaL_newstate();

		/* Do conversion */
		Proto* LP = DumpProto(RS, NState, P);

		/* Create LClosure */
		Closure* LC = luaF_newLclosure(NState, LP->nups, hvalue(gt(NState)));
		LC->l.p = LP;
		for (DWORD i = 0; i < LP->nups; i++) LC->l.upvals[i] = luaF_newupval(NState);
		setclvalue(NState, NState->top, LC);
		incr_top(NState);
        
        VM_TIGER_WHITE_END;

		/* Dump bytecode */
		luaL_Buffer B;
		luaL_buffinit(NState, &B);
		if (Strip) { if (lua_dump_strip(NState, DumpWriter, &B) != 0) throw std::exception("failed to dump bytecode"); }
		else { if (lua_dump(NState, DumpWriter, &B) != 0) throw std::exception("failed to dump bytecode"); }
		luaL_pushresult(&B);
		size_t Len;
		const char* BC = lua_tolstring(NState, -1, &Len);

		std::string Res(BC, Len);

		/* Close */
		lua_close(NState);

		/* Done! */
		return Res;
	}

	Proto* LuaTranslator::DumpToProto(lua_State* NState, RbxLua RS) const
	{
		DWORD P = RS.ToPointer(-1);
		return DumpProto(RS, NState, P);
	}

	Closure* LuaTranslator::DumpToFunc(lua_State* NState, RbxLua RS) const
	{
        VM_TIGER_WHITE_START;

		/* Get proto pointer */
		DWORD RLC = RS.ToPointer(-1);
		DWORD P = syn::PointerObfuscation::DeObfuscateLClosure(RLC + 20);

		/* Do conversion */
		Proto* LP = DumpProto(RS, NState, P);

		/* Create LClosure */
		Closure* LC = luaF_newLclosure(NState, LP->nups, hvalue(gt(NState)));
		LC->l.p = LP;
		for (DWORD i = 0; i < LP->nups; i++) LC->l.upvals[i] = luaF_newupval(NState);

        VM_TIGER_WHITE_END;

		/* Done! */
		return LC;
	}

	void LuaTranslator::CloneConstant(RbxLua RL, TValue* Constants, int Index)
	{
		switch (Constants[Index].tt)
		{
			case R_LUA_TNIL:
			{
				RL.PushNil();
				break;
			}
			case R_LUA_TBOOLEAN:
			{
				RL.PushBoolean(Constants[Index].value.b);
				break;
			}
			case R_LUA_TNUMBER:
			{
				RL.PushNumber(syn::RbxLua::XorDouble(Constants[Index].value.n));
				break;
			}
			case R_LUA_TSTRING:
			{
				RL.PushObject(&Constants[Index]);
				std::size_t Size;
				const char* CStr = RL.ToLString(-1, &Size);
				RL.Pop(1);
				RL.PushLString(CStr, Size);
				break;
			}
			case R_LUA_TFUNCTION:
			case R_LUA_TUSERDATA:
			{
				RL.PushObject(&Constants[Index]);
				break;
			}
			default:
			{
				RL.PushNil();
				break;
			}
		}
	}

	TValue* LuaTranslator::GetConstantsPointer(RbxLua RS, int index, int& sizek)
	{
		const auto RLC = RS.ToPointer(index);
		Structures::rProto P(syn::PointerObfuscation::DeObfuscateLClosure(RLC + 20));
		sizek = P.sizek;

		return (TValue*) P.k;
	}

	TString** LuaTranslator::GetUpvaluesPointer(RbxLua RS, int index, int& sizeupvalues)
	{
		const auto RLC = RS.ToPointer(index);
        Structures::rProto P(syn::PointerObfuscation::DeObfuscateLClosure(RLC + 20));
		sizeupvalues = P.sizeupvalues;

		return (TString**)P.upvalues;
	}

	BOOL LuaTranslator::GetSynapseMarked(RbxLua RS, int index)
	{
		DWORD P = RS.ToPointer(index);

		if (RS.Type(index) != R_LUA_TPROTO)
			P = syn::PointerObfuscation::DeObfuscateLClosure(P + 20);

		return syn::Structures::rProto(P).lastlinedefined == LastDefineKey;
	}

	HSvmSettings* LuaTranslator::GetHsvmSettings(RbxLua RS, int index)
	{
		if (RS.IsCFunction(index))
			return nullptr;

		DWORD P = RS.ToPointer(index);

		if (RS.Type(index) != R_LUA_TPROTO)
			P = syn::PointerObfuscation::DeObfuscateLClosure(P + 20);

		auto Proto = syn::Structures::rProto(P);

		if (Proto.lastlinedefined != LastDefineKey)
			return nullptr;

		return (HSvmSettings*) (std::uintptr_t) Proto.linedefined;
	}

	LuaTranslator* LuaTranslator::GetSingleton()
	{
		static LuaTranslator* Singleton;
		if (!Singleton)
			Singleton = new LuaTranslator();
		return Singleton;
	}

	void LuaTranslator::SetDecodeKey(const DWORD Decode)
	{
		DK = Decode;
		EK = ModInverse(DK);

		InstTranslator = new syn::InstructionTranslator(EK, DK);
	}
}
