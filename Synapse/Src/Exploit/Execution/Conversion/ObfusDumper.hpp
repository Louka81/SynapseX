
/*
*
*	SYNAPSE X
*	File.:	ObfusDumper.hpp
*	Desc.:	Obfuscated bytecode format for Synapse unluac.
*
*/

#pragma once

#include "../../../Utilities/Buffer.hpp"
#include "../../../Source Dependencies/xxtea/xxtea.h"

const char ObfOpcodes[NUM_OPCODES]
{
	32, // OP_MOVE
	30, // OP_LOADK
	28, // OP_LOADBOOL
	34, // OP_LOADNIL
	19, // OP_GETUPVAL
	27, // OP_GETGLOBAL
	12, // OP_GETTABLE
	21, // OP_SETGLOBAL
	29, // OP_SETUPVAL
	2, // OP_SETTABLE
	33, // OP_NEWTABLE
	11, // OP_SELF
	35, // OP_ADD
	23, // OP_SUB
	17, // OP_MUL
	5, // OP_DIV
	4, // OP_MOD
	26, // OP_POW
	13, // OP_UNM
	10, // OP_NOT
	7, // OP_LEN
	0, // OP_CONCAT
	31, // OP_JMP
	15, // OP_EQ
	20, // OP_LT
	3, // OP_LE
	9, // OP_TEST
	25, // OP_TESTSET
	24, // OP_CALL
	1, // OP_TAILCALL
	6, // OP_RETURN
	37, // OP_FORLOOP
	16, // OP_FORPREP
	14, // OP_TFORLOOP
	18, // OP_SETLIST
	22, // OP_CLOSE
	8, // OP_CLOSURE
	36, // OP_VARARG
};

namespace syn
{
	class ObfuscatedDumper
	{
		LClosure Func;
		Buffer Serial;
		uint32_t XorKey;
		uint32_t XorKey2;

		__forceinline void DumpByte(const uint8_t X)
		{
			Serial.writeUInt8(X ^ XorKey % OBFUSCATED_NUM(128));
		}

		__forceinline void DumpInt(uint32_t X)
		{
			const auto Arr = (uint8_t*) &X;

			for (uint8_t i = 0; i < 4; i++)
			{
				Arr[i] ^= (uint8_t) (XorKey2 % (OBFUSCATED_NUM(32) * (i + 1)));
			}

			Serial.writeUInt32_LE(~(X ^ XorKey));
		}

		__forceinline void DumpDouble(double X)
		{
			const auto Arr = (uint8_t*) &X;

			for (uint8_t i = 0; i < 8; i++)
			{
				Arr[i] ^= (uint8_t) (XorKey2 % (OBFUSCATED_NUM(32) * (i % 3 + 1)));
			}

			Serial.writeUInt64_LE(~(*(uint64_t*) &X ^ ((uint64_t) XorKey << OBFUSCATED_NUM(32) | XorKey2)));
		}

		__forceinline void DumpString(TString* X)
		{
			if (X == nullptr || getstr(X) == nullptr)
			{
				DumpInt(0);
			}
			else
			{
				size_t Size = X->tsv.len + 1;
				DumpInt(Size);
				const char* Dmp = getstr(X);

				for (size_t i = 0; i < Size; i++)
				{
					Serial.writeUInt8(Dmp[i] ^ (uint8_t) (XorKey2 % (OBFUSCATED_NUM(32) * (i % 3 + 1))));
				}
			}
		}

		__declspec(noinline) void DumpConstants(const Proto* f)
		{
            VM_TIGER_WHITE_START;

			int i, n = f->sizek;
			DumpInt(n);

            VM_TIGER_WHITE_END;

			for (i = 0; i < n; i++)
			{
				const TValue* o = &f->k[i];
				DumpByte(ttype(o) ^ XorKey2 % OBFUSCATED_NUM(32));

				switch (ttype(o))
				{
					case LUA_TNIL:
						break;
					case LUA_TBOOLEAN:
						MUTATE_START
						DumpByte(bvalue(o));
						MUTATE_END
						break;
					case LUA_TNUMBER:
						MUTATE_START
						DumpDouble(nvalue(o));
						MUTATE_END
						break;
					case LUA_TSTRING:
						MUTATE_START
						DumpString(rawtsvalue(o));
						MUTATE_END
						break;
					default:
						lua_assert(0);
						break;
				}
			}

            VM_TIGER_WHITE_START;

			n = f->sizep;
			DumpInt(n);

			for (i = 0; i < n; i++) DumpFunction(f->p[i], f->source);

            VM_TIGER_WHITE_END;
		}

		__declspec(noinline) void DumpDebug(const Proto* f)
		{
            VM_TIGER_WHITE_START;

			int i;

			auto n = f->sizelocvars;
			DumpInt(n);
			for (i = 0; i < n; i++)
			{
				DumpString(f->locvars[i].varname);
				DumpInt(f->locvars[i].startpc);
				DumpInt(f->locvars[i].endpc);
			}

			n = f->sizelineinfo;
			DumpInt(n);
			for (i = 0; i < n; i++)
			{
				DumpInt(f->lineinfo[i]);
			}

			n = f->sizeupvalues;
			DumpInt(n);
			for (i = 0; i < n; i++) DumpString(f->upvalues[i]);

            VM_TIGER_WHITE_END;
		}

		__declspec(noinline) void DumpCode(const Instruction* Insts, size_t Size)
		{
            VM_TIGER_WHITE_START;

			DumpInt(Size);
			const auto CodeKey = RandomInteger(0, INT_MAX);
			DumpInt(CodeKey);

			for (uint32_t i = 0; i < Size; i++)
			{
				auto Inst = Insts[i];

				const auto Op = GET_OPCODE(Inst);
				SET_OPCODE(Inst, ObfOpcodes[Op]);

				if (Op == OP_NOT || Op == OP_MOVE)
				{
					SETARG_C(Inst, CodeKey % OBFUSCATED_NUM(64));
				}

				DumpInt(Inst);
			}

            VM_TIGER_WHITE_END;
		}

		__declspec(noinline) void DumpFunction(const Proto* f, const TString* p)
		{
            VM_TIGER_WHITE_START;

			DumpByte(f->maxstacksize);
			DumpInt(f->lastlinedefined);
			DumpInt(f->linedefined);
			DumpString(f->source == p ? NULL : f->source);
			DumpByte(f->numparams);
			DumpByte(f->nups);
			DumpByte(f->is_vararg);
			DumpCode(f->code, f->sizecode);
			DumpConstants(f);
			DumpDebug(f);

            VM_TIGER_WHITE_END;
		}

	public:
		ObfuscatedDumper(const LClosure F)
		{
            XorKey = 0;
            XorKey2 = 0;
			Func = F;
		}

		std::tuple<std::string, std::string> Dump()
		{
            VM_TIGER_WHITE_START;

			Serial.clear();

			Serial.writeStr(OBFUSCATE_STR("\033SYN"));

			auto x = 1;
			Serial.writeUInt8(0);
			Serial.writeUInt8((char) *(char*)&x);
			Serial.writeUInt8((char) sizeof(int));
			Serial.writeUInt8((char) sizeof(size_t));
			Serial.writeUInt8((char) sizeof(Instruction));
			Serial.writeUInt8((char) sizeof(lua_Number));
			Serial.writeUInt8((char) ((lua_Number) 0.5 == 0));

			XorKey = RandomInteger(0, INT_MAX);
			XorKey2 = RandomInteger(0, INT_MAX);
			Serial.writeUInt32_LE(XorKey ^ OBFUSCATED_NUM(0xb3d2335c));
			Serial.writeUInt32_LE(XorKey2 ^ OBFUSCATED_NUM(0x2fae219a));
			DumpFunction(Func.p, NULL);

			auto Buffer = Serial.getBuffer();
			auto SKey = RandomString(16);
			const auto SKeyGrab = (SKey.at(0) * OBFUSCATED_NUM(16777216) + SKey.at(1) * OBFUSCATED_NUM(65536) + SKey.at(2) * OBFUSCATED_NUM(256) + SKey.at(3)) % 128;

			for (size_t i = 0; i < Buffer.size(); i++)
			{
				Buffer[i] ^= SKeyGrab;
			}

			auto FStr = std::string(Buffer.begin(), Buffer.end());
			auto FKey = OBFUSCATE_STR("F8ixT9H4z8moGusU") + SKey;
			size_t FLen;
			auto FRet = xxtea_encrypt(FStr.c_str(), FStr.length(), FKey.c_str(), &FLen);

            VM_TIGER_WHITE_END;

			return std::make_tuple(Base64Encode((byte*) FRet, FLen), SKey);
		}
	};
}